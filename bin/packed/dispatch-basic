#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Pipeline/Lite4.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4';
  use strict;
  use warnings;
  package App::Pipeline::Lite4;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
  use Types::Path::Tiny qw/Path AbsPath/;
  extends 'App::Pipeline::Lite4::Base';
  use App::Pipeline::Lite4::Util;
  use App::Pipeline::Lite4::Parser; 
  use App::Pipeline::Lite4::Resolver;
  use App::Pipeline::Lite4::Grapher;
  use File::Copy;
  use Data::Dumper;
  has smoke_test => ( isa => 'Bool', is => 'rw', default => sub {0} ); 
  has external_dispatcher => ( isa => 'Path::Tiny|Undef', is => 'rw', 
                                lazy_build => 1 );
  
  sub _build_external_dispatcher {
      my $self = shift;  
        
      my $dispatcher = $self->config->{_}->{dispatcher}; #check local config 
      
      # if does not exist, check system config    
      $dispatcher = $self->system_config->{_}->{dispatcher} 
                                 unless defined( $dispatcher);
      
      defined($dispatcher) ?  path($dispatcher) : undef;    
  }
  
  sub util {
      my $self = shift;
      # give back object with utilities
      return App::Pipeline::Lite4::Util->new(  pipeline_dir => $self->pipeline_dir);
  }
  
  sub symlink {
      my $self      = shift;
      my $opt       = shift; # this is the options  with the id_field,symlinkdir if required
      #my $pipeline_file = shift;
      my $id_field = $opt->{id_field};
      
      
      my $parser = App::Pipeline::Lite4::Parser->new(
          pipeline_dir => $self->pipeline_dir,
       );
      
      $parser->preparse(  $self->pipeline_file, 
                          $self->pipeline_preparse_file ); 
      
      $parser->parse(  $self->pipeline_preparse_file, 
                       $self->pipeline_parse_file  );
      #warn "WORKING WITH DATASOURCE: " .    $self->datasource_file;
        
      my $resolver = App::Pipeline::Lite4::Resolver->new (                      
                         pipeline_dir         => $self->pipeline_dir,
                         #datasource_file     => $self->datasource_resolved_file,
                         datasource_file      => $self->datasource_file,
                         current_run_num      => defined( $self->run_num ) ? $self->run_num : undef,
                         step_filter_str      => defined( $self->step_filter_str) ? $self->step_filter_str : undef,
                         job_filter_str       => defined( $self->job_filter_str) ? $self->job_filter_str : undef,
                         #run_num_dep         => defined( $self->run_num_dep ) ? $self->run_num_dep : undef
                         );   
                         
      #warn Dumper $resolver->pipeline_datasource;                                          
      $resolver->resolve($self->pipeline_parse_file,$self->pipeline_resolved_file);
          
      my $datasource = $resolver->pipeline_datasource;
      
      # read resolved file YAML
      my $resolved_file_yaml = $self->pipeline_resolved_file->slurp;
      my $resolved_pipeline  = Load($resolved_file_yaml);
      my $output_run_dir = path( $self->output_dir, "run" . $self->run_num );
     
      foreach my $job_num (keys %$resolved_pipeline){
          my $job = $resolved_pipeline->{$job_num};         
          foreach my $step (keys %$job) {
              my $job_ids;   
              my $symlink_dir = path($resolver->symlink_dir, $step, $self->run_num);
              $symlink_dir->mkpath;
              my $condition = $job->{$step}->{condition};                   
              if(defined($condition) && $condition eq 'groupby'){
                 my $condition_params = $job->{$step}->{condition_params};
                 $job_ids = $self->_get_job_ids($id_field,$datasource,$condition_params);
                 my $num_jobs = scalar @$job_ids;
                 #warn "groupby step in symlink";
                 next if $job_num >= $num_jobs ;
              }else{
                 # get the job ids  
                 $job_ids = $self->_get_job_ids($id_field,$datasource,undef);
              }
  
              my $outputfiles = $job->{$step}->{outputfiles};
              foreach my $outputfile ( @$outputfiles ){
                 # warn "OUTPUTFILE: ", $outputfile,"\n";           
                 my  $outputfile_path = path($output_run_dir,"job$job_num",$step,$outputfile);  
                 # warn "LOOKING FOR $outputfile_path";          
                 if( $outputfile_path->exists ) {
                 #    warn "FOUND: ", $outputfile_path;
                    my $symlink_path = path($symlink_dir,$job_ids->[$job_num]);
                 #    warn "SYMLINK $outputfile_path $symlink_path";
                    my $path_to_link = $outputfile_path;
                    $self->_symlink_paths($job_num, $path_to_link,$job_ids,$symlink_dir,$opt->{name});
              }            
           }
           
           my $placeholders= $job->{$step}->{placeholders};
           foreach my $placeholder ( @$placeholders ){
             my $path_to_link;
             # warn "PLACEHOLDER: ", $placeholder,"\n";
              my ($file ) = $placeholder =~ /$step\.(.+)/;
              if( defined $file ){           
              
                my  $file_path = path($output_run_dir,"job$job_num",$step,$file);    
                #  warn "Looking for $file in $file_path";        
                if( $file_path->exists ) {
                #      warn "FOUND: ", $file_path;     
                    my $path_to_link = $file_path; 
                    $self->_symlink_paths($job_num,$path_to_link,$job_ids,$symlink_dir,$opt->{name});        
                }
              }else{
              #   warn "no file in $placeholder";
              }
           }
         }
      } 
  
  }
   
  sub _symlink_paths {
      my $self = shift;
      my $job_num = shift;
      my $path_to_link =shift;
      my $job_ids =shift;
      my $symlink_dir = shift;
      my $name = shift;
      
      if(defined $path_to_link){
               my $id =$job_ids->[$job_num];
               my $new_basename = "$id-".$path_to_link->basename;
               if( defined( $name )){
                  $new_basename = "$id$name" ;                                
                }     
               my $symlink_path = path($symlink_dir,$new_basename);        
               #my $symlink_path = path($symlink_dir,$job_ids->[$job_num],$file_path);
               warn " SYMLINK $path_to_link $symlink_path";    
               CORE::symlink $path_to_link, $symlink_path;       
           }  
  } 
   
  sub _get_job_ids {
      my $self = shift;
      my $id_field = shift;  
      my $datasource = shift;
      my $groupby_fields = shift;
      
      my @job_ids ;
      if(defined $groupby_fields){
          my $groupby_field = $groupby_fields->[0];  # only one group by supported at the moment      
          $datasource = $datasource->group([$groupby_field],[$id_field],[sub { join("-",@_) } ],["$id_field-group"] );
          #$self->logger->debug("Symlink - grouped datasource looks like " . $datasource->tsv );
          $id_field = "$id_field-group";
      }
     
      if( ! defined( $id_field) ){
             warn "No ID field defined. Prepending job numbers " ;
             @job_ids = map {"job$_"} (0 .. $datasource->nofRow -1 );
      }elsif( $datasource->hasCol($id_field) ){
             @job_ids = $datasource->col($id_field);
      }else{
             warn "No matching ID field in datasource. Prepending job numbers";
             @job_ids = map {"job$_"} (0 .. $datasource->nofRow -1 );
      }    
      return \@job_ids;  
  }
   
  
  sub run_pipeline {
      my $self = shift;   
      my $pipeline_file = shift; 
  
     # RESOLVE DATASOURCE HERE
  
      my $parser = App::Pipeline::Lite4::Parser->new(
          pipeline_dir => $self->pipeline_dir,
       );
      
      $parser->preparse(  $self->pipeline_file, 
                          $self->pipeline_preparse_file ); 
      
      $parser->parse(  $self->pipeline_preparse_file, 
                       $self->pipeline_parse_file  );
      #warn "WORKING WITH DATASOURCE: " .    $self->datasource_file;
        
      my $resolver = App::Pipeline::Lite4::Resolver->new (                      
                         pipeline_dir         => $self->pipeline_dir,
                         #datasource_file      => $self->datasource_resolved_file,
                         datasource_file      => $self->datasource_file,
                         current_run_num      => defined( $self->run_num ) ? $self->run_num : undef,
                         step_filter_str      => defined( $self->step_filter_str) ? $self->step_filter_str : undef,
                         job_filter_str       => defined( $self->job_filter_str) ? $self->job_filter_str : undef,
                         #run_num_dep          => defined( $self->run_num_dep ) ? $self->run_num_dep : undef
                         );   
                         
     #warn Dumper $resolver->pipeline_datasource;                                       
     
     $resolver->resolve($self->pipeline_parse_file,$self->pipeline_resolved_file); 
     
     
      my $grapher = App::Pipeline::Lite4::Grapher->new ( 
                         pipeline_dir    => $self->pipeline_dir,
                         datasource_file => $self->datasource_file,
                         );     
                                           
      $grapher->add_dependents(  $self->pipeline_resolved_file, 
                                 $self->pipeline_graph_file );                
       
      # copy stuff over to settings directory
      my $run_num = $resolver->current_run_num;
      $self->copy_pipeline_files_to_run_settings_dir($run_num); 
       
      if ( ! $self->smoke_test ) { 
     
        if( defined( $self->external_dispatcher ) ) {       
           $self->external_dispatch( $self->external_dispatcher );            
        } else {
            print "\n*** dispatcher not defined - see config file ***\n";
            # warn using local dispatch option
            #print "\n***\n\nUsing built in dispatcher\n\n***\n";
            #my $dispatcher = App::Pipeline::Lite4::Dispatcher->new( 
            #             pipeline_graph_file => $self->pipeline_graph_file,
            #             logfile => $self->logfile );                                      
            #$dispatcher->dispatch;    
       }
     }else{      
       $self->logger->debug("Smoke Test!");    
     }
     
  
  }
  
  sub external_dispatch {
     # TYPE  Path::Tiny :$dispatcher_exe )  {
      my $self=shift;
      my $dispatcher_exe=shift;
      
      my $pipeline_graph_file = $self->pipeline_graph_file->absolute;
      
      my $pipeline_dir = $self->pipeline_dir->absolute->stringify;
      ouch 'App_Pipeline_Lite4_Error', "Dispatcher does not exist at $dispatcher_exe" 
       unless $dispatcher_exe->exists;
      
       my $dispatcher_path_str = $dispatcher_exe->absolute->stringify;     
      ouch  'App_Pipeline_Lite4_Error', "Dispatcher app is not executable" 
        unless ( -x $dispatcher_path_str);  
        
      #my $dispatcher_cmd =  qq{ $dispatcher_path_str  $pipeline_dir };
      my $dispatcher_cmd =  qq{ $dispatcher_path_str  $pipeline_graph_file };
      system( $dispatcher_cmd );    
  }
  
  
  sub copy_pipeline_files_to_run_settings_dir  {
     
     my $self = shift;
     my $run_num = shift;
     $self->new_run_settings_dir($run_num)->mkpath unless $self->new_run_settings_dir($run_num)->exists;  
     
     copy( $self->pipeline_file->stringify , $self->run_settings_dir($run_num)->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy pipeline file to run settings directory";
     
     copy( $self->pipeline_graph_file->stringify , $self->run_settings_dir($run_num)->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy graph file to run settings directory";
      
     copy( $self->datasource_file->stringify , $self->run_settings_dir($run_num)->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy datasource file to run settings directory"; 
       
     #make a standardised version to the pipeline name 
     copy( $self->datasource_file->stringify , path( $self->run_settings_dir($run_num), $self->pipeline_name . ".datasource" )->stringify )
       or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy datasource file to run settings directory"; 
      
     #copy( $self->datasource_resolved_file->stringify , $self->run_settings_dir($run_num)->stringify )
     #  or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy resolved datasource file to run settings directory"; 
       
     if( $self->software_ini_file->exists){ 
         copy( $self->software_ini_file->stringify , $self->run_settings_dir($run_num)->stringify )
           or ouch 'App_Pipeline_Lite4_Error', "Couldn't copy software ini file to run settings directory";
     }
  }
  
  
  
  1;
APP_PIPELINE_LITE4

$fatpacked{"App/Pipeline/Lite4/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_BASE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Base;
  use Moo;
  use MooX::late;
  use Path::Tiny;
  use Types::Path::Tiny qw/Path AbsPath/;
  use Config::Tiny;
  use Ouch;
  use File::HomeDir; 
  use Data::Table;
  use App::Pipeline::Lite4::Logger; 
  use List::Util qw(max);
  
  has pipeline_dir  => ( isa => Path,  is => 'rw', coerce => 1, trigger  => \&_pipeline_dir_trigger);
  has use_relative_paths  => (isa => 'Bool', is => 'rw', default => sub {0});
  has pipeline_name    => ( isa => 'Str', is => 'rw', lazy_build => 1);
  has pipeline_file    => ( isa => Path, is => 'rw',  lazy_build => 1);
  has logfile          => ( isa => Path, is => 'rw', lazy_build => 1);
  has logconf          => ( isa => 'HashRef|Undef', is => 'rw', lazy_build => 1);
  has logconffile      => ( isa => Path, is => 'rw',  lazy_build => 1);
  has logger           => ( isa => 'App::Pipeline::Lite4::Logger', lazy_build=>1);
  has system_logfile   => ( isa => Path, is => 'rw',  lazy_build => 1);
  has system_logger    => ( isa => 'App::Pipeline::Lite4::Logger', lazy_build=>1);
  # config locations
  
  has config           => ( isa => 'Config::Tiny', is => 'rw', lazy_build => 1 );
  has config_file      => ( isa => Path, is => 'rw', coerce => 1, lazy_build => 1);
  has system_config      => (isa => 'Config::Tiny', is => 'rw', lazy_build => 1 ); 
  has system_config_file => ( isa => Path, is => 'rw', coerce => 1, lazy_build => 1);
  
  =cut
  has logconffile      => ( isa => Path, is => 'rw',  lazy_build => 1);
  =cut
  
  has output_dir       => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build => 1 );
  has input_dir        => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has software_dir     => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has software_ini      => (isa => 'Config::Tiny', is => 'rw', lazy_build => 1 );
  has software_ini_file => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build =>1  );
  has test_data_file   => ( isa => Path, is => 'rw', coerce => 1,  lazy_build =>1  );
  has datasource_file  => ( isa => Path, is => 'rw', coerce => 1,  lazy_build =>1  );
  has datasource_resolved_file  => ( isa => Path, is => 'rw', coerce => 1,  lazy_build =>1  );
   
  has pipeline_preparse_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 ); 
  has pipeline_parse_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 ); 
  has pipeline_resolved_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 ); 
  has pipeline_graph_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 );
  has pipeline_submission_file => (isa => Path, is => 'rw', coerce => 1, lazy_build => 1 );
  has pipeline_datasource  => ( isa => 'Data::Table', is => 'rw', lazy_build =>1 ); #used in util.
  
  has symlink_dir => ( isa => Path, is => 'rw',  coerce => 1,  lazy_build => 1 );
  has output_run_name => (  isa => 'Str', is => 'rw', default => sub {return 'run'} );
  has output_job_name => (  isa => 'Str', is => 'rw', default => sub {return 'job'} );
  has run_settings_name => ( isa => 'Str', is => 'rw', default => sub {return 'settings'});
  
  has run_num => ( isa => 'Str', is => 'rw'); 
  has job_filter_str  => ( isa => 'Str|Undef', is => 'rw');
  has step_filter_str => ( isa => 'Str|Undef', is => 'rw');
  has argument_str    => ( isa => 'Str|Undef', is => 'rw'  );
  
  
  sub _pipeline_dir_trigger {
      my $self = shift;
      return if $self->pipeline_dir->is_absolute;
      if ($self->use_relative_paths){
          warn "USING RELATIVE PATHS";
          warn "The pipeline_dir is relative " if $self->pipeline_dir->is_relative;
          warn "But the pipeline_dir is absolute" if $self->pipeline_dir->is_absolute;
      } else {
         $self->pipeline_dir( $self->pipeline_dir->absolute );
      }
  }
  
  sub _build_pipeline_name {
      my $self = shift;
      return $self->pipeline_dir->basename; 
  }
  
  sub _build_pipeline_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.pipeline' ); 
  }
  
  sub _build_pipeline_preparse_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.preparse.yaml') ; 
  }
  
  sub _build_pipeline_parse_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.parse.yaml') ; 
  }
  
  sub _build_pipeline_resolved_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.resolved.yaml') ; 
  }
  
  sub _build_pipeline_graph_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.graph.yaml') ; 
  }
  
  sub _build_pipeline_submission_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.submissions.txt') ; 
  }
  
  sub _build_pipeline_datasource {
      my $self = shift;
      my $datasourcefile = path( $self->datasource_file )->absolute;  
      ouch 'badfile', "Need to provide datasource file location\n" unless defined( $datasourcefile);
      #my $t =  App::Pipeline::Lite2::Datasource->new( datasource_file => $datasourcefile );         
      my $t = Data::Table::fromTSV( $datasourcefile->stringify );
  }
  
  sub _build_logfile {
      my $self = shift;
      #return file($self->pipeline_dir, $self->pipeline_name .".log")->stringify;
      #this should be able to be set system/user wide
      my $tmp_dir = "/tmp/";
      return path($tmp_dir, $self->pipeline_name .".log") #->stringify;
  }
  
  sub _build_system_logfile {
      my $self = shift;
      #return file($self->pipeline_dir, $self->pipeline_name .".log")->stringify;
      #this should be able to be set system/user wide
      my $sys_log_dir = File::HomeDir->my_data;
      return path($sys_log_dir, "plite.log"); #->stringify;
  }
  
  sub _build_software_ini_file {
     my $self = shift;  
     my $file = path($self->software_dir, 'software.ini');
     return $file;
  }
  
  sub _build_software_ini {
      my $self = shift;
      my $cf = Config::Tiny->new;
      #if no config file then means nothing has been set.
      return $cf unless $self->software_ini_file->exists;
      my $conf = $cf->read( $self->software_ini_file->absolute->stringify ) or ouch 'badfile' , "Cannot read config file ".$cf->errstr; 
      return $conf;
  }
  
  sub _build_logger {
      my $self = shift;   
      my $logger = App::Pipeline::Lite4::Logger->new( logfile => $self->logfile) ;    
      return $logger; 
  }
  
  sub _build_system_logger {
      my $self = shift;
      my $logger = App::Pipeline::Lite4::Logger->new( logfile => $self->system_logfile) ;    
      return $logger;
  }
  
  sub _build_logconf {
      my $self = shift;
      # open YAML config file
       my $logconf_yaml =  $self->logconffile->stat
        ? $self->logconffile->slurp
        : return undef;
      my $logconfig = Load($logconf_yaml);
      return $logconfig;
  }
  
  sub _build_logconffile {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.log.conf' );
  }
  
  sub _build_config_file {
     my $self = shift;  
     my $file = path($self->pipeline_dir, $self->pipeline_name.'.ini');
     #print "config file is $file\n";
     #$file->touch;
     return $file;
  }
  
  sub _build_config {
      my $self = shift;
      my $cf = Config::Tiny->new;
      #if no config file then means nothing has been set.
      return $cf unless $self->config_file->exists;
      my $conf = $cf->read( $self->config_file ) 
         or ouch 'badfile' , "Cannot read config file ".$cf->errstr; 
      return $conf;
  }
  
  sub _build_system_config {
      my $self = shift;
      my $cf = Config::Tiny->new;
      #if no config file then means nothing has been set.
      return $cf unless $self->system_config_file->exists;
      my $conf = $cf->read( $self->system_config_file ) or ouch 'badfile' , "Cannot read config file ".$cf->errstr; 
      return $conf;
  }
  
  sub _build_system_config_file {
     my $self = shift;  
     my $system_config_dir = File::HomeDir->my_dist_config('App-Pipeline-Lite4', { create => 1 });
     my $system_config_file = path($system_config_dir, 'config.ini');
     #print "config file is $file\n";
     #$file->touch;
     return $system_config_file;
  }
  
  sub _build_output_dir {
      my $self = shift;
      my $output_dir = $self->config->{_}->{output_dir}; 
      return path($output_dir) if(defined( $output_dir)) ;
      return path( $self->pipeline_dir, 'output'  ); 
  }
  
  sub _build_input_dir {
      my $self = shift;
      my $input_dir = $self->config->{_}->{input_dir}; 
      return path($input_dir) if(defined( $input_dir)) ;
      return path( $self->pipeline_dir, 'input'  ); 
  }
  
  
  sub _build_symlink_dir {
      my $self = shift;
      my $symlink_dir = $self->config->{_}->{symlink_dir}; 
      return path($symlink_dir) if(defined( $symlink_dir)) ;
      return path( $self->pipeline_dir, 'symlink'  ); 
  }
  
  
  sub _build_software_dir {
      my $self = shift;
      my $software_dir = $self->config->{_}->{software_dir}; 
      return path($software_dir) if(defined( $software_dir)) ;
      return path( $self->pipeline_dir, 'software'  ); 
  }
  
  sub _build_datasource_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.datasource');
  }
  
  sub _build_datasource_resolved_file {
      my $self = shift;
      return path( $self->pipeline_dir, $self->pipeline_name . '.resolved.datasource');
  }
  
  sub _build_test_data_file {
      my $self = shift;
      return path( $self->pipeline_dir, 'test_data', 'test.txt'  ); 
  }
  
  sub run_dir  {
      my $self = shift;
      ## Num $run_num
      my $run_num = shift;
      return path( $self->output_dir, $self->output_run_name . $run_num );
  }
  
  sub run_settings_dir   {
     my $self = shift;
     #Num $run_num
     my $run_num = shift;   
     my $settings_dir = path($self->run_dir($run_num), $self->run_settings_name );
     if( $settings_dir->exists){
        my $num_runs = scalar $settings_dir->children; 
        return path($settings_dir, $num_runs);
     }else{
        return path($settings_dir, 1);
     }
  }
  
  sub last_run_num {
      my $self=shift;
      #read in files in data directory
      #order by run number
      # - if none then run number is 1.
      my $run_num = max map { if( $_ =~ /run([0-9]+)/){$1}else{} } $self->output_dir->children;
      $run_num = 0 unless (defined $run_num);    
      return $run_num;   
  }
  
  sub new_run_settings_dir { 
     my $self = shift;
     #(Num $run_num){
     # this should generate a new settings 
     #dir taking into account reruns
     my $run_num = shift;   
     my $settings_dir = path($self->run_dir($run_num), $self->run_settings_name );
     
     if( $settings_dir->exists){
        my $num_runs = scalar $settings_dir->children + 1; 
        return path($settings_dir, $num_runs);
     }else{
        return path($settings_dir, 1);
     }  
  }
  
  sub datasource_from_run {
      my $self = shift;
      my $run_num = shift;
      my $settings_path = $self->run_settings_dir($run_num);   
      my $datasource_path = path($settings_path, $self->datasource_file->basename );
      return $datasource_path;
  }
  
  
  
  
  1;
APP_PIPELINE_LITE4_BASE

$fatpacked{"App/Pipeline/Lite4/Command/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_FILE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::file;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4::Resolver;
  use Path::Tiny;
  use Sort::Naturally;
  use Number::Bytes::Human qw(format_bytes);
  use Time::Piece;
  use Data::Table;
  sub execute {
      my ($self, $opt, $args) = @_;
   
      
      eval {
         
         # set show steps if stats
         $opt->{step_name} = 1 if $opt->{stats};
          
         # Default is to get the latest run and the latest datasource
     
        my $resolver = App::Pipeline::Lite4::Resolver->new( pipeline_dir =>  $args->[0]); 
        my $run_num = $resolver->_last_run_number;           
         if( defined $opt->{run_num} ) {
            $run_num = $opt->{run_num};
         }
        
        #get datasource from settings directory and set to datasource file
        $resolver->datasource_file( $resolver->datasource_from_run($run_num) );
        my $datasource = $resolver->pipeline_datasource;
        #print $datasource->tsv;
         
        # Go through each job  
            # create a hash based on steps 
            #  $steps{step}{filename}{jobnum}
            #  then  at the end  
        my $output_run_dir = path( $resolver->output_dir, "run".$run_num);
   
        my $iter = $output_run_dir->iterator( { recurse => 1 } );
        my %step_hash;
        my %jobs;
        while( my $path = $iter->() ){        
          next unless $path->is_file;
          next if(  $path->basename =~ m{/?(out|err)$} ); 
          next unless $path =~ /job/; #removes setting directory and other things that are not jobs
          
          #print $path . "\n";
          my ($job, $step,$name)  = $path->stringify =~ m{(job[0-9]+)/(.+)/(.+)$};
          #my ($step) = $path->stringify =~ m{job[0-9]+/(.+)/} ;
          #print join " ", $job, $step, $name .  "\n";
          if( $opt->{stats} ){
             my $time = localtime($path->stat->mtime)->datetime;
             $step_hash{$step}{$name}{$job} = format_bytes( $path->stat->size) . "," . "[$time]";
          }else{
            $step_hash{$step}{$name}{$job} = $path;
          } 
          $jobs{$job} =1;
        }  
       
        #print header
        
        my @row;
        my $header;
        foreach my $step (nsort keys %step_hash){
          my $names = $step_hash{$step};
          foreach my $name (nsort keys %$names){
             if( $opt->{step_name} ){
               push @row,  $step."-".$name;
             }else{
               push @row,  $name;
             }
          }
        }
        
        #print join "\t", @row; print "\n";
        $header = [@row];
        
        my @table_data;
        foreach my $job (nsort keys %jobs){  
            @row = ();
            # go through each step and if the name doesn't have this job then put in some null character          
            foreach my $step (nsort keys %step_hash){
                my $names = $step_hash{$step};
                foreach my $name (nsort keys %$names){
                    if( exists $names->{$name}->{$job} ){                  
                     push @row,  $names->{$name}->{$job} 
                  }else{
                    push @row,"-";
                  }
                                   
                }
            }
            #print join "\t", @row; print "\n";
            push @table_data, [@row];
         }
         
        my $t = Data::Table->new(\@table_data, $header, 0);
        $datasource->colMerge($t, {renameCol => 1 } );
        print $datasource->tsv;
         
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( kiss 'App_Pipeline_Lite4_Error_MISSING_PLACEHOLDER' ){
         print "\n*** There is something to fix before this pipeline can dispatch ***\n";
         print "\n", bleep(), "\n\n"; 
         print "This might be fixed by:\n
               - giving the placeholder a value (e.g. treating as an argument) via --args
               - fixing an error in the placeholder name
               - creating values for this placeholder in the datasource
          \n";
      }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  
  1;
APP_PIPELINE_LITE4_COMMAND_FILE

$fatpacked{"App/Pipeline/Lite4/Command/new.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_NEW';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::new;
  use Moo;
  use MooX::late;
  use Ouch;
  use App::Pipeline::Lite4::SetupPipeline;
  
  sub execute {
      my ($self, $opt, $args) = @_;
      # get pipeline directory
      # get pipelite object    
      eval {        
          my $App_Pipeline_Lite_Setup = App::Pipeline::Lite4::SetupPipeline->new( pipeline_dir => $args->[0]); 
          $App_Pipeline_Lite_Setup->output_dir( dir( $opt->{output_dir} ) ) if defined($opt->{output_dir});      
          if( defined $opt->{based_on}){
               $App_Pipeline_Lite_Setup->create_pipeline_directory( based_on => $opt->{based_on} ); # this needs to be written in setup            
          }else{
               $App_Pipeline_Lite_Setup->create_pipeline_directory();
          }        
      };
      
      if( kiss 'App_Pipeline_Lite2_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_NEW

$fatpacked{"App/Pipeline/Lite4/Command/run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_RUN';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::run;
  use Moo;
  use Ouch;
  use Path::Tiny;
  use App::Pipeline::Lite4;
  sub execute {
      my ($self, $opt, $args) = @_;
   
      
      eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
           
          $App_Pipeline_Lite->smoke_test(1) if defined($opt->{smoke_test});    
          
          if( defined $opt->{steps} ) {
            $App_Pipeline_Lite->step_filter_str($opt->{steps});     
          }
          
          if(defined $opt->{jobs}){
             $App_Pipeline_Lite->job_filter_str( $opt->{jobs} );
          }
          
          if(defined $opt->{run}){
                 
           $App_Pipeline_Lite->run_num($opt->{run});
           my $datasource_path = $App_Pipeline_Lite->datasource_from_run($opt->{run});
           $App_Pipeline_Lite->datasource_file($datasource_path);
           
           # $App_Pipeline_Lite->datasource_file
           # or do we set the $App_Pipeline_Lite->datasource_resolve_file
           # do we need a switch to say this is the resolved file 
           # and don't do any further datasource resolving?
          }
          
          if( defined $opt->{datasource} ) {
             # pre check that file exists
             my $datasource_path = $opt->{datasource}; 
             ouch 'App_Pipeline_Lite4_Error', "The datasource path ($datasource_path) is not a file" unless path( $datasource_path)->is_file ;         
             $App_Pipeline_Lite->datasource_file( $datasource_path )  ;       
          }  
         
          my $desc ="smoke-test";  
         $desc = $App_Pipeline_Lite->util->ask_for_description
                        unless defined $opt->{smoke_test};
        my $step_filter = $opt->{steps} // "*";
        my $job_filter  = $opt->{jobs} // "*"; 
        my $run_num =  $App_Pipeline_Lite->last_run_num + 1; 
        $run_num = $opt->{run} if defined($opt->{run});    
        my $run_info = join " ", "run" . "[ $run_num ]", "[ step-filter: " . $step_filter  . " ]", "[ job-filter: " . $job_filter . " ]";
                  
        $App_Pipeline_Lite->util->append_description( $run_info, $desc );   
          
        $App_Pipeline_Lite->run_pipeline;
          
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( kiss 'App_Pipeline_Lite4_Error_MISSING_PLACEHOLDER' ){
         print "\n*** There is something to fix before this pipeline can dispatch ***\n";
         print "\n", bleep(), "\n\n"; 
         print "This might be fixed by:\n
               - giving the placeholder a value (e.g. treating as an argument) via --args
               - fixing an error in the placeholder name
               - creating values for this placeholder in the datasource
          \n";
     }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_RUN

$fatpacked{"App/Pipeline/Lite4/Command/symdir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_SYMDIR';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::symdir;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
   sub execute {
      my ($self, $opt, $args) = @_;
      
       # get pipeline directory
       # get pipelite object 
      
       eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
     
          my ($step,$filename) = split '#', $opt->{step_and_fname} ;
          
          # get the datasource  
          my $resolver = App::Pipeline::Lite4::Resolver->new( pipeline_dir =>  $args->[0]); 
          my $run_num = $resolver->_last_run_number;           
          if( defined $opt->{run_num} ) {
            $run_num = $opt->{run_num};
           }
        
          #get datasource from settings directory and set to datasource file
          $resolver->datasource_file( $resolver->datasource_from_run($run_num) );
          my $datasource = $resolver->pipeline_datasource;
          
          
          
          my $output_run_dir = path( $resolver->output_dir, "run".$run_num);
          my @jobs =  grep { /job/ } $output_run_dir->children
          print "@jobs\n"; 
          #my $iter = $output_run_dir->iterator( { recurse => 1 } );
          #my %step_hash;
          #my %jobs;
          #while( my $path = $iter->() ){        
          #  next unless $path->is_file;
          #  next if(  $path->basename =~ m{/?(out|err)$} ); 
          #  next unless $path =~ /job/; #removes setting directory and other things that are not jobs
          #}
          
          
          # parse the step name and filename
          # check that the field exists
          # go through each job directory and make the link
          # if a file doesn't exist warn. 
          # make a datasource for the symlink files
              
       };
      
       if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
       } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
       }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_SYMDIR

$fatpacked{"App/Pipeline/Lite4/Command/symlink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_SYMLINK';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::symlink;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  use App::Pipeline::Lite4::Resolver;
  use Path::Tiny;
  use Sort::Naturally;
  
  sub execute {
      my ($self, $opt, $args) = @_;
  
       eval {
          my $id_field = $opt->{id_field};
          my $pipeline_dir =       path($args->[0]);
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
          ouch 'App_Pipeline_Lite_CMD_ERROR', "Requires step_and_filename argument"
             unless ( defined( $opt->{step_and_fname} ) );
          my ($step,$filename) = split '#', $opt->{step_and_fname} ;
          
          ouch 'App_Pipeline_Lite_CMD_ERROR', "Something went wrong specifying the step and filename" 
             unless ( defined($step) and defined($filename));
          ouch 'App_Pipeline_Lite_CMD_ERROR', "Something went wrong specifying the step and filename" 
             if( $step eq '' or $filename eq '');
          
          # get the datasource  
          my $resolver = App::Pipeline::Lite4::Resolver->new( pipeline_dir =>  $args->[0]); 
          my $run_num = $resolver->_last_run_number;           
          if( defined $opt->{run_num} ) {
            $run_num = $opt->{run_num};
          }
          
          my $datasource;
          if( defined( $opt->{datasource} )){
            $resolver->datasource_file($opt->{datasource} );
            $datasource = $resolver->pipeline_datasource;
          }else{
            #get datasource from settings directory and set to datasource file
            $resolver->datasource_file( $resolver->datasource_from_run($run_num) );
            $datasource = $resolver->pipeline_datasource;
          }
           
          my $output_run_dir = path( $resolver->output_dir, "run".$run_num);
          my @jobs = nsort grep { /job/ } $output_run_dir->children;
  
          my @job_ids = map {$_->basename} @jobs;
          if( ! defined( $id_field) ){
             warn "No ID field defined. Prepending job numbers " 
          }elsif( $datasource->hasCol($id_field) ){
             @job_ids = $datasource->col($id_field);
          }else{
             warn "No matching ID field in datasource. Prepending job numbers"
          }
          
          #default path
          my $symlink_dir = path($resolver->symlink_dir, $step, $run_num);
          $symlink_dir = $opt->{path} if defined($opt->{path});
          $symlink_dir->mkpath;
          my @table_data;
          foreach my $job (@jobs){
            my $path = path($job,$step,$filename);
            my $id = shift @job_ids;
            if( $path->exists){
               my $new_basename = "$id-".$path->basename;
               if( defined( $opt->{name} )){
                  my $name = $opt->{name};
                  $new_basename = "$id$name" ;                                
               }             
               my $new_path = path($symlink_dir,$new_basename);
               symlink $path, $new_path->absolute;  
               print "symlinked $path to $new_path\n";
               push @table_data, [$new_path];
            }else{
               warn "path $path does not exist";
               push @table_data, ["-"];
            }
          }
          
          my $t = Data::Table->new(\@table_data, [$filename], 0);
          $datasource->colMerge($t);
          my $datasource_tsv = $datasource->tsv;
          my $datasource_path = path($symlink_dir,$pipeline_dir->basename . ".datasource");
          $datasource_path->spew($datasource_tsv);
          # parse the step name and filename
          # check that the field exists
          # go through each job directory and make the link
          # if a file doesn't exist warn. 
          # make a datasource for the symlink files            
       };
      
       if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
       } elsif ( kiss  'App_Pipeline_Lite_CMD_ERROR') {
         print bleep(), "\n";       
       }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
       }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_SYMLINK

$fatpacked{"App/Pipeline/Lite4/Command/symlink2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_SYMLINK2';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::symlink2;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  use App::Pipeline::Lite4::Resolver;
  use Path::Tiny;
  use Sort::Naturally;
  
  sub execute {
      my ($self, $opt, $args) = @_;
  
       eval {
          my $pipeline_dir =   path($args->[0]);
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);      
          my $run_num = $App_Pipeline_Lite->last_run_num;
          if(defined $opt->{run}){     
             $run_num = $opt->{run};
          }
          $App_Pipeline_Lite->run_num($run_num);
          my $datasource_path = $App_Pipeline_Lite->datasource_from_run($run_num);
          $App_Pipeline_Lite->datasource_file($datasource_path);
          $App_Pipeline_Lite->symlink($opt);       
       };
       
       if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
       } elsif ( kiss  'App_Pipeline_Lite_CMD_ERROR') {
         print bleep(), "\n";       
       }elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
       }
  }    
  1;
APP_PIPELINE_LITE4_COMMAND_SYMLINK2

$fatpacked{"App/Pipeline/Lite4/Command/viewconfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWCONFIG';
  # use strict;
  # use warnings;
  # package App::Pipeline::Lite4::Command::viewconfig;
  # use Moo;
  # use Ouch;
  # use App::Pipeline::Lite4;
  
  # # sub execute {
      # my ($self, $opt, $args) = @_;
      
  # #     # get pipeline directory
      # # get pipelite object 
      
  # #     eval {
          # my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
  # #         if(defined $opt->{editor}){
                  # $App_Pipeline_Lite->util->set_editor( $opt->{editor} );            
          # }                             
          # $App_Pipeline_Lite->util->view_file_with_editor( 
                                # $App_Pipeline_Lite->pipeline_file->absolute->stringify);
          
  # #     };
      
  # #     if( kiss 'App_Pipeline_Lite4_Error') {
         # print bleep(), "\n"; 
      # } elsif ( hug ) {
         # print 'An error occurred, check logs: ', $@ ;
      # }
  # }
  #1;
APP_PIPELINE_LITE4_COMMAND_VIEWCONFIG

$fatpacked{"App/Pipeline/Lite4/Command/viewgraph.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWGRAPH';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::viewgraph;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
  sub execute {
      my ($self, $opt, $args) = @_;
      
      # get pipeline directory
      # get pipelite object 
      
      eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
          if(defined $opt->{editor}){
                  $App_Pipeline_Lite->util->set_editor( $opt->{editor} );            
          }                             
          $App_Pipeline_Lite->util->view_file_with_editor( 
                                $App_Pipeline_Lite->pipeline_graph_file->absolute->stringify);
          
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_VIEWGRAPH

$fatpacked{"App/Pipeline/Lite4/Command/viewpipeline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWPIPELINE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::viewpipeline;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
  sub execute {
      my ($self, $opt, $args) = @_;
      
      # get pipeline directory
      # get pipelite object 
      
      eval {
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new( pipeline_dir => $args->[0]);
  
          if(defined $opt->{editor}){
                  $App_Pipeline_Lite->util->set_editor( $opt->{editor} );            
          }                             
          $App_Pipeline_Lite->util->view_file_with_editor( 
                                $App_Pipeline_Lite->pipeline_file->absolute->stringify);
          
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_VIEWPIPELINE

$fatpacked{"App/Pipeline/Lite4/Command/viewsystemconfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_COMMAND_VIEWSYSTEMCONFIG';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Command::viewsystemconfig;
  use Moo;
  use Ouch;
  use App::Pipeline::Lite4;
  
  sub execute {
      my ($self, $opt, $args) = @_;
        
      
      eval {       
          my $App_Pipeline_Lite = App::Pipeline::Lite4->new;
          my $App_Pipeline_Lite_Util = App::Pipeline::Lite4::Util->new; 
          if(defined $opt->{editor}){               
                  $App_Pipeline_Lite_Util->set_editor( $opt->{editor});
          }                             
          $App_Pipeline_Lite_Util->view_file_with_editor( $App_Pipeline_Lite->system_config_file );
      };
      
      if( kiss 'App_Pipeline_Lite4_Error') {
         print bleep(), "\n"; 
      } elsif ( hug ) {
         print 'An error occurred, check logs: ', $@ ;
      }
  }
  1;
APP_PIPELINE_LITE4_COMMAND_VIEWSYSTEMCONFIG

$fatpacked{"App/Pipeline/Lite4/Grapher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_GRAPHER';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Grapher;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
  #use List::AllUtils qw(min any); can't use as get kick ups about requiring versions > 1.32
  use List::Util qw(min reduce);
  use Array::Compare;
  use Data::Dumper;
  use App::Pipeline::Lite4::Util;
  extends 'App::Pipeline::Lite4::Base';
  has pipeline_step_struct_with_dependents => ( isa => 'HashRef', is => 'rw' );
  
  sub add_dependents {
     my $self=shift;
     # Path::Tiny :$yaml_infile,
     my $yaml_infile = shift;  
     # Path::Tiny :$yaml_outfile
     my $yaml_outfile = shift;
     $self->pipeline_resolved_file($yaml_infile);
     $self->_add_dependents;
     $yaml_outfile->spew( Dump( $self->pipeline_step_struct_with_dependents ) );
  }
  
  #method _add_dependents {    
  sub _add_dependents {
      my $self = shift;
      my $resolved_file_yaml = $self->pipeline_resolved_file->slurp;
      my $resolved_pipeline = Load($resolved_file_yaml); 
      
      my $lowest_job_num = min keys $resolved_pipeline;
      my $num_of_jobs    = scalar keys $resolved_pipeline;
      
     # my $valid_steps = $self->valid_steps( $resolved_pipeline);
      my $valid_steps = $self->valid_steps_hash( $resolved_pipeline);
      
      foreach my $job_num (keys %$resolved_pipeline){
          my $job = $resolved_pipeline->{$job_num};
          foreach my $step (keys %$job) {
             $job->{$step}->{dependents} = [];
             if( defined($job->{$step}->{placeholders})) {
                $self->_add_dependents_for_step_via_placeholder( 
                          $job->{$step}, #step
                          $step, #step_name 
                          $job_num,
                          $lowest_job_num,  
                          $num_of_jobs, 
                          $valid_steps 
                          );
             }
             
             if( defined( $job->{$step}->{after}) ) {
                 $self->_add_dependents_for_step_via_after_condition( 
                          $job->{$step}, #step
                          $step,   #sep_name
                          $job_num, 
                          $lowest_job_num, 
                          $num_of_jobs, 
                          $valid_steps );  
             }           
          }
      }
      $self->pipeline_step_struct_with_dependents($resolved_pipeline);
  }
  
  sub _add_dependents_for_step_via_placeholder {
  # TYPE (  HashRef :$step, Str :$step_name, Num :$job_num, Num :$lowest_job_num, 
  # TYPE Num :$num_of_jobs, ArrayRef :$valid_steps ) {
       my ($self,$step,$step_name,$job_num, $lowest_job_num, 
           $num_of_jobs,$valid_steps_hash  ) = @_;
       
       $self->logger->debug( "Valid Steps: " . Dumper $valid_steps_hash );
       my $rgx1 = qr{^([\w\-]+)\.{0,1}};
       my $rgx2 = qr{^jobs\.([\w\-]+)\.{0,1}};      
       my $rgx3 = qr{groupbyebyebye}; # should not match anything
       if( defined( $step->{condition} ) ){         
         if(  $step->{condition} eq 'groupby'){
           my $params = $step->{condition_params};     
           my $params_str = join '\.', @$params;
           my $rgx3_str = '^groupby\.' . $params_str . '\.' . '([\w\-]+)\.{0,1}';
           $rgx3 = qr{$rgx3_str};
         }
       } 
       #warn "REGEX3 $rgx3";     
       my $placeholders = $step->{placeholders};
       my $dependents   = $step->{dependents};
       
       my @valid_steps = keys %$valid_steps_hash;
       foreach my $placeholder (@$placeholders){                                    
           my ($placeholder_step_name) = $placeholder =~ $rgx2;#/^(\w+)\.{0,1}/; # =~ /step([0-9]+)/;
           ($placeholder_step_name) = $placeholder =~ $rgx3 unless defined($placeholder_step_name);
           ($placeholder_step_name) = $placeholder =~ $rgx1 unless defined($placeholder_step_name);
            
           # warn "GOT STEP NAME: $placeholder_step_name from $placeholder";
           $self->logger->debug("step $step_name: placeholder step name - $placeholder_step_name (from $placeholder)");  
           next unless defined($placeholder_step_name);
           
           ### I want 'any' unfortunately any isn't in recent version of List::Util and List::MoreUtils is XS and not core
           my $code = sub { my $k = shift; return 1 if( $placeholder_step_name eq $k ); return 0;   };
           my $next = reduce { $a || $code->(local $_ = $b)  } 0,  @valid_steps;
           next unless $next;
           
           # DO THIS WHEN List::Util qw(any) works for most Perls  
           #next unless any { $placeholder_step_name eq $_ } @$valid_steps; # if we have filtered steps this is important, and also takes care of the 0 datasource step
           ########################################################
           
                  
               my ($existing_dependents, $this_step_name) = (0,0);
               
               ## Actually want List::Util qw(any)
               my $codeA = sub { my $k = shift; return 1 if( "$job_num.$placeholder_step_name"  eq $k ); return 0;   };
               $existing_dependents = reduce { $a || $codeA->(local $_ = $b)  } 0,  @$dependents;
               
               # DO THIS WHEN List::Util qw(any) works for most Perls  
               #$existing_dependents =  any { $_ eq "$job_num.$placeholder_step_name"  }  @$dependents;
               ##############################################################################
               $this_step_name = 1 if( $placeholder_step_name eq $step_name);                                   
               if ( defined $step->{condition} ) {
                   # only defined condition is 'once' so far
                   # the 'any' code above will skip adding the same dependent jobs if a placeholder with the same step name occurs multiple times. 
                   # it works because it sets $existing_dependents true if any of the job numbers is present                
                   #---
                   if( $step->{condition} eq 'once'){ 
                       # now a once condition referencing another step with a once condition only needs to put down the minimal job number
                       # remember we are looking at the placeholder and trying to determine dependencies,
                       # the valid steps hash, tells us what condition the step of that placeholder is, so we can 
                       # adjust for once or groupby steps
                       if( defined $valid_steps_hash->{$placeholder_step_name}->{condition} ){             
                           if( $valid_steps_hash->{$placeholder_step_name}->{condition} eq 'once' ){
                             push(@$dependents, "$lowest_job_num.$placeholder_step_name") unless ( $this_step_name or $existing_dependents) ; 
                           }
                       }else {
                           for my $i ( $lowest_job_num .. ( $num_of_jobs -1 )){
                              push(@$dependents, "$i.$placeholder_step_name") unless ( $this_step_name or $existing_dependents) ;                                               
                           }
                    
                       }
                     }
                     if ( $step->{condition} eq 'groupby'  ){
                         
                         #we take the job number and get the group we need
                         my $util = App::Pipeline::Lite4::Util->new;
                         my $params = $step->{condition_params};
                         #warn "PARAMS: ", Dumper $params;
                         my $groupby_hash = $util->datasource_groupby2( $self->pipeline_datasource, @$params );
                         my $groupby_ids  = $util->datasource_groupby2_order($self->pipeline_datasource, @$params);
                         #my @groupby_ids = sort keys %$groupby_hash;
                         #warn "GRAPHER JOBNUM: $job_num";
                         #warn "GRAPHER GROUPID: @groupby_ids";
                         #warn "gRAPHER CMD", $step->{cmd};
                         #warn "STEP",  Dumper $step;
                         my $group_id = $groupby_ids->[$job_num]; 
                         #warn "GRAPHER GROUPID: $group_id";
                         my $job_ids = $groupby_hash->{$group_id};
                         
                         
                         # if we are referring to a step that is a groupby step, then we only need to 
                         # put int dependencies that refer to the jobs generated by that step - i.e. only up to job 4 rather
                         # than job 10 for example, as it won't exist 
                         
                         if( defined $valid_steps_hash->{$placeholder_step_name}->{condition} ){             
                           if( $valid_steps_hash->{$placeholder_step_name}->{condition} eq 'groupby' ){
                               # different conditions will have different numbers, 
                               # we can only refer to a groupby with the same condition  
                               # and then we only put in the job number, 
                               my $placeholder_step_params = $valid_steps_hash->{$placeholder_step_name}->{condition_params};
                               my $comp = Array::Compare->new; 
                               if( ! $comp->compare( $placeholder_step_params, $params  ) ){
                                  ouch 'App_Pipeline4_Error', "One groupby statement depends on another groupby statement with a different groupby field(s)";
                               }else{
                                  
                                  push(@$dependents, "$job_num.$placeholder_step_name") 
                                     unless ( $this_step_name or $existing_dependents or ($job_num >= scalar(@$groupby_ids)) ); 
                               } 
                           }
                           #do something for once here
                          }else{
                         
                             foreach my $job_id (@$job_ids){  
                                push( @$dependents, "$job_id.$placeholder_step_name" ) unless ( $this_step_name or $existing_dependents) ;
                             }
                         }
                     } 
                   
               }else{                 
                   #$existing_dependents =  any { $_ eq "$job_num.$placeholder_step_name"  }  @$dependents;
                   #$this_step_name = 1 if( $placeholder_step_name eq $step_name);  
                   if( defined ( $valid_steps_hash->{$placeholder_step_name}->{condition} ) ){                     
                       if( $valid_steps_hash->{$placeholder_step_name}->{condition} eq 'once'){
                            push( @$dependents, "$lowest_job_num.$placeholder_step_name")
                                unless ($this_step_name or $existing_dependents) ; 
                       }
                       
                    }else{
                      push( @$dependents, "$job_num.$placeholder_step_name")
                        unless ($this_step_name or $existing_dependents) ;
                   }
               }       
           #}         
       }
  }
  =cut To implement
  sub _add_dependents_for_step_via_after_condition {
      #TYPE: HashRef :$step, Str :$step_name, Num :$job_num, 
      #TYPE: Num :$lowest_job_num, Num :$num_of_jobs, ArrayRef :$valid_steps )
        my ($self,$step,$step_name,$job_num, $lowest_job_num, 
           $num_of_jobs,$valid_steps_hash  ) = @_;
        foreach my $after_step_name ($step->{after}->flatten){
          # if($after_step_num > $step) {
             # ouch 'steperror', "Need to ensure that a step does not define steps to run after that are future steps"; 
          # } 
          
         # if ( $after_step_num < $step_num ) { 
              my $dependents = $step->{dependents};  
               $self->logger->debug("step $step_name: placeholder step num - $after_step_name");                         
               if ( defined $step->{condition} ) { # only 'once' is the only thing that can occur from the condition key                
                   for my $i ( $lowest_job_num .. ( $num_of_jobs -1 )){
                       push( @$dependents, "$i.$after_step_name");                                               
                   }
               }else{
                   ouch 'App_Pipeline4_Error', "The after condition of step $step_name refers to its own step"
                     if( $after_step_name eq $step_name );
                  
                   push(@$dependents, "$job_num.$after_step_name")
                     unless any { $_ eq "$job_num.$after_step_name"  }  @$dependents ;
               }       
         #  }                    
                     
      }
  }
  =cut
  
  ####DEPRECATED## REMOVE
  sub valid_steps {
    #TYPE: ( HashRef :$resolved_pipeline ) {
    my $self = shift;    
    my $resolved_pipeline = shift;  
    # run through the first job.  
    my ($a_job);
    my @jobs = keys %$resolved_pipeline;
    my ($min_job_num) = sort {$a <=> $b} @jobs;
    $a_job =  $resolved_pipeline->{$min_job_num}; 
    my @step_names =  keys %$a_job;
    warn "@step_names";
    return \@step_names;    
  } 
  ############
  
  
  sub valid_steps_hash {
    #TYPE: ( HashRef :$resolved_pipeline ) {
    my $self = shift;    
    my $resolved_pipeline = shift;  
    # run through the first job.  
    my ($a_job);
    my @jobs = keys %$resolved_pipeline;
    my ($min_job_num) = sort {$a <=> $b} @jobs;
    $a_job =  $resolved_pipeline->{$min_job_num}; 
    my @step_names =  keys %$a_job;
    my %valid_step_hash;
    foreach my $step (keys %$a_job){
       $valid_step_hash{$step}->{condition} = $a_job->{$step}->{condition};
       $valid_step_hash{$step}->{condition_params} = $a_job->{$step}->{condition_params};   
    }
    
    return \%valid_step_hash;
  } 
  
  1;
APP_PIPELINE_LITE4_GRAPHER

$fatpacked{"App/Pipeline/Lite4/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_LOGGER';
  package App::Pipeline::Lite4::Logger;
  use Moo;
  use MooX::late;
  use Path::Tiny;
  use Time::Piece;
  use Devel::StackTrace;
  has logfile => ( isa => 'Path::Tiny|Undef', is => 'rw' );
  has system_logfile => ( isa => 'Path::Tiny|Undef', is => 'rw' );
  sub log {
      my $self  = shift;
      my $level = shift;
      my $msg   = shift; 
      
      my $t = localtime;  
      my $trace = Devel::StackTrace->new();
      
      my $frame = $trace->frame(1);
      my $package = $frame->package;
      my $app_caller = "unknown";
      
      while ( my $frame = $trace->prev_frame() ) {
         if ( $frame->package =~ /Command\:\:(.+)/ ) {
            $app_caller = $1;
            last;
         }
      }
      
      my $log_msg = "[" . $level . "] " . "[ $app_caller -> $package ] " . " [ " . $t->strftime . " ] " . $msg;         
      my $append_log = $self->logfile->opena; #( $level =~ /sys/ ) ? $self->system_logfile->opena : $self->logfile->opena;
      print $append_log $log_msg, "\n";
  }
  
  sub debug {
     my $self = shift;
     my $msg  = shift;
     $self->log("debug",$msg) ;
  }
  
  sub info {
     my $self = shift;
     my $msg  = shift;
     $self->log("info",$msg) ;
  }
  
  
  1;
APP_PIPELINE_LITE4_LOGGER

$fatpacked{"App/Pipeline/Lite4/Packer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_PACKER';
  package App::Pipeline::Lite4::Packer;
  use Moo;
  use App::FatPacker;
  use Path::Tiny;
  # thieve from Carton fatpacking (MIYAGAWA)
  
  sub fatpack_plite {
      my $self = shift;
      my $dir = path(shift);
      my $file = $dir->child('plite');
      
      my $fatpacked = $self->do_fatpack($file);     
      my $executable = path($dir,'packed')->child('plite');
      warn "... Bundling $executable\n";   
      $executable->spew($fatpacked);
      chmod 0755, $executable;
  }
  
  sub do_fatpack {
      my ($self, $file) = @_;
      my $packer = App::FatPacker->new;
   
      my @modules = split /\r?\n/, $packer->trace(args => [$file]); #, use => $self->required_modules);
      @modules = grep { !/main.pm/ } @modules;
      @modules = grep { !/XS.pm/ } @modules;
      print join "\n", @modules, "\n"; 
      my @packlists = $packer->packlists_containing(\@modules);
      $packer->packlists_to_tree(Path::Tiny->new('fatlib')->absolute, \@packlists);
   
      my $fatpacked = do {
          local $SIG{__WARN__} = sub {};
          $packer->fatpack_file($file);
      };
   
      # HACK: File::Spec bundled into arch in < 5.16, but is loadable as pure-perl
      #use Config;
      #$fatpacked =~ s/\$fatpacked{"$Config{archname}\/(Cwd|File)/\$fatpacked{"$1/g;
      $fatpacked;
  }
  1;
APP_PIPELINE_LITE4_PACKER

$fatpacked{"App/Pipeline/Lite4/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_PARSER';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Parser ;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
  use SHARYANTO::String::Util qw(trim rtrim);
  
  extends 'App::Pipeline::Lite4::Base';
  
  has append_err_str => ( isa => 'Bool' , is => 'rw', default => sub { 1;} );
  has prepend_cwd_str => ( isa => 'Bool' , is => 'rw', default => sub { 1;} );
  
  #has append => (isa => 'Str', is =>'rw', default=> sub {''} );
  #has prepend =>  (isa => 'Str', is =>'rw', default=> sub {''} );
  
  has append => (isa => 'Str|Undef', is =>'rw', lazy_build => 1 );
  has prepend =>  (isa => 'Str|Undef', is =>'rw', lazy_build =>1  );
  
  sub get_step_name { 
      #TYPE( :$str) 
     my $str = shift;
     my ($name) = $str =~ /^([\w\-]+)\./;
     return $name;
  }
  
  sub get_step_condition {
      my $str = shift;
     #TYPE: :$str 
    
     my ($condition) = $str =~ /^[\w\-]+\.([\w\-]+)\.*/;
     return $condition;
  }
  
  sub _build_append {
      my $self = shift;
      my $append_str = $self->config->{_}->{append}; #check local config 
      
      # if does not exist, check system config    
      $append_str = $self->system_config->{_}->{append} 
                                 unless defined( $append_str);
      $append_str = " " . $append_str . " "; #make sure there is a space between commands
      defined($append_str) ?  $append_str : undef;  
  }
  
   sub _build_prepend {
      my $self = shift;
      my $prepend_str = $self->config->{_}->{prepend}; #check local config 
      
      # if does not exist, check system config    
      $prepend_str = $self->system_config->{_}->{prepend} 
                                 unless defined( $prepend_str);
      $prepend_str = " " . $prepend_str . " " if defined($prepend_str); #make sure there is a space between commands
      defined($prepend_str) ?  $prepend_str : undef;  
  }
  
  
  sub preparse {
      my $self = shift;       
      my $pipeline_file = shift // $self->pipeline_file; # TYPE: Path::Class::File :$pipeline_file = $self->pipeline_file,   
      my $yaml_outfile = shift // $self->pipeline_preparse_file;     # TYPE: Path::Class::File :$yaml_outfile = $self->pipeline_preparse_file 
      # parse the current steps in the pipeline 
      my $step_hash = parse_pipeline_to_step_hash( $pipeline_file );       
      # append other stuff here first, and then err string
      # <---     
      $self->append_err_str_to_cmd( $step_hash  )
        if  ( $self->append_err_str );      
       # prepend other stuff here first, and then cwd string
       # <---   
      $self->prepend_str_to_cmd($step_hash, $self->prepend ) 
        if  ( defined $self->prepend);  
      $self->prepend_cwd_str_to_cmd($step_hash ) 
        if  ( $self->prepend_cwd_str);        
      $yaml_outfile->spew( Dump($step_hash) );
  };
  
  sub parse {
      # TYPE: Path::Class::File :$yaml_infile, 
      # TYPE: Path::Class::File :$yaml_outfile  
    my $self= shift;
    my $yaml_infile  =shift;
    my $yaml_outfile =shift;  
    my $step_hash_yaml = $yaml_infile->slurp;
    my $step_hash    = Load($step_hash_yaml); 
    my $step_struct  = pipeline_step_hash_to_step_struct( $step_hash );
    $yaml_outfile->spew( Dump($step_struct) );  
  };
  
  sub append_str_to_cmd {
    my $self = shift;
    # TYPE:  HashRef $step_hash
    my $step_hash = shift;  
    my $str = shift;
    my $append_str_func   = sub { my $step_name = shift // 'default'; return $str};
    # concat_to_cmd knows to provide step name to the coderef
    my $appended_step_hash = $self->concat_to_cmd($step_hash, $append_str_func, 'APPEND');
  }
  
  # yes this is a specific case of above - look to refactor
  sub append_err_str_to_cmd {  
      my $self = shift;
      #TYPE: HashRef $step_hash 
      my $step_hash = shift;  
      my $append_str_func   =  sub { my $step_name = shift // 'default'; return " 2>[% $step_name.err %]" };
      # concat_to_cmd knows to provide step name to this coderef
      my $appended_step_hash = $self->concat_to_cmd($step_hash, $append_str_func, 'APPEND');  
  }
  
  sub prepend_str_to_cmd {
    my $self = shift;
    # TYPE:  HashRef $step_hash
    my $step_hash = shift;  
    my $str = shift;
    my $prepend_str_func   = sub { my $step_name = shift // 'default'; return $str};
    # concat_to_cmd knows to provide step name to the coderef
    my $prepended_step_hash = $self->concat_to_cmd($step_hash, $prepend_str_func, 'PREPEND');
  }
  
  # yes this is a specific case of above - look to refactor
  sub prepend_cwd_str_to_cmd {
    my $self = shift;
    # TYPE:  HashRef $step_hash
    my $step_hash = shift;  
    my $prepend_str_func   = sub { my $step_name = shift // 'default'; return "cd [% $step_name %]; "};
    # concat_to_cmd knows to provide step name to the coderef
    my $prepended_step_hash = $self->concat_to_cmd($step_hash, $prepend_str_func, 'PREPEND');
  }
  
  # requires a coderef that returns a string, which can be used to 
  # parameterise a step name
  sub concat_to_cmd {
      my $self = shift;
      #TYPE: HashRef $step_hash 
      my $step_hash = shift;
      my $concat_string_code = shift;
      my $type_of_concat = shift; #APPEND or PREPEND
      foreach my $step ( keys %$step_hash) {
         my $step_name =  get_step_name( $step);
         $step_name = trim( $step_name ) ;
         $step_hash->{$step} = rtrim( $step_hash->{$step} );           
         my $concat_str = $concat_string_code->($step_name);
         my $step_cond = get_step_condition( $step);
         if( defined($step_cond) ){
             if($step_cond eq 'once'){              
                 $step_hash->{$step} .= $concat_str if $type_of_concat eq 'APPEND';
                 $step_hash->{$step}  = $concat_str . $step_hash->{$step} if $type_of_concat eq 'PREPEND' ;                             
             }
             
              if($step_cond eq 'groupby'){              
                 $step_hash->{$step} .= $concat_str if $type_of_concat eq 'APPEND';
                 $step_hash->{$step}  = $concat_str . $step_hash->{$step} if $type_of_concat eq 'PREPEND' ;                             
             }
             
         } else {
                 $step_hash->{$step} .= $concat_str if $type_of_concat eq 'APPEND';
                 $step_hash->{$step} =  $concat_str . $step_hash->{$step} if $type_of_concat eq 'PREPEND' ;
         }
     } 
     return $step_hash;
  }
  
  =func parse_pipeline_file_to_step_hash
    A step hash has a key such as "1." and value "some_cmd -h MOREOPTIONS ARGS ..."
  =cut
  sub parse_pipeline_to_step_hash   {
      # TYPE:  Path::Tiny $file
      my $file = shift;
      # Each Step Starts with X. or X.output and then a space, where X is the step number
      # Can be multiline but cannot start with X. on a line
      my @pipeline_file_contents = $file->lines;
      my %stephash;
      my $stepname;
      foreach my $line (@pipeline_file_contents) {  
         
         if ( $line =~ /^#/){ next; }  
         my $C = qr{^[\w\-]+\.};
         my $D = qr{^[\w\-]+\.output};
         my $E = qr{^[\w\-]+\.once};
         my $F = qr{^[\w\-]+\.mem};       
         my $G = qr{^[\w\-]+\.after};
         my $H = qr{^[\w\-]+\.queue};
         my $I = qr{^[\w\-]+\.cores};
         my $J = qr{^[\w\-]+\.groupby\.[\w\-]+};
         my $K = qr{^[\w\-]+\.groupby\.[\w\-]+\.[\w\-]+};
         #my $L = qr{^[\w\-]+\.grouptransby\.[\w\-]};
         #my $M = qr{^[\w\-]+\.grouptransby\.[\w\-]\.[\w\-]};
  
         # #my $G = qr{^[0-9]+\.skip_if_exists}
         # #my $E = qr{^[0-9]+\.no_err};
         
         my $N = qr{\s(.+)};
         my $rg = qr{        
             ($C|$D|$E|$F|$G|$H|$I|$J|$K)$N      
         }x;
         
          if( $line =~ $rg) {          
              $stepname = $1;            
              my $steptext = $2;
              $stephash{$stepname} = $steptext;
          }else{
              $stephash{$stepname} .= $line; 
          }    
      }
      return {%stephash};  
  }
  
  #takes step hash and parses it to more processed structure
  sub pipeline_step_hash_to_step_struct {
      #   TYPE: Path::Tiny :$yamlfile ) {
      my $step_hash = shift;
      my %step_struct;
      foreach my $step ( keys %$step_hash ){  
              
             my $step_name = get_step_name( $step);
             my $step_condition = get_step_condition( $step);
             
             if( !defined($step_condition) ) {
               $step_struct{$step_name}->{cmd} = $step_hash->{$step};
               $step_struct{$step_name}->{condition} = undef; # change to 'none'?
             } 
                        
             elsif( $step_condition eq 'output' ) {
                 my @files = $step_hash->{$step} =~ /(\[\%.+?\%\]\S+|\S+)/g; #my @files = split(/\s/, $step_hash->{$step}); 
                 $step_struct{$step_name}->{outputfiles} = \@files; #$step_hash->{$step};
             }
                        
             elsif( $step_condition eq 'once' ) {
               $step_struct{$step_name}->{cmd} = $step_hash->{$step};
               $step_struct{$step_name}->{condition} = 'once';
             }
             
             elsif ( $step_condition eq 'mem' ) { 
               $step_struct{$step_name}->{mem} = trim( $step_hash->{$step} );
             }
                    
             elsif ( $step_condition eq 'after' ) { 
               my @after = split(/\s/, $step_hash->{$step}); 
               $step_struct{$step_name}->{after} = \@after ;
             }
             
             elsif ( $step_condition eq 'queue' ) { 
               $step_struct{$step_name}->{queue} =trim( $step_hash->{$step} );
             }
             
             elsif ( $step_condition eq 'cores' ) { 
               $step_struct{$step_name}->{cores} =trim( $step_hash->{$step} );
             }
             elsif( $step_condition eq 'groupby' ) {         
               my @condition_params = split( /\./,$step);            
               $step_struct{$step_name}->{cmd} = $step_hash->{$step};
               $step_struct{$step_name}->{condition} = $step_condition;
               my @params = @condition_params[2 .. $#condition_params];
               $step_struct{$step_name}->{condition_params} = \@params;
             }
             
             # get placeholders
             if( ! exists( $step_struct{$step_name}->{placeholders} ) ){$step_struct{$step_name}->{placeholders} = undef;}#initialise to undef
             if( ( ! defined $step_condition) or ($step_condition eq 'once') or ($step_condition eq 'output') or ($step_condition eq 'groupby') ){
               #my (@placeholders) = ( $step_hash->{$step} =~ /\[\%\s+([a-z0-9\.]+)\s\%\]/g );
               my (@placeholders) = ( $step_hash->{$step} =~ /\[\%\s+([\w\-\.]+)\s+\%\]/g ); #\w is alphanumeric plus _, added more spaces at end. Consider /\[\%\s+([a-z0-9_][\w\.]+)\s+\%\]/g enforcing lower case start.
               if ( @placeholders >= 1){ 
                  $step_struct{$step_name}->{placeholders} = \@placeholders;
               }; 
             }   
  
      }
      return \%step_struct;
  }
  
  1;
APP_PIPELINE_LITE4_PARSER

$fatpacked{"App/Pipeline/Lite4/Resolver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_RESOLVER';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Resolver ;
  use Moo;
  use MooX::late;
  use Ouch;
  use Path::Tiny;
  use Types::Path::Tiny qw/Path AbsPath/;
  use YAML::Any;
  use List::Util qw(max reduce);
  use Data::Table;
  use Data::Dumper;
  use App::Pipeline::Lite4::Template::TinyMod; 
  use App::Pipeline::Lite4::Util;
  use Storable qw(dclone);
  extends 'App::Pipeline::Lite4::Base';
  
  #has pipeline_datasource  => ( isa => 'Data::Table', is => 'rw', lazy_build =>1 );
  has placeholder_hash     => ( isa =>'HashRef', is => 'rw', default => sub {return {}});
  has current_run_num => ( isa => 'Num|Undef', is => 'rw');
  has current_run_dir => (isa => Path, is =>'rw', lazy_build => 1);
  has pipeline_step_struct => ( isa => 'HashRef' , is => 'rw', lazy_build => 1 );
  has pipeline_step_struct_resolved => ( isa => 'HashRef' , is => 'rw', default => sub {{}}  );
  has run_num_dep  => ( isa => 'Num|Undef', is => 'rw');
  has tot_jobs => ( isa => 'Num', is => 'ro', lazy_build => 1);
  #has job_filter_str  => ( isa => 'Str|Undef', is =>'rw');
  has job_filter => ( isa  => 'ArrayRef|Undef', is =>'rw', lazy_build => 1 );
  
  #has step_filter_str => ( isa => 'Str|Undef', is => 'rw'); in base
  has step_filter => ( isa => 'ArrayRef|Undef' , is => 'rw', lazy_build =>1 );
  
  
  #sub _build_pipeline_datasource {
  #    my $self = shift;
  #    my $datasourcefile = path( $self->datasource_file )->absolute;    
  #    ouch 'badfile', "Need to provide datasource file location\n" unless defined( $datasourcefile);
  #    #my $t =  App::Pipeline::Lite2::Datasource->new( datasource_file => $datasourcefile );         
  #    my $t = Data::Table::fromTSV( $datasourcefile->stringify );
  #}
  
  sub _build_pipeline_step_struct {
       my $self = shift;
       my $yaml = $self->pipeline_parse_file->slurp;
       return Load($yaml);   
  }
  
  sub _build_current_run_dir {
      my $self = shift;
      return  path( $self->output_dir, $self->output_run_name . ($self->current_run_num) );
  }
  
  sub _build_tot_jobs {
      my $self = shift;
      return $self->pipeline_datasource->lastRow + 1; 
  }
  
  sub _build_job_filter  {
      my $self= shift;
      
      #check the jobs don't exceed the datasource  
      my $ds_rows = $self-> pipeline_datasource->nofRow;
          
      if( defined $self->job_filter_str ) {
          #my @jobs_to_keep = $self->job_filter_str->split('\s+');
          #return \@jobs_to_keep;
          my $jobs = $self->_parse_job_filter_str($self->job_filter_str);
          my $max_job = max( @$jobs );
          #$self->logger->debug("Check max job filter row with number of datasource rows: ($ds_rows) ");
          $self->logger->debug("Check max of jobs in job filter: ( @$jobs max = $max_job) 
                                 with num of datasource rows: ($ds_rows) ");
          #jobs start from 0                       
          ouch 'App_Pipeline_Lite4_ERROR', "max job in filter exceeds datasource row." if $max_job >= $ds_rows ;
                
          return $jobs;
      } else {
          return undef;    
      }   
  }
  
  sub _parse_job_filter_str {
      my $self = shift;
      my $job_filter_str = shift;
      my @job_filters = split ',', $job_filter_str;
      my @jobs;
      foreach my $job_filter (@job_filters){
          if($job_filter =~ '-'){
             my @pair = split '-', $job_filter;
             push @jobs, $pair[0] .. $pair[1]; 
          }else{
             push @jobs, $job_filter; 
          }
          
      } 
      return [ App::Pipeline::Lite4::Util::uniq( @jobs ) ];
  }
  
  
  sub _build_step_filter {
      my $self = shift;
      if( defined $self->step_filter_str ) {
          #my ($start_step, $end_step) = $self->step_filter_str =~ /([0-9]+)\-([0-9]+)/;
          my @steps;
          #if(defined($start_step) and defined($end_step)){
          #   @steps = $start_step .. $end_step;
          #   return \@steps;
          #} else {
             @steps = split '\s+', $self->step_filter_str;       
             return \@steps;
          #} 
      } else {
          return undef;    
      }
  }
  
  #does this only need to be done on a per job basis.
  sub _step_filter_on_resolved_step_struct  { 
          my $self = shift;
          my $steps = $self->step_filter;
          #warn "@$steps";
          my $resolved_step_struct = $self->pipeline_step_struct_resolved;
          $self->logger->debug( "Steps to keep: @$steps\n");        
          foreach my $step_struct (values %$resolved_step_struct) {
              foreach my $step_name ( keys %$step_struct) {               
                 $self->logger->debug( "Checking $step_name against filter\n" );
                 
                 #### WE WANT ANY####
                 my $code = sub { my $k = shift; return 1 if( $step_name eq $k ); return 0;   };
                 my $dont_delete = reduce { $a || $code->(local $_ = $b)  } 0,  @$steps;
                 
                 #delete $step_struct->{$step_name} unless any{ ($step_name eq $_) } any{ ($step_name eq $_) } @$steps; 
                 #######
                 
                 delete $step_struct->{$step_name} unless $dont_delete; #any{ ($step_name eq $_) } @$steps;          
              }
          }       
          #the run number must be set to the last run. otherwise we could end up with dependency issues.
          #this might not be good enough, e.g. we may have run a smoke_test - this creates output directories
          #my $last_run_num = App::Pipeline::Lite1::Resolver->new( output_dir => $self->output_dir)->_last_run_number;    
          #$self->run_num($last_run_num) unless defined($self->run_num); #the user has already assigned a run number we use this
          #$self->logger->debug("Set run number to " . $self->run_num);
  } 
  
  sub _job_filter_on_resolved_step_struct   { 
       my $self=shift;
       my $jobs_to_keep= $self->job_filter;
        
       my $resolved_step_struct = $self->pipeline_step_struct_resolved;
       $self->logger->debug( "Jobs to keep: @$jobs_to_keep\n");
       
       $self->logger->debug( "RESOLVED STEP STRUCT BEFORE FILTER: " . Dumper($resolved_step_struct)  );
  
       
       foreach my $job_num (keys %$resolved_step_struct) {
           
            #### WE WANT ANY####
                 my $code = sub { my $k = shift; return 1 if( $job_num eq $k ); return 0;   };
                 my $dont_delete = reduce { $a || $code->(local $_ = $b)  } 0,  @$jobs_to_keep;               
            #delete $resolved_step_struct->{$job_num} unless any { ($job_num == $_) } @$jobs_to_keep;
            #######
                   
           delete $resolved_step_struct->{$job_num} unless $dont_delete;
       }
       
       $self->logger->debug( "RESOLVED STEP STRUCT AFTER FILTER: " . Dumper($resolved_step_struct)  );
  }
  
  sub resolve {
     my $self = shift;
     # TYPE: ( Path::Class::File :$yaml_infile,  Path::Class::File :$yaml_outfile )  
     my $yaml_infile  = shift;
     my $yaml_outfile = shift;
     $self->pipeline_parse_file($yaml_infile); #sets the path to yaml file produced by parser step
     $self->_resolve;
     $yaml_outfile->spew( Dump( $self->pipeline_step_struct_resolved ) );
  }
  
  sub _resolve {
      my $self = shift;
      #$self->clear_pipeline_step_struct_resolved;    
      $self->current_run_num( $self->_last_run_number + 1 ) unless defined( $self->current_run_num);
      
      foreach my $row ( 0 .. $self->pipeline_datasource->lastRow ) {
           $self->logger->log("debug", "=== Job $row  ==="); 
           $self->_add_data_source_to_placeholder_hash( $row);
            #add input file directory to placeholder hash
           $self->_add_input_files_to_placeholder_hash;
          
           # add globals to placeholder hash      
           ##$self->_add_dir_to_placeholder_hash ( dir_name => 'global', dir_path => dir( $self->output_dir , 'run' . ($self->current_run_num) )); 
           # add data dir to placeholder hash 
           ##$self->_add_dir_to_placeholder_hash ( dir_name => 'data', dir_path => dir( $self->output_dir->parent ) );
           
           # add in the output files expected for each step to the placeholder hash       
           $self->_add_steps_in_step_struct_to_placeholder_hash($row);
           $self->_create_directory_structure_from_placeholder_hash;         
           
           # add software to placeholder hash - MUST GO AFTER CREATE DIRECTORY
           # OTHERWISE DIRECTORIES WILL BE MADE FOR SOFTWARE
           $self->_add_software_to_placeholder_hash;
           
           # add in the output files expected for each step to the placeholder hash       
           $self->_add_expected_output_files_to_placeholder_hash( $row);
           $self->_add_expected_output_files_to_jobs_in_placeholder_hash;
           #warn Dumper $self->placeholder_hash;
  
           # validate placeholders against placeholder hash
           $self->_validate_placeholder_hash_with_placeholders;
           # interpolate the cmds in each step and add to new resolved_step_struct
           $self->_interpolate_cmd_in_step_struct_to_resolved_step_struct( $row);
           $self->_step_filter_on_resolved_step_struct if defined $self->step_filter_str; 
           $self->_job_filter_on_resolved_step_struct if defined $self->job_filter_str;
           $self->_once_condition_filter_on_resolved_step_struct;
           $self->_groupby_condition_filter_on_resolved_step_struct;
           $self->placeholder_hash({});
      }    
      #$self->logger->log( "info", "Final Resolved Step Struct: \n" . Dumper $self->pipeline_step_struct_resolved );
  }
  
  
  =method _add_data_source_to_placeholder_hash
     Reads the data source as specified in $self->pipeline_datasource and 
     parses a specified row of the datasource to the placeholder_hash  
  =cut
  sub _add_data_source_to_placeholder_hash{ 
        #TYPE:  Num :$datasource_row 
        my $self = shift;
        my $datasource_row = shift;
        my $t = $self->pipeline_datasource;
        my @header = $t->header;
        for my $i (0 .. $t->lastCol ) {
           #print $header[$i], " ", $t->col($i), "\n";      
           my @datasource_rows = $t->col($i);
           $self->logger->log( "debug", "Datasource col $i : ".$header[$i] . " =>  $datasource_rows[$datasource_row]");
           #adds in the datasource reference here, so that we can deal specially with datasource stuff later in create_directory_structure
           $self->_placeholder_hash_add_item( "datasource." . $header[$i],  $datasource_rows[$datasource_row]  );
  
      }   
  }
  
  
  sub _add_software_to_placeholder_hash {
      my $self = shift;
      return unless defined $self->software_dir; 
      my $dir = $self->software_dir;    
      return unless $dir->exists;
      my @software = $dir->children;
  
      #add to placeholder;   
      for my $i (0 .. $#software) {
         $self->_placeholder_hash_add_item( "software.".$software[$i]->basename, $software[$i]->stringify )
          unless $software[$i]->stringify eq $self->software_ini_file->stringify;       
      }  
      
      # we then need to add the software in in the software.ini file
      return unless defined $self->software_ini;
      return unless $self->software_ini_file->exists;
      foreach my $software_name ( keys %{ $self->software_ini->{_} }  ) {
          $self->_placeholder_hash_add_item(  "software.$software_name", $self->software_ini->{_}->{$software_name} );
      }
      
  }
  
  
  sub _add_input_files_to_placeholder_hash {
     my $self = shift;  
     # read folder called input add to the placeholder hash
     # can add folders to input directory and it will pick the names  
     return unless defined $self->input_dir; 
     my $dir = $self->input_dir;
     return unless $dir->stat;
     
     ouch 'App_Pipeline_Lite4_ERROR', "The input directory $dir does not exist" unless $dir->stat;
     
     my @files;
  
     my $iter = $dir->iterator( { recurse => 1 } );  
     while( my $path = $iter->() ){        
          next unless $path->is_file;
          push( @files, $path);
     }
      #add to placeholder;   
      for my $i (0 .. $#files) {
         $self->_placeholder_hash_add_item( "input.".$files[$i]->basename,  
                                             $files[$i]->stringify );
      }
  }
  
  # placeholder hash is where we have {step0}{file1} = value
  # currently we leave it for the groupby case, so that we just have a long key that still matched fine
  # probably we should have the step and its field names as one key 
  # {groupby}{cmp.hmr}{file.name} = /outputdir/job../hmr/file.name
  sub _placeholder_hash_add_item{
     #TYPE: ( Str :$keystr, Str :$value) 
     my $self   = shift;
     my $keystr = shift;
     my $value  = shift; 
     my @keystr = split('\.', $keystr);   
     if( $keystr[0] eq 'jobs'){
  	  @keystr = ( $keystr[0], $keystr[1], join('.', @keystr[2 .. $#keystr]  ) ); 
  	}else {
        @keystr = ( $keystr[0], join('.', @keystr[1 .. $#keystr]  ) );
  	} 
     if (@keystr == 2){
      $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] } = $value ;  
      $self->logger->log("debug", " _placeholder_hash_add_item:  Adding @keystr and $value. Value from hash: " . $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] });
      
     }
      if (@keystr == 3){
         $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] }{ $keystr[2] } = $value;             
     }
  } 
  
  # this method could be broken down into
  # _add_steps_to_placeholder_hash
  # _add_all_job_steps_to_placeholder_hash
  # or leave it like this, except call it _add_steps_to_placeholder_hash
  # as we are using the same mechanism to generate the file locations.
  #
  # this is a horrible function and needs to be fixed and refactored in someway
  # the reason we loop over all jobs is because any job can still refer tot_jobs
  # groupby and jobs placeholders if they wish... not entirely true for groupby 
  # we would have to bring in the syntax to allow a specific group to be instantiated using 
  # groupby.type=A.file.txt or something like that. 
  # at the moment if this is done, then one group is given (the one where the group values are top of an ascending perl sort  
  
  sub _add_steps_in_step_struct_to_placeholder_hash {
     #TYPES: ( Num :$job_num ){
     my $self = shift;
     my $JOB_NUM = shift;
     my $step_struct = $self->pipeline_step_struct; # we have placeholders parsed for each step
     #warn "JOB_NUM $JOB_NUM";
     foreach my $step_name (keys %$step_struct ){
        $self->logger->log( "debug", "Processing Pipeline to placeholder hash step " . $step_name);
        my $placeholders = $step_struct->{$step_name}->{placeholders}; 
        next unless defined($placeholders);      
        foreach my $placeholder ( @$placeholders ) {
              
              #           
              # A placeholder that references a step, should be mentioned in that step. 
              # I.e We do not need to worry about it if it appears in other steps.
              # Thus we only process the placeholders in step X that mention this step X.
              # -----
              
              my $output_files;
              my @output_run_dir;
              # case 1. stepX.fileY
              $self->logger->debug("step $step_name. Processing $placeholder"); 
              #my $placeholder_rgx = qr/(step$step_num)(\.(.+))*/; 
              my $placeholder_rgx = qr/^($step_name)(\.(.+))*$/; 
              if( @output_run_dir = $placeholder =~ $placeholder_rgx ){
                 $self->logger->debug("step $step_name. Got " . Dumper(@output_run_dir) . " from $placeholder");               
                 @output_run_dir = @output_run_dir[0,2]; # we don't want [1], so @output_run_dir is 2 length array
                 if( defined $output_run_dir[1] ){ # if the 2nd element is defined e.g. normally a filename like note.txt
                     # specific case for steps that are once - they can only refer to a single job directory
                    
                     # 2/07/2014
                     # because this is being done for every row in the datasource then we will be making a once step
                     # for each job/row and then later pruning those steps that we dont need - i.e. we only want to have the 
                     # job0 step for a once condition. It should also mean that for row0/job0, any placeholder would get job0 path names 
                     # so this really shouldn't be needed, I'm not sure I understand why it's there.
                     if ( defined (   $step_struct->{$step_name}->{condition} )){
                        
                        if( $step_struct->{$step_name}->{condition} eq 'once' ){ 
                            my $min_job = 0;
                            my $jobs = $self->job_filter;
                            ($min_job) = sort {$a <=> $b} @$jobs if defined($jobs);
                            $output_files = $self->_generate_file_output_location($min_job, \@output_run_dir)->stringify;
                        }else {
                            # we may have to deal with a case here for groupby
                            $output_files = $self->_generate_file_output_location($JOB_NUM, \@output_run_dir)->stringify;  
                        }
                     }else{
                            $output_files = $self->_generate_file_output_location($JOB_NUM, \@output_run_dir)->stringify;               
                     }
                    
                     #the below condition is just weird - by defn $output_run_dir[1] is !defined, 
                     #and $output_run_dir[2] should not exist. 
                     # anyway this below is just the case where the step name exists.
                 }elsif ( ( ! defined $output_run_dir[1] ) and ( ! defined $output_run_dir[2] ) and ( defined $output_run_dir[0] ) ) {
                    pop @output_run_dir; #remove last entry because it def can't be undefined I guess, no, remove last entry because we only want the step dir
                    $output_files = $self->_generate_file_output_location($JOB_NUM, \@output_run_dir)->stringify;
                    #warn "PLACEHOLDER", $placeholder;
                    #warn "OUTPUT RUN DIR (NORMAL PLCHOLDER) ". Dumper @output_run_dir;
                    #warn "OUTPUTFILES(NORMAL PLCHOLDER) ".$output_files;
                 }
                 $self->logger->debug("step $step_name. Extracted a run dir from: @output_run_dir. Full path is $output_files ");  
              }
              
              # case 2.  jobs.stepX.fileY
              # note that because we don't check for conditions in this function
              # then having "jobs...." allows us to identify placeholders that are
              # from once conditions. 
              # I think we should have conditions here instead, jobs only exists in a once step.
              # although it does give some clarity about what is going on in the summary steps.            
              my $jobs_placeholder_rgx = qr/jobs\.([\w\-]+)\.(.+)$/;
              if(@output_run_dir = $placeholder =~ $jobs_placeholder_rgx){
                 # get all the files from a step for all jobs
                 my @stepfiles;
                 my $num_of_jobs = $self->tot_jobs;
                 for my $job_num ( 0 .. $num_of_jobs -1 ) {
                     if( $output_run_dir[0] eq 'datasource' ) {                      
                        my $t = $self->pipeline_datasource;
                        my @datasource_rows = $t->col( $output_run_dir[1] );
                        push( @stepfiles,$datasource_rows[$job_num] ); 
                     }else{    
                        push( @stepfiles, 
                              $self->_generate_file_output_location(
                                  $job_num, \@output_run_dir)->stringify );                   
                     }
                 }
                 # JOB FILTER
                 my $job_filter = $self->job_filter;
                 @stepfiles = @stepfiles[@$job_filter] if defined ( $job_filter );
                 $output_files = join ' ', @stepfiles;
                 $self->logger->debug("step $step_name. Extracted a run dir from: @output_run_dir. Full path is $output_files ");
              }
              
              
              # case 3. groupby
              # to get the run directory we need to make a regex that takes into account
              # the condition_params - we are parsing [% groupby.type.file.txt %]
              # we have to infer the group by fields from the placeholder regex and not the 
              # step condition, because these can occurr in a stp without a groupby condition 
              # the only way to do that is to get the header from the datasource and see if there
              # are any matching fields.
  
              if( $placeholder =~ /groupby/ ){ #don't get in the door unless groupby 
                 my $groupby_placeholder_rgx;
                 # get the datasource
                 
                 my $col_names = $self->pipeline_datasource->{header};
                 #warn "WORKING WITH DATASOURCE: " . $self->datasource_file;
                 #warn "DATASOURCE: " . Dumper $self->pipeline_datasource;
                 
                 my $col_names_rgx_str = join "|", @$col_names;               
                 my $groupby_placeholder_rgx_str = 'groupby\.('.$col_names_rgx_str . ')\.(' . $col_names_rgx_str . ')*\.*([\w\-]+)\.(.+)$';  
                 #warn "PLACEHOLDER $placeholder";
                 #warn "PLACEHOLDER RGX:", $groupby_placeholder_rgx_str;
                 $groupby_placeholder_rgx = qr/$groupby_placeholder_rgx_str/;
                 my @output_run_dir = $placeholder =~  $groupby_placeholder_rgx;
                 #warn "PLACEHOLDER PARTS:", Dumper @output_run_dir;
                
                 # check if the second argument is present
                 my @group_names;
                 if ( defined $output_run_dir[1] ){
  
                     @group_names = @output_run_dir[0,1];
                     @output_run_dir = @output_run_dir[2 .. $#output_run_dir];
                      
                 }else{
  
                     @group_names = $output_run_dir[0 ];
                     @output_run_dir = @output_run_dir[2 .. $#output_run_dir];
                 }
                  # warn "OUTPUTDIR @output_run_dir";
                 if ( ! defined $output_run_dir[0] ){
                     ouch 'App_Pipeline_Lite4_ERROR', "The groupby placeholder has a group name that does not exist in the datasource";
                 }
                       
                 # now get the mapping of job ids
                 #warn "OUTPUTDIR", "@output_run_dir";
                 my $util = App::Pipeline::Lite4::Util->new;
                 #warn "GROUP NAMES: @group_names";
                 my $job_map_hash = $util->datasource_groupby2( $self->pipeline_datasource, @group_names );
                 #warn Dumper $job_map_hash;
                 
                 # So now run through the jobids and make strings of the files
                 # we only do the jobs that we need to do, i.e. since we have grouped into eg 4 groups, 
                 # we only want to do the four jobs and these will be done on each iteration of _resolve looop 
                 my @grouped_jobs = sort keys %$job_map_hash; 
                 my $grouped_job_idx;
                 $grouped_job_idx = ($JOB_NUM <= $#grouped_jobs) ? $JOB_NUM : 0; 
                 # for job numbers higher, then you get the first group 
                 # this will be implemented later so that you can chose 
                 # which group thought someihtng like
                 # [% groupby.type=A.file.txt %]
                 my $grouped_jobs_id = $grouped_jobs[ $grouped_job_idx ];
                 my @stepfiles;
                 my $jobs = $job_map_hash->{$grouped_jobs_id};
                 for my $job_num ( @$jobs){
                     
                     if( $output_run_dir[0] eq 'datasource' ) {                      
                        my $t = $self->pipeline_datasource;
                        my @datasource_rows = $t->col( $output_run_dir[1] );
                        push( @stepfiles,$datasource_rows[$job_num] ); 
                    }else{
                     
                     
                     push( @stepfiles, $self->_generate_file_output_location($job_num, \@output_run_dir)->stringify);                  
                    }
                 
                 }
                 my $job_filter = $self->job_filter;
                 @stepfiles = @stepfiles[@$job_filter] if defined ( $job_filter );
                 $output_files = join ' ', @stepfiles;
                 #warn "STEPFILES: $output_files";
                 
              } 
              
              # add to placeholder hash - if there is something to add
              if( defined( $output_files ) ){               
                  $self->_placeholder_hash_add_item( $placeholder, $output_files); #in order key,value
                  $self->logger->debug("step $step_name. Generated file location for placeholder $placeholder as $output_files");
              }
           }  
     }
     #warn Dumper $self->placeholder_hash;
  }
  
  =method _create_directory_structure_from_placeholder_hash  
    At the moment we  allow directory with 'dir' in the name
    to be created as a directory - e.g. for this scenario 
    e.g. 1. some_app --output-dir [ step1.dir ]
    Where some_app requires a pre-existing directory for storing it's output
    We could resolve this issue without using this.
    By doing:
    1. mkdir [% step1.outputdir %]; some_app --output-dir [% step1.outputdir %]
    So it's debatable whether we want automatic creation of directories with 'dir' in the name, 
    but will leave for backwards compatability
    THE DIR BEHAVIOUR SHOULD BE DEPRECATED
  =cut
  
  sub _create_directory_structure_from_placeholder_hash {
      my $self = shift;
      $self->logger->debug("Creating directory structure from placeholder hash...");
      # run over hash    
      my $placeholder_hash = $self->placeholder_hash;
      $self->logger->debug(Dumper($placeholder_hash));
      foreach my $step (keys %$placeholder_hash ){
         next if( ($step eq 'step0') or ($step eq 'datasource')); # we don't create any directories from the source step values. (which could be filenames)
         next if( ($step eq 'groupby')); # don't make directory on a groupby
         foreach my $param (keys $placeholder_hash->{$step} ){
             if ($param =~ /dir/) {
                 my $dir = path( $placeholder_hash->{$step}->{$param} );
                 #make_path($dir->stringify);
                 $dir->mkpath;
                 $self->logger->debug("Making directory: $dir" );
             } else {
                my $file = path( $placeholder_hash->{$step}->{$param} );
                #make_path($file->parent->stringify);
                $file->parent->mkpath;
                $self->logger->debug("Making directory (step $step): " . $file->parent->stringify );
                 
             }
         }      
      }
  } 
  
  # processing the "X.output file1 file2 .."  lines 
  sub _add_expected_output_files_to_placeholder_hash {
       # TYPE: ( Num :$job_num ) 
       my $self = shift;
       my $job_num = shift;
       my $step_struct = $self->pipeline_step_struct; # we have outputfiles parsed for each step     
       foreach my $step_name (keys %$step_struct ){
          $self->logger->debug( "Processing expected output file for Step: " . $step_name); 
          $self->logger->debug("Make filepaths and placeholder hash entry for stated outputs of step $step_name");
          my $file_num = 1;
          $self->logger->debug("So far there are " . ($file_num - 1) . " file(s) registered as outputs for this step");
          my $outputfiles = $step_struct->{$step_name}->{outputfiles};
          if( defined( $outputfiles) ) {
              foreach my $outputfile ( @$outputfiles ) {  
                    #output_path_in_run_dir should be output_path_in_job_dir
                    #check whether the file_path is absolute, if its absolute then we don't generate anything for it  
                   # if($step_name =~ /^[1-9][0-9]*[a-z]*$/){
                   #   my $file_path = $self->_generate_file_output_location( $job_num, ['step'. $step_name , $outputfile] ); 
                   #   $self->placeholder_hash->{"step$step_name"}{"output$file_num"}=$file_path->stringify; 
                   #   $self->logger->debug( "Made step$step_name output$file_num : " . $file_path->stringify);
                   #   $file_num++;
                   # }else{
                      my $file_path = $self->_generate_file_output_location( $job_num, [ $step_name , $outputfile] ); 
                      $self->placeholder_hash->{"$step_name"}{"output$file_num"}=$file_path->stringify; 
                      $self->logger->debug( "Made $step_name output$file_num : " . $file_path->stringify);
                      $file_num++;
                   # }    
              }
          }
       }
  }
  
  sub _add_expected_output_files_to_jobs_in_placeholder_hash {
      my $self = shift;
      #get the expected output files
      my $step_struct = $self->pipeline_step_struct;   
      my $placeholder_hash = $self->placeholder_hash;    
      return if( ! exists $placeholder_hash->{jobs} );    
      my $jobs = $placeholder_hash->{jobs};    
      foreach my $step (keys %$jobs){
         next if $step eq 'datasource';
         my $filenames_and_paths = $jobs->{$step};
         my @filenames = keys %$filenames_and_paths;
         foreach my $filename (@filenames){
           my ($output_num) = $filename =~ /output([0-9]+)/;   
           next unless defined( $output_num);      
           my $outputfiles = $step_struct->{$step}->{outputfiles};
           my $name_of_output_file  = $outputfiles->[$output_num-1];
           $filenames_and_paths->{$filename}  =~ s/output$output_num/$name_of_output_file/g;
         }
      }
  }
  
  =method _validate_placeholder_with_placeholders
     
     What happens if you add a non existant placeholder e.g. [% step0.fil %] ?
     The parser has parsed out this placeholder - so it is part of the step_struct placeholders for each step
     But, it won't have a corresponding value in the placeholder hash, since it not of the right form.
     Not having a value, might be desired behaviour for somethings (this could be warned), 
     But not existing in the hash is an error.
     
  =cut
  
  sub _validate_placeholder_hash_with_placeholders {
     my $self = shift;   
     #foreach step check that we have the right stuff in the placeholder hash
      my $step_struct = $self->pipeline_step_struct;
      my %problem_placeholders;
      foreach my $step_name ( keys %$step_struct) {
         my $placeholders = $step_struct->{$step_name}->{placeholders}; 
         $self->logger->debug( "Validating Step: " . $step_name);
          foreach my $placeholder (@$placeholders) {
             #if($placeholder =~ /^datasource\./){
             #   ($placeholder ) = $placeholder =~ /datasource\.(.+)$/; 
             #}
             #ouch 'App_Pipeline_Lite2_Error', "Check the placeholder $placeholder - it is incorrectly named." 
             #  . Dumper ($self->placeholder_hash)
             #  unless $self->_placeholder_hash_check_item_exists( keystr => $placeholder );
             $problem_placeholders{ $placeholder } = 1  unless $self->_placeholder_hash_check_item_exists(  $placeholder );;  
          }
      }
      my @problem_placeholders = keys %problem_placeholders;
      my $problem_placeholders = join "\n", @problem_placeholders ;
      ouch 'App_Pipeline_Lite4_Error_MISSING_PLACEHOLDER', "Check the placeholders:\n$problem_placeholders\n" 
               if @problem_placeholders > 0;
      
  }
  
  sub _interpolate_cmd_in_step_struct_to_resolved_step_struct {
      # ( Num :$job_num ) {
      my $self = shift;   
      my $job_num = shift;   
      my $step_struct = $self->pipeline_step_struct;
      $self->logger->debug("Step struct has : " . Dumper( $step_struct ));
      $self->logger->debug("Placeholder hash has : " . Dumper ( $self->placeholder_hash ) );
      my %output_hash;
      my $interpolated_cmd;
      my $interpolated_output;
      my $new_step_struct = dclone($step_struct);
      my $tt = App::Pipeline::Lite4::Template::TinyMod->new;
      foreach my $step ( keys %$step_struct) {
         my $cmd = $step_struct->{$step}->{cmd}; 
         $interpolated_cmd = $tt->_process($self->placeholder_hash, $cmd);
         $new_step_struct->{$step}->{cmd} =$interpolated_cmd;
         $interpolated_cmd = '';
         
         #also do for output line
        
         if( exists $step_struct->{$step}->{outputfiles} ){ 
             my $output_files = $step_struct->{$step}->{outputfiles}; 
              $new_step_struct->{$step}->{outputfiles} = [];
             foreach my $output (@$output_files){
                 $interpolated_output = $tt->_process($self->placeholder_hash, $output);
                 my $outputfiles = $new_step_struct->{$step}->{outputfiles}; 
                 push(@$outputfiles, $interpolated_output); #CHECK THIS IN TEST
                 $interpolated_output = '';
             }
         } 
      }
      $self->pipeline_step_struct_resolved->{$job_num} = $new_step_struct;    
  }
  
  
  sub _placeholder_hash_check_item_exists{
      # TYPE: Str :$keystr
      my $self = shift;
      my $keystr = shift;
      my @keystr = ();
      @keystr = split('\.', $keystr) if ($keystr =~ /\./);
      return exists $self->placeholder_hash->{ $keystr } if( @keystr == 0);
        
      if( $keystr[0] eq 'jobs'){
  	  @keystr = ( $keystr[0], $keystr[1], join('.', @keystr[2 .. $#keystr]  ) ); 
  	}else {
        @keystr = ( $keystr[0], join('.', @keystr[1 .. $#keystr]  ) );
  	} 
  	
      return exists $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] } if @keystr == 2;  
      return exists $self->placeholder_hash->{ $keystr[0] }{ $keystr[1] }{ $keystr[2] } if @keystr == 3;   
  }
  
  sub _once_condition_filter_on_resolved_step_struct {
     my $self = shift;
     my $resolved_step_struct = $self->pipeline_step_struct_resolved;
     my @keys = sort {$a <=> $b } keys %$resolved_step_struct;
     shift @keys; #remove the lowest job
     $self->logger->debug("Deleting once steps in these steps: @keys");
     foreach my $job_num (@keys){  
         my $job = $resolved_step_struct->{$job_num}; 
         foreach my $step (keys %$job) { 
            next unless ( exists  $job->{$step}->{condition}  ); 
            next unless ( defined $job->{$step}->{condition}  );   
            if ( $job->{$step}->{condition} eq 'once') {
                  $self->logger->debug("Deleting once step in $job_num");
                  delete $job->{$step};
            }
         }
     }         
  } 
  
  sub _groupby_condition_filter_on_resolved_step_struct {
      my $self = shift;
      my $resolved_step_struct = $self->pipeline_step_struct_resolved;
      my @keys = sort {$a <=> $b } keys %$resolved_step_struct;
      # need to get the number of jobs to shift off.
      my $util = App::Pipeline::Lite4::Util->new;
     
      #shift @keys for 0 .. $num_grouped_jobs - 1; #remove the X lowest jobs depending on the step groupby clause
      $self->logger->debug("Consider deleting groupby steps in these steps: @keys");
      foreach my $job_num (@keys){  
         my $job = $resolved_step_struct->{$job_num}; 
         foreach my $step (keys %$job) { 
            next unless ( exists  $job->{$step}->{condition}  ); 
            next unless ( defined $job->{$step}->{condition}  );   
            if ( $job->{$step}->{condition} eq 'groupby') {                
                  my $params = $job->{$step}->{condition_params};
                  my $num_grouped_jobs = $util->datasource_groupby2_num_groups($self->pipeline_datasource, @$params);
                  if( $job_num >= $num_grouped_jobs){
                      $self->logger->debug("Deleting groupby step $step in $job_num");
                      delete $job->{$step};
                  }
            }
         }
     }           
  }
  
  
  
  sub _generate_file_output_location { 
     # TYPE:( :$job_num, :$output_path_in_run_dir )  
     my ($self, $job_num, $output_path_in_run_dir) = @_;
     if ( defined $self->run_num_dep ) { 
        my $steps = $self->step_filter;
        
        #### WE WANT ANY####
        my $code = sub { my $k = shift; return 1 if( $output_path_in_run_dir->[0] eq $k ); return 0;   };
        my $valid_step = reduce { $a || $code->(local $_ = $b)  } 0,  @$steps;
        # my $valid_step = any{ ($output_path_in_run_dir->[0] =~ $_) } @$steps;
        ###############
              
        if ( !$valid_step ) { 
         my $alt_run_dir = path( $self->output_dir, $self->output_run_name . ($self->run_num_dep) );
         return path( $alt_run_dir , $self->output_job_name .  $job_num, @$output_path_in_run_dir );
        }
     }
     return path( $self->current_run_dir , $self->output_job_name .  $job_num, @$output_path_in_run_dir );
     # return file( $self->output_dir, 'run' . ($self->current_run_num) , $self->output_job_name .  $job_num, @$output_path_in_run_dir );
  }
  
  =method _run_number 
     Provides the last run number by looking at previous run directory numbers
  =cut
  ## THIS IS IN BASE NOW - REMOVE
  sub _last_run_number {
      my $self=shift;
      #read in files in data directory
      #order by run number
      # - if none then run number is 1.
      my $run_num = max map { if( $_ =~ /run([0-9]+)/){$1}else{} } $self->output_dir->children;
      $run_num = 0 unless (defined $run_num);    
      return $run_num;   
  }
  
  1;
APP_PIPELINE_LITE4_RESOLVER

$fatpacked{"App/Pipeline/Lite4/SetupPipeline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_SETUPPIPELINE';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::SetupPipeline ;
  use Moo;
  use MooX::late;
  
  extends 'App::Pipeline::Lite4::Base';
  use Ouch;
  use Path::Tiny;
  use YAML::Any;
   
  sub create_pipeline_directory {
      my $self=shift;
      my $based_on = shift; # PARAMETER TYPE: ( Path::Tiny $based_on? ) i.e. optional 
      
      my $dir             = $self->pipeline_dir;
      my $output_dir      = $self->output_dir;
      my $input_dir       = $self->input_dir;
      my $pipeline_file   = $self->pipeline_file;
      my $test_data_file  = $self->test_data_file;
      my $datasource_file = $self->datasource_file;
      my $software_dir    = $self->software_dir;
      ouch 'App_Pipeline_Lite4_Error', "That pipeline already exists."  if $dir->exists;
      $dir->mkpath();  
      $output_dir->mkpath();
      $input_dir->mkpath();
      $software_dir->mkpath();
      
      #set output file and read to config file
      $self->config->{_}->{output_dir} = $output_dir->absolute->stringify;
      $self->config->{_}->{input_dir}  = $input_dir->absolute->stringify;
  
      $self->config->write($self->config_file->absolute->stringify); 
      
      #create a small pipeline file and a dummy test data directory
      $pipeline_file->spew("1. wc -l [% step0.file1 %] > [% step1.file1 %]");
      $test_data_file->parent->mkpath();
      $test_data_file->spew("line1\nline2\nline3");
      
      #create a small datasource file
      my $datasource = "step0.file1\n" . $test_data_file->absolute->stringify;
      $datasource_file->spew($datasource);
      $self->create_logfile_config;
  }
  
  
  sub create_logfile_config {
     my $self = shift; 
     my $default = 
     { 
       file => {
                filename => defined($self->logfile) ? $self->logfile : "/tmp/".__PACKAGE__.".log",
                maxlevel => "debug",
                minlevel => "warning",
                message_layout => "%T [%L] [%p] line %l: %m",
              }
     };
     my $conf_yaml  = Dump($default);
     $self->logconffile->spew($conf_yaml);  
  }
  1;
APP_PIPELINE_LITE4_SETUPPIPELINE

$fatpacked{"App/Pipeline/Lite4/Template/TinyMod.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_TEMPLATE_TINYMOD';
  package App::Pipeline::Lite4::Template::TinyMod;
  
  # Load overhead: 40k
  
  #use 5.00503;
  use strict;
  
  $Template::Tiny::VERSION = '1.12';
  
  # Evaluatable expression
  my $EXPR = qr/ [a-z_\-][\-\w.]* /xs;
  
  # Opening [% tag including whitespace chomping rules
  my $LEFT = qr/
  	(?:
  		(?: (?:^|\n) [ \t]* )? \[\%\-
  		|
  		\[\% \+?
  	) \s*
  /xs;
  
  # Closing %] tag including whitespace chomping rules
  my $RIGHT  = qr/
  	\s* (?:
  		\+? \%\]
  		|
  		\-\%\] (?: [ \t]* \n )?
  	)
  /xs;
  
  sub new {
  	bless { @_[1..$#_] }, $_[0];
  }
  
  sub _process {
  	my ($self, $stash, $text) = @_;
      # Resolve expressions
  
  	$text =~ s/
  		$LEFT ( $EXPR ) $RIGHT
  	/
  		eval {
  			$self->_expression($stash, $1)
  			. '' # Force stringification
  		}
  	/gsex;
  	return $text;
  }
  
  
  sub _expression {
  	my $cursor = $_[1];
  	
  	my @path   = split /\./, $_[2];
  	if( $path[0] eq 'jobs'){
  	  @path = ( $path[0], $path[1], join('.', @path[2 .. $#path]  ) ); 
  	}else {
        @path = ( $path[0], join('.', @path[1 .. $#path]  ) );
  	}
  	
  	foreach ( @path ) {
  		# Support for private keys
  		return undef if substr($_, 0, 1) eq '_';
  
  		# Split by data type
  		my $type = ref $cursor;
  		
  		#if ( $type eq 'ARRAY' ) {
  		#	return '' unless /^(?:0|[0-9]\d*)\z/;
  		#	$cursor = $cursor->[$_];
  		#} elsif ( $type eq 'HASH' ) {
  		#	$cursor = $cursor->{$_};
  		#} elsif ( $type ) {
  		#	$cursor = $cursor->$_();
  		#} else {
  		#	return '';
  		#}
  		if ( $type eq 'HASH' ) {
  			$cursor = $cursor->{$_};
  	    }else {
  		  return '';	
          }
  		
  	}
  	return $cursor;
  }
APP_PIPELINE_LITE4_TEMPLATE_TINYMOD

$fatpacked{"App/Pipeline/Lite4/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PIPELINE_LITE4_UTIL';
  use strict;
  use warnings;
  package App::Pipeline::Lite4::Util ;
  use Moo;
  use Term::UI;
  use Term::ReadLine; 
  use Path::Tiny;
  use Time::Piece;
  use Data::Dumper;
  extends 'App::Pipeline::Lite4::Base';
   
  use Ouch;
  
  sub view_file_with_editor {
      my $self = shift; 
      my $filename = shift; # PARAMETER TYPE: ( Path::Tiny $filename ) 
      
      my $editor = $self->system_config->{_}->{editor} ; #check system config first     
      ouch 'App_Pipeline_Lite4_Error', "No pipeline editor set, try --editor EDITOR.  (e.g. --editor vim)" unless defined($editor);    
      my $cmd = qq{$editor $filename};
      
      eval {
        system($cmd);
      };
      
      if ( hug ) {
        ouch 'App_Pipeline_Lite4_Error', "Viewing the file with the editor '$editor' did not work. Perhaps set something different in system config.";    
      }
  }
  
  sub set_editor  {
      my $self = shift;
      my $editor = shift; # TYPE: ( Str $editor  )
      $self->system_config->{_}->{editor}  = $editor;
      $self->system_config->write($self->system_config_file);
      $self->system_logger->log( "info", "Set $editor as default editor");
  }
  
  sub ask_for_description {
    #( Num $run_num ) {
    my $self = shift;  
    my $term = Term::ReadLine->new('describe-run');
      
    my $print_me = <<PRINTME;
       
       *************
        Description
       -------------    
  PRINTME
      
      my $bool = $term->ask_yn(
              prompt => "Do you want to describe this run?"            
              );
            
     if($bool) {
       my $desc = $term->get_reply(
              print_me => $print_me,
              prompt => "Enter description: ",
       ); 
     }  
  }
  
  sub append_description {
    my $self         = shift;  
    my $run_info     = shift // "";
    my $message      = shift // "";
    my $append_file  = $self->pipeline_submission_file;
    my $t = localtime;
    my $run_desc = join "\t", $t->datetime, $run_info, $message;
    $run_desc .= "\n";
    my $path = path($append_file)->append($run_desc); 
  }
  
  sub uniq {
    my %seen;
    return grep { !$seen{$_}++ } @_;
  }
  
  sub datasource_groupby {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field = shift;
    my %group_hash; 
    # create hash
    my $next = $datasource_table->iterator();
    my $i = 0;
    while( my $row = $next->() ){ 
      #warn Dumper $row;   
      push( @{ $group_hash{ $row->{$groupby_field} } }, $i );  
      $i++;
    }
    return \%group_hash; 
  }
  #the idea is to only offer a groupby one attribute, if more than one
  #is required then the datasource should be given an extra column and
  # the two column mergedin to a specific column
  # the exception is for grouptransby which will work with two columns in general I think.
  # for testing purposes we have this here.
  =cut
  sub datasource_groupby2 {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field1 = shift;
    my $groupby_field2 = shift;
    my %group_hash; 
    # create hash
    my $next = $datasource_table->iterator();
    my $i = 0;
    while( my $row = $next->() ){ 
      #warn Dumper $row;
      
      if( defined($groupby_field1) and defined( $groupby_field2 )){    
          push( @{ $group_hash{$row->{$groupby_field1} .'-' . $row->{$groupby_field2} } } , $i );  
      }elsif( defined($groupby_field1 ) ){
          push( @{ $group_hash{ $row->{$groupby_field1} } }, $i );   
      }else{
          ouch "App_Pipeline_Lite4_Error","No groupby fields to group by";
      }
        
      $i++;
    }
    return \%group_hash; 
  }
  =cut
  sub datasource_groupby2 {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field1 = shift;
    my $groupby_field2 = shift;
    my $grouphash_and_order_array = datasource_groupby2main($datasource_table,$groupby_field1,$groupby_field2);
    return $grouphash_and_order_array->[0];
  }
  
  
  sub datasource_groupby2main {
    #my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field1 = shift;
    my $groupby_field2 = shift;
    my %group_hash; 
    # create hash
    my $next = $datasource_table->iterator();
    my $i = 0;
    my @group_array;
    my @group_array_unique;
    while( my $row = $next->() ){ 
      #warn Dumper $row;
      if( defined($groupby_field1) and defined( $groupby_field2 )){    
          push( @{ $group_hash{$row->{$groupby_field1} .'-' . $row->{$groupby_field2} } } , $i );  
          push( @group_array, $row->{$groupby_field1} .'-' . $row->{$groupby_field2});
      }elsif( defined($groupby_field1 ) ){
          push( @{ $group_hash{ $row->{$groupby_field1} } }, $i );   
          push( @group_array, $row->{$groupby_field1} );
      }else{
          ouch "App_Pipeline_Lite4_Error","No groupby fields to group by";
      }
        
      $i++;
    }
    @group_array_unique = uniq( @group_array);
    return [ \%group_hash, \@group_array_unique]; 
  }
  
  
  # this gives back group ids in an ordering that
  # is ordered by first instance of group in the datasource
  sub datasource_groupby2_order {
    my $self = shift;
    my $datasource_table  =shift;
    my $groupby_field1 = shift;
    my $groupby_field2 = shift;
    my $grouphash_and_order_array = datasource_groupby2main($datasource_table,$groupby_field1,$groupby_field2);
    return $grouphash_and_order_array->[1];
  }
  
   
  
  sub datasource_groupby2_num_groups {
    my $self = shift;
    my @args = @_;
    #warn "DATASOURC ARGS ," , Dumper @args;
    my $groupby_hash = $self->datasource_groupby2(@args);
    return scalar keys %$groupby_hash;  
  }
  
  sub groupby_placeholder_regex_get_step {
    my $self       = shift;
    my $datasource = shift;
    my $groupby_fields  = shift;
  
    my $col_names = $datasource->{header};
    my $col_names_rgx_str = join "|", @$col_names;               
    my $groupby_placeholder_rgx_str = 'groupby\.('.$col_names_rgx_str . ')\.(' . $col_names_rgx_str . ')*\.*(.+)$';
    
  }
  
  1;
APP_PIPELINE_LITE4_UTIL

$fatpacked{"Graph.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH';
  package Graph;
  
  use strict;
  
  BEGIN {
      if (0) { # SET THIS TO ZERO FOR TESTING AND RELEASES!
  	$SIG{__DIE__ } = \&__carp_confess;
  	$SIG{__WARN__} = \&__carp_confess;
      }
      sub __carp_confess { require Carp; Carp::confess(@_) }
  }
  
  use Graph::AdjacencyMap qw(:flags :fields);
  
  use vars qw($VERSION);
  
  $VERSION = '0.96';
  
  require 5.006; # Weak references are absolutely required.
  
  my $can_deep_copy_Storable =
      eval 'require Storable; require B::Deparse; $Storable::VERSION >= 2.05 && $B::Deparse::VERSION >= 0.61' && !$@;
  
  sub _can_deep_copy_Storable () {
      return $can_deep_copy_Storable;
  }
  
  use Graph::AdjacencyMap::Heavy;
  use Graph::AdjacencyMap::Light;
  use Graph::AdjacencyMap::Vertex;
  use Graph::UnionFind;
  use Graph::TransitiveClosure;
  use Graph::Traversal::DFS;
  use Graph::MSTHeapElem;
  use Graph::SPTHeapElem;
  use Graph::Undirected;
  
  use Heap071::Fibonacci;
  use List::Util qw(shuffle first);
  use Scalar::Util qw(weaken);
  
  use Safe;  # For deep_copy().
  
  sub _F () { 0 } # Flags.
  sub _G () { 1 } # Generation.
  sub _V () { 2 } # Vertices.
  sub _E () { 3 } # Edges.
  sub _A () { 4 } # Attributes.
  sub _U () { 5 } # Union-Find.
  sub _S () { 6 } # Successors.
  sub _P () { 7 } # Predecessors.
  
  my $Inf;
  
  BEGIN {
      local $SIG{FPE}; 
      eval { $Inf = exp(999) } ||
  	eval { $Inf = 9**9**9 } ||
  	    eval { $Inf = 1e+999 } ||
  		{ $Inf = 1e+99 };  # Close enough for most practical purposes.
  }
  
  sub Infinity () { $Inf }
  
  # Graphs are blessed array references.
  # - The first element contains the flags.
  # - The second element is the vertices.
  # - The third element is the edges.
  # - The fourth element is the attributes of the whole graph.
  # The defined flags for Graph are:
  # - _COMPAT02 for user API compatibility with the Graph 0.20xxx series.
  # The vertices are contained in either a "simplemap"
  # (if no hypervertices) or in a "map".
  # The edges are always in a "map".
  # The defined flags for maps are:
  # - _COUNT for countedness: more than one instance
  # - _HYPER for hyperness: a different number of "coordinates" than usual;
  #   expects one for vertices and two for edges
  # - _UNORD for unordered coordinates (a set): if _UNORD is not set
  #   the coordinates are assumed to be meaningfully ordered
  # - _UNIQ for unique coordinates: if set duplicates are removed,
  #   if not, duplicates are assumed to meaningful
  # - _UNORDUNIQ: just a union of _UNORD and UNIQ
  # Vertices are assumed to be _UNORDUNIQ; edges assume none of these flags.
  
  use Graph::Attribute array => _A, map => 'graph';
  
  sub _COMPAT02 () { 0x00000001 }
  
  sub stringify {
      my $g = shift;
      my $u = $g->is_undirected;
      my $e = $u ? '=' : '-';
      my @e =
  	map {
  	    my @v =
  		map {
  		    ref($_) eq 'ARRAY' ? "[" . join(" ", @$_) . "]" : "$_"
  		}
  	    @$_;
  	    join($e, $u ? sort { "$a" cmp "$b" } @v : @v) } $g->edges05;
      my @s = sort { "$a" cmp "$b" } @e;
      push @s, sort { "$a" cmp "$b" } $g->isolated_vertices;
      join(",", @s);
  }
  
  sub eq {
      "$_[0]" eq "$_[1]"
  }
  
  sub ne {
      "$_[0]" ne "$_[1]"
  }
  
  use overload
      '""' => \&stringify,
      'eq' => \&eq,
      'ne' => \&ne;
  
  sub _opt {
      my ($opt, $flags, %flags) = @_;
      while (my ($flag, $FLAG) = each %flags) {
  	if (exists $opt->{$flag}) {
  	    $$flags |= $FLAG if $opt->{$flag};
  	    delete $opt->{$flag};
  	}
  	if (exists $opt->{my $non = "non$flag"}) {
  	    $$flags &= ~$FLAG if $opt->{$non};
  	    delete $opt->{$non};
  	}
      }
  }
  
  sub is_compat02 {
      my ($g) = @_;
      $g->[ _F ] & _COMPAT02;
  }
  
  *compat02 = \&is_compat02;
  
  sub has_union_find {
      my ($g) = @_;
      ($g->[ _F ] & _UNIONFIND) && defined $g->[ _U ];
  }
  
  sub _get_union_find {
      my ($g) = @_;
      $g->[ _U ];
  }
  
  sub _opt_get {
      my ($opt, $key, $var) = @_;
      if (exists $opt->{$key}) {
  	$$var = $opt->{$key};
  	delete $opt->{$key};
      }
  }
  
  sub _opt_unknown {
      my ($opt) = @_;
      if (my @opt = keys %$opt) {
  	my $f = (caller(1))[3];
  	require Carp;
  	Carp::confess(sprintf
  		      "$f: Unknown option%s: @{[map { qq['$_'] } sort @opt]}",
  		      @opt > 1 ? 's' : '');
      }
  }
  
  sub new {
      my $class = shift;
      my $gflags = 0;
      my $vflags;
      my $eflags;
      my %opt = _get_options( \@_ );
  
      if (ref $class && $class->isa('Graph')) {
  	no strict 'refs';
          for my $c (qw(undirected refvertexed compat02
                        hypervertexed countvertexed multivertexed
                        hyperedged countedged multiedged omniedged
  		      __stringified)) {
  #            $opt{$c}++ if $class->$c; # 5.00504-incompatible
  	    if (&{"Graph::$c"}($class)) { $opt{$c}++ }
          }
  #        $opt{unionfind}++ if $class->has_union_find; # 5.00504-incompatible
  	if (&{"Graph::has_union_find"}($class)) { $opt{unionfind}++ }
      }
  
      _opt_get(\%opt, undirected   => \$opt{omniedged});
      _opt_get(\%opt, omnidirected => \$opt{omniedged});
  
      if (exists $opt{directed}) {
  	$opt{omniedged} = !$opt{directed};
  	delete $opt{directed};
      }
  
      my $vnonomni =
  	$opt{nonomnivertexed} ||
  	    (exists $opt{omnivertexed} && !$opt{omnivertexed});
      my $vnonuniq =
  	$opt{nonuniqvertexed} ||
  	    (exists $opt{uniqvertexed} && !$opt{uniqvertexed});
  
      _opt(\%opt, \$vflags,
  	 countvertexed	=> _COUNT,
  	 multivertexed	=> _MULTI,
  	 hypervertexed	=> _HYPER,
  	 omnivertexed	=> _UNORD,
  	 uniqvertexed	=> _UNIQ,
  	 refvertexed	=> _REF,
  	 refvertexed_stringified => _REFSTR ,
  	 __stringified => _STR,
  	);
  
      _opt(\%opt, \$eflags,
  	 countedged	=> _COUNT,
  	 multiedged	=> _MULTI,
  	 hyperedged	=> _HYPER,
  	 omniedged	=> _UNORD,
  	 uniqedged	=> _UNIQ,
  	);
  
      _opt(\%opt, \$gflags,
  	 compat02      => _COMPAT02,
  	 unionfind     => _UNIONFIND,
  	);
  
      if (exists $opt{vertices_unsorted}) { # Graph 0.20103 compat.
  	my $unsorted = $opt{vertices_unsorted};
  	delete $opt{vertices_unsorted};
  	require Carp;
  	Carp::confess("Graph: vertices_unsorted must be true")
  	    unless $unsorted;
      }
  
      my @V;
      if ($opt{vertices}) {
  	require Carp;
  	Carp::confess("Graph: vertices should be an array ref")
  	    unless ref $opt{vertices} eq 'ARRAY';
  	@V = @{ $opt{vertices} };
  	delete $opt{vertices};
      }
  
      my @E;
      if ($opt{edges}) {
  	unless (ref $opt{edges} eq 'ARRAY') {
  	    require Carp;
  	    Carp::confess("Graph: edges should be an array ref of array refs");
  	}
  	@E = @{ $opt{edges} };
  	delete $opt{edges};
      }
  
      _opt_unknown(\%opt);
  
      my $uflags;
      if (defined $vflags) {
  	$uflags = $vflags;
  	$uflags |= _UNORD unless $vnonomni;
  	$uflags |= _UNIQ  unless $vnonuniq;
      } else {
  	$uflags = _UNORDUNIQ;
  	$vflags = 0;
      }
  
      if (!($vflags & _HYPER) && ($vflags & _UNORDUNIQ)) {
  	my @but;
  	push @but, 'unordered' if ($vflags & _UNORD);
  	push @but, 'unique'    if ($vflags & _UNIQ);
  	require Carp;
  	Carp::confess(sprintf "Graph: not hypervertexed but %s",
  		      join(' and ', @but));
      }
  
      unless (defined $eflags) {
  	$eflags = ($gflags & _COMPAT02) ? _COUNT : 0;
      }
  
      if (!($vflags & _HYPER) && ($vflags & _UNIQ)) {
  	require Carp;
  	Carp::confess("Graph: not hypervertexed but uniqvertexed");
      }
  
      if (($vflags & _COUNT) && ($vflags & _MULTI)) {
  	require Carp;
  	Carp::confess("Graph: both countvertexed and multivertexed");
      }
  
      if (($eflags & _COUNT) && ($eflags & _MULTI)) {
  	require Carp;
  	Carp::confess("Graph: both countedged and multiedged");
      }
  
      my $g = bless [ ], ref $class || $class;
  
      $g->[ _F ] = $gflags;
      $g->[ _G ] = 0;
      $g->[ _V ] = ($vflags & (_HYPER | _MULTI)) ?
  	Graph::AdjacencyMap::Heavy->_new($uflags, 1) :
  	    (($vflags & ~_UNORD) ?
  	     Graph::AdjacencyMap::Vertex->_new($uflags, 1) :
  	     Graph::AdjacencyMap::Light->_new($g, $uflags, 1));
      $g->[ _E ] = (($vflags & _HYPER) || ($eflags & ~_UNORD)) ?
  	Graph::AdjacencyMap::Heavy->_new($eflags, 2) :
  	    Graph::AdjacencyMap::Light->_new($g, $eflags, 2);
  
      $g->add_vertices(@V) if @V;
  
      if (@E) {
  	for my $e (@E) {
  	    unless (ref $e eq 'ARRAY') {
  		require Carp;
  		Carp::confess("Graph: edges should be array refs");
  	    }
  	    $g->add_edge(@$e);
  	}
      }
  
      if (($gflags & _UNIONFIND)) {
  	$g->[ _U ] = Graph::UnionFind->new;
      }
  
      return $g;
  }
  
  sub countvertexed { $_[0]->[ _V ]->_is_COUNT }
  sub multivertexed { $_[0]->[ _V ]->_is_MULTI }
  sub hypervertexed { $_[0]->[ _V ]->_is_HYPER }
  sub omnivertexed  { $_[0]->[ _V ]->_is_UNORD }
  sub uniqvertexed  { $_[0]->[ _V ]->_is_UNIQ  }
  sub refvertexed   { $_[0]->[ _V ]->_is_REF   }
  sub refvertexed_stringified { $_[0]->[ _V ]->_is_REFSTR }
  sub __stringified { $_[0]->[ _V ]->_is_STR   }
  
  sub countedged    { $_[0]->[ _E ]->_is_COUNT }
  sub multiedged    { $_[0]->[ _E ]->_is_MULTI }
  sub hyperedged    { $_[0]->[ _E ]->_is_HYPER }
  sub omniedged     { $_[0]->[ _E ]->_is_UNORD }
  sub uniqedged     { $_[0]->[ _E ]->_is_UNIQ  }
  
  *undirected   = \&omniedged;
  *omnidirected = \&omniedged;
  sub directed { ! $_[0]->[ _E ]->_is_UNORD }
  
  *is_directed      = \&directed;
  *is_undirected    = \&undirected;
  
  *is_countvertexed = \&countvertexed;
  *is_multivertexed = \&multivertexed;
  *is_hypervertexed = \&hypervertexed;
  *is_omnidirected  = \&omnidirected;
  *is_uniqvertexed  = \&uniqvertexed;
  *is_refvertexed   = \&refvertexed;
  *is_refvertexed_stringified = \&refvertexed_stringified;
  
  *is_countedged    = \&countedged;
  *is_multiedged    = \&multiedged;
  *is_hyperedged    = \&hyperedged;
  *is_omniedged     = \&omniedged;
  *is_uniqedged     = \&uniqedged;
  
  sub _union_find_add_vertex {
      my ($g, $v) = @_;
      my $UF = $g->[ _U ];
      $UF->add( $g->[ _V ]->_get_path_id( $v ) );
  }
  
  sub add_vertex {
      my $g = shift;
      if ($g->is_multivertexed) {
  	return $g->add_vertex_by_id(@_, _GEN_ID);
      }
      my @r;
      if (@_ > 1) {
  	unless ($g->is_countvertexed || $g->is_hypervertexed) {
  	    require Carp;
  	    Carp::croak("Graph::add_vertex: use add_vertices for more than one vertex or use hypervertexed");
  	}
  	for my $v ( @_ ) {
  	    if (defined $v) {
  		$g->[ _V ]->set_path( $v ) unless $g->has_vertex( $v );
  	    } else {
  		require Carp;
  		Carp::croak("Graph::add_vertex: undef vertex");
  	    }
  	}
      }
      for my $v ( @_ ) {
  	unless (defined $v) {
  	    require Carp;
  	    Carp::croak("Graph::add_vertex: undef vertex");
  	}
      }
      $g->[ _V ]->set_path( @_ );
      $g->[ _G ]++;
      $g->_union_find_add_vertex( @_ ) if $g->has_union_find;
      return $g;
  }
  
  sub has_vertex {
      my $g = shift;
      my $V = $g->[ _V ];
      return exists $V->[ _s ]->{ $_[0] } if ($V->[ _f ] & _LIGHT);
      $V->has_path( @_ );
  }
  
  sub vertices05 {
      my $g = shift;
      my @v = $g->[ _V ]->paths( @_ );
      if (wantarray) {
  	return $g->[ _V ]->_is_HYPER ?
  	    @v : map { ref $_ eq 'ARRAY' ? @$_ : $_ } @v;
      } else {
  	return scalar @v;
      }
  }
  
  sub vertices {
      my $g = shift;
      my @v = $g->vertices05;
      if ($g->is_compat02) {
          wantarray ? sort @v : scalar @v;
      } else {
  	if ($g->is_multivertexed || $g->is_countvertexed) {
  	    if (wantarray) {
  		my @V;
  		for my $v ( @v ) {
  		    push @V, ($v) x $g->get_vertex_count($v);
  		}
  		return @V;
  	    } else {
  		my $V = 0;
  		for my $v ( @v ) {
  		    $V += $g->get_vertex_count($v);
  		}
  		return $V;
  	    }
  	} else {
  	    return @v;
  	}
      }
  }
  
  *vertices_unsorted = \&vertices_unsorted; # Graph 0.20103 compat.
  
  sub unique_vertices {
      my $g = shift;
      my @v = $g->vertices05;
      if ($g->is_compat02) {
          wantarray ? sort @v : scalar @v;
      } else {
  	return @v;
      }
  }
  
  sub has_vertices {
      my $g = shift;
      scalar $g->[ _V ]->has_paths( @_ );
  }
  
  sub _add_edge {
      my $g = shift;
      my $V = $g->[ _V ];
      my @e;
      if (($V->[ _f ]) & _LIGHT) {
  	for my $v ( @_ ) {
  	    $g->add_vertex( $v ) unless exists $V->[ _s ]->{ $v };
  	    push @e, $V->[ _s ]->{ $v };
  	}
      } else {
  	my $h = $g->[ _V ]->_is_HYPER;
  	for my $v ( @_ ) {
  	    my @v = ref $v eq 'ARRAY' && $h ? @$v : $v;
  	    $g->add_vertex( @v ) unless $V->has_path( @v );
  	    push @e, $V->_get_path_id( @v );
  	}
      }
      return @e;
  }
  
  sub _union_find_add_edge {
      my ($g, $u, $v) = @_;
      $g->[ _U ]->union($u, $v);
  }
  
  sub add_edge {
      my $g = shift;
      if ($g->is_multiedged) {
  	unless (@_ == 2 || $g->is_hyperedged) {
  	    require Carp;
  	    Carp::croak("Graph::add_edge: use add_edges for more than one edge");
  	}
  	return $g->add_edge_by_id(@_, _GEN_ID);
      }
      unless (@_ == 2) {
  	unless ($g->is_hyperedged) {
  	    require Carp;
  	    Carp::croak("Graph::add_edge: graph is not hyperedged");
  	}
      }
      my @e = $g->_add_edge( @_ );
      $g->[ _E ]->set_path( @e );
      $g->[ _G ]++;
      $g->_union_find_add_edge( @e ) if $g->has_union_find;
      return $g;
  }
  
  sub _vertex_ids {
      my $g = shift;
      my $V = $g->[ _V ];
      my @e;
      if (($V->[ _f ] & _LIGHT)) {
  	for my $v ( @_ ) {
  	    return () unless exists $V->[ _s ]->{ $v };
  	    push @e, $V->[ _s ]->{ $v };
  	}
      } else {
  	my $h = $g->[ _V ]->_is_HYPER;
  	for my $v ( @_ ) {
  	    my @v = ref $v eq 'ARRAY' && $h ? @$v : $v;
  	    return () unless $V->has_path( @v );
  	    push @e, $V->_get_path_id( @v );
  	}
      }
      return @e;
  }
  
  sub has_edge {
      my $g = shift;
      my $E = $g->[ _E ];
      my $V = $g->[ _V ];
      my @i;
      if (($V->[ _f ] & _LIGHT) && @_ == 2) {
  	return 0 unless
  	    exists $V->[ _s ]->{ $_[0] } &&
  	    exists $V->[ _s ]->{ $_[1] };
  	@i = @{ $V->[ _s ] }{ @_[ 0, 1 ] };
      } else {
  	@i = $g->_vertex_ids( @_ );
  	return 0 if @i == 0 && @_;
      }
      my $f = $E->[ _f ];
      if ($E->[ _a ] == 2 && @i == 2 && !($f & (_HYPER|_REF|_UNIQ))) { # Fast path.
  	@i = sort @i if ($f & _UNORD);
  	return exists $E->[ _s ]->{ $i[0] } &&
  	       exists $E->[ _s ]->{ $i[0] }->{ $i[1] } ? 1 : 0;
      } else {
  	return defined $E->_get_path_id( @i ) ? 1 : 0;
      }
  }
  
  sub edges05 {
      my $g = shift;
      my $V = $g->[ _V ];
      my @e = $g->[ _E ]->paths( @_ );
      wantarray ?
  	map { [ map { my @v = $V->_get_id_path($_);
  		      @v == 1 ? $v[0] : [ @v ] }
  		@$_ ] }
              @e : @e;
  }
  
  sub edges02 {
      my $g = shift;
      if (@_ && defined $_[0]) {
  	unless (defined $_[1]) {
  	    my @e = $g->edges_at($_[0]);
  	    wantarray ?
  		map { @$_ }
                      sort { $a->[0] cmp $b->[0] || $a->[1] cmp $b->[1] } @e
                  : @e;
  	} else {
  	    die "edges02: unimplemented option";
  	}
      } else {
  	my @e = map { ($_) x $g->get_edge_count(@$_) } $g->edges05( @_ );
  	wantarray ?
            map { @$_ }
                sort { $a->[0] cmp $b->[0] || $a->[1] cmp $b->[1] } @e
            : @e;
      }
  }
  
  sub unique_edges {
      my $g = shift;
      ($g->is_compat02) ? $g->edges02( @_ ) : $g->edges05( @_ );
  }
  
  sub edges {
      my $g = shift;
      if ($g->is_compat02) {
  	return $g->edges02( @_ );
      } else {
  	if ($g->is_multiedged || $g->is_countedged) {
  	    if (wantarray) {
  		my @E;
  		for my $e ( $g->edges05 ) {
  		    push @E, ($e) x $g->get_edge_count(@$e);
  		}
  		return @E;
  	    } else {
  		my $E = 0;
  		for my $e ( $g->edges05 ) {
  		    $E += $g->get_edge_count(@$e);
  		}
  		return $E;
  	    }
  	} else {
  	    return $g->edges05;
  	}
      }
  }
  
  sub has_edges {
      my $g = shift;
      scalar $g->[ _E ]->has_paths( @_ );
  }
  
  ###
  # by_id
  #
  
  sub add_vertex_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      $g->[ _V ]->set_path_by_multi_id( @_ );
      $g->[ _G ]++;
      $g->_union_find_add_vertex( @_ ) if $g->has_union_find;
      return $g;
  }
  
  sub add_vertex_get_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $id = $g->[ _V ]->set_path_by_multi_id( @_, _GEN_ID );
      $g->[ _G ]++;
      $g->_union_find_add_vertex( @_ ) if $g->has_union_find;
      return $id;
  }
  
  sub has_vertex_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      $g->[ _V ]->has_path_by_multi_id( @_ );
  }
  
  sub delete_vertex_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      $g->expect_non_unionfind;
      my $V = $g->[ _V ];
      return unless $V->has_path_by_multi_id( @_ );
      # TODO: what to about the edges at this vertex?
      # If the multiness of this vertex goes to zero, delete the edges?
      $V->del_path_by_multi_id( @_ );
      $g->[ _G ]++;
      return $g;
  }
  
  sub get_multivertex_ids {
      my $g = shift;
      $g->expect_multivertexed;
      $g->[ _V ]->get_multi_ids( @_ );
  }
  
  sub add_edge_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $id = pop;
      my @e = $g->_add_edge( @_ );
      $g->[ _E ]->set_path_by_multi_id( @e, $id );
      $g->[ _G ]++;
      $g->_union_find_add_edge( @e ) if $g->has_union_find;
      return $g;
  }
  
  sub add_edge_get_id {
      my $g = shift;
      $g->expect_multiedged;
      my @i = $g->_add_edge( @_ );
      my $id = $g->[ _E ]->set_path_by_multi_id( @i, _GEN_ID );
      $g->_union_find_add_edge( @i ) if $g->has_union_find;
      $g->[ _G ]++;
      return $id;
  }
  
  sub has_edge_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $id = pop;
      my @i = $g->_vertex_ids( @_ );
      return 0 if @i == 0 && @_;
      $g->[ _E ]->has_path_by_multi_id( @i, $id );
  }
  
  sub delete_edge_by_id {
      my $g = shift;
      $g->expect_multiedged;
      $g->expect_non_unionfind;
      my $V = $g->[ _E ];
      my $id = pop;
      my @i = $g->_vertex_ids( @_ );
      return unless $V->has_path_by_multi_id( @i, $id );
      $V->del_path_by_multi_id( @i, $id );
      $g->[ _G ]++;
      return $g;
  }
  
  sub get_multiedge_ids {
      my $g = shift;
      $g->expect_multiedged;
      my @id = $g->_vertex_ids( @_ );
      return unless @id;
      $g->[ _E ]->get_multi_ids( @id );
  }
  
  ###
  # Neighbourhood.
  #
  
  sub vertices_at {
      my $g = shift;
      my $V = $g->[ _V ];
      return @_ unless ($V->[ _f ] & _HYPER);
      my %v;
      my @i;
      for my $v ( @_ ) {
  	my $i = $V->_get_path_id( $v );
  	return unless defined $i;
  	push @i, ( $v{ $v } = $i );
      }
      my $Vi = $V->_ids;
      my @v;
      while (my ($i, $v) = each %{ $Vi }) {
  	my %i;
  	my $h = $V->[_f ] & _HYPER;
  	@i{ @i } = @i if @i; # @todo: nonuniq hyper vertices?
  	for my $u (ref $v eq 'ARRAY' && $h ? @$v : $v) {
  	    my $j = exists $v{ $u } ? $v{ $u } : ( $v{ $u } = $i );
  	    if (defined $j && exists $i{ $j }) {
  		delete $i{ $j };
  		unless (keys %i) {
  		    push @v, $v;
  		    last;
  		}
  	    }
  	}
      }
      return @v;
  }
  
  sub _edges_at {
      my $g = shift;
      my $V = $g->[ _V ];
      my $E = $g->[ _E ];
      my @e;
      my $en = 0;
      my %ev;
      my $h = $V->[_f ] & _HYPER;
      for my $v ( $h ? $g->vertices_at( @_ ) : @_ ) {
  	my $vi = $V->_get_path_id( ref $v eq 'ARRAY' && $h ? @$v : $v );
  	next unless defined $vi;
  	my $Ei = $E->_ids;
  	while (my ($ei, $ev) = each %{ $Ei }) {
  	    if (wantarray) {
  		for my $j (@$ev) {
  		    push @e, [ $ei, $ev ]
  			if $j == $vi && !$ev{$ei}++;
  		}
  	    } else {
  		for my $j (@$ev) {
  		    $en++ if $j == $vi;
  		}
  	    }		    
  	}
      }
      return wantarray ? @e : $en;
  }
  
  sub _edges {
      my $g = shift;
      my $n = pop;
      my $i = $n == _S ? 0 : -1;  # _edges_from() or _edges_to()
      my $V = $g->[ _V ];
      my $E = $g->[ _E ];
      my $N = $g->[ $n ];
      my $h = $V->[ _f ] & _HYPER;
      unless (defined $N && $N->[ 0 ] == $g->[ _G ]) {
  	$g->[ $n ]->[ 1 ] = { };
  	$N = $g->[ $n ];
  	my $u = $E->[ _f ] & _UNORD;
  	my $Ei = $E->_ids;
  	while (my ($ei, $ev) = each %{ $Ei }) {
  	    next unless @$ev;
  	    my $e = [ $ei, $ev ];
  	    if ($u) {
  		push @{ $N->[ 1 ]->{ $ev->[ 0] } }, $e;
  		push @{ $N->[ 1 ]->{ $ev->[-1] } }, $e;
  	    } else {
  		my $e = [ $ei, $ev ];
  		push @{ $N->[ 1 ]->{ $ev->[$i] } }, $e;
  	    }
  	}
  	$N->[ 0 ] = $g->[ _G ];
      }
      my @e;
      my @at = $h ? $g->vertices_at( @_ ) : @_;
      my %at; @at{@at} = ();
      for my $v ( @at ) {
  	my $vi = $V->_get_path_id( ref $v eq 'ARRAY' && $h ? @$v : $v );
  	next unless defined $vi && exists $N->[ 1 ]->{ $vi };
  	push @e, @{ $N->[ 1 ]->{ $vi } };
      }
      if (wantarray && $g->is_undirected) {
  	my @i = map { $V->_get_path_id( $_ ) } @_;
  	for my $e ( @e ) {
  	    unless ( $e->[ 1 ]->[ $i ] == $i[ $i ] ) {
  		$e = [ $e->[ 0 ], [ reverse @{ $e->[ 1 ] } ] ];
  	    }
  	}
      }
      return @e;
  }
  
  sub _edges_from {
      push @_, _S;
      goto &_edges;
  }
  
  sub _edges_to {
      push @_, _P;
      goto &_edges;
  }
  
  sub _edges_id_path {
      my $g = shift;
      my $V  = $g->[ _V ];
      [ map { my @v = $V->_get_id_path($_);
  	    @v == 1 ? $v[0] : [ @v ] }
            @{ $_[0]->[1] } ];
  }
  
  sub edges_at {
      my $g = shift;
      map { $g->_edges_id_path($_ ) } $g->_edges_at( @_ );
  }
  
  sub edges_from {
      my $g = shift;
      map { $g->_edges_id_path($_ ) } $g->_edges_from( @_ );
  }
  
  sub edges_to {
      my $g = shift;
      map { $g->_edges_id_path($_ ) } $g->_edges_to( @_ );
  }
  
  sub successors {
      my $g = shift;
      my $E = $g->[ _E ];
      ($E->[ _f ] & _LIGHT) ?
  	$E->_successors($g, @_) :
  	Graph::AdjacencyMap::_successors($E, $g, @_);
  }
  
  sub predecessors {
      my $g = shift;
      my $E = $g->[ _E ];
      ($E->[ _f ] & _LIGHT) ?
  	$E->_predecessors($g, @_) :
  	Graph::AdjacencyMap::_predecessors($E, $g, @_);
  }
  
  sub _all_successors {
      my $g = shift;
      my @init = @_;
      my %todo;
      @todo{@init} = @init;
      my %seen;
      my %init = %todo;
      my %self;
      while (keys %todo) {
        my @todo = values %todo;
        for my $t (@todo) {
  	$seen{$t} = delete $todo{$t};
  	for my $s ($g->successors($t)) {
  	  $self{$s} = $s if exists $init{$s};
  	  $todo{$s} = $s unless exists $seen{$s};
  	}
        }
      }
      for my $v (@init) {
        delete $seen{$v} unless $g->has_edge($v, $v) || $self{$v};
      }
      return values %seen;
  }
  
  sub all_successors {
      my $g = shift;
      $g->expect_directed;
      return $g->_all_successors(@_);
  }
  
  sub _all_predecessors {
      my $g = shift;
      my @init = @_;
      my %todo;
      @todo{@init} = @init;
      my %seen;
      my %init = %todo;
      my %self;
      while (keys %todo) {
        my @todo = values %todo;
        for my $t (@todo) {
  	$seen{$t} = delete $todo{$t};
  	for my $p ($g->predecessors($t)) {
  	  $self{$p} = $p if exists $init{$p};
  	  $todo{$p} = $p unless exists $seen{$p};
  	}
        }
      }
      for my $v (@init) {
        delete $seen{$v} unless $g->has_edge($v, $v) || $self{$v};
      }
      return values %seen;
  }
  
  sub all_predecessors {
      my $g = shift;
      $g->expect_directed;
      return $g->_all_predecessors(@_);
  }
  
  sub neighbours {
      my $g = shift;
      my $V  = $g->[ _V ];
      my @s = map { my @v = @{ $_->[ 1 ] }; shift @v; @v } $g->_edges_from( @_ );
      my @p = map { my @v = @{ $_->[ 1 ] }; pop   @v; @v } $g->_edges_to  ( @_ );
      my %n;
      @n{ @s } = @s;
      @n{ @p } = @p;
      map { $V->_get_id_path($_) } keys %n;
  }
  
  *neighbors = \&neighbours;
  
  sub all_neighbours {
      my $g = shift;
      my @init = @_;
      my @v = @init;
      my %n;
      my $o = 0;
      while (1) {
        my @p = $g->_all_predecessors(@v);
        my @s = $g->_all_successors(@v);
        @n{@p} = @p;
        @n{@s} = @s;
        @v = values %n;
        last if @v == $o;  # Leave if no growth.
        $o = @v;
      }
      for my $v (@init) {
        delete $n{$v} unless $g->has_edge($v, $v);
      }
      return values %n;
  }
  
  *all_neighbors = \&all_neighbours;
  
  sub all_reachable {
      my $g = shift;
      $g->directed ? $g->all_successors(@_) : $g->all_neighbors(@_);
  }
  
  sub delete_edge {
      my $g = shift;
      $g->expect_non_unionfind;
      my @i = $g->_vertex_ids( @_ );
      return $g unless @i;
      my $i = $g->[ _E ]->_get_path_id( @i );
      return $g unless defined $i;
      $g->[ _E ]->_del_id( $i );
      $g->[ _G ]++;
      return $g;
  }
  
  sub delete_vertex {
      my $g = shift;
      $g->expect_non_unionfind;
      my $V = $g->[ _V ];
      return $g unless $V->has_path( @_ );
      my $E = $g->[ _E ];
      for my $e ( $g->_edges_at( @_ ) ) {
  	$E->_del_id( $e->[ 0 ] );
      }
      $V->del_path( @_ );
      $g->[ _G ]++;
      return $g;
  }
  
  sub get_vertex_count {
      my $g = shift;
      $g->[ _V ]->_get_path_count( @_ ) || 0;
  }
  
  sub get_edge_count {
      my $g = shift;
      my @e = $g->_vertex_ids( @_ );
      return 0 unless @e;
      $g->[ _E ]->_get_path_count( @e ) || 0;
  }
  
  sub delete_vertices {
      my $g = shift;
      $g->expect_non_unionfind;
      while (@_) {
  	my $v = shift @_;
  	$g->delete_vertex($v);
      }
      return $g;
  }
  
  sub delete_edges {
      my $g = shift;
      $g->expect_non_unionfind;
      while (@_) {
  	my ($u, $v) = splice @_, 0, 2;
  	$g->delete_edge($u, $v);
      }
      return $g;
  }
  
  ###
  # Degrees.
  #
  
  sub _in_degree {
      my $g = shift;
      return undef unless @_ && $g->has_vertex( @_ );
      my $in = 0;
      $in += $g->get_edge_count( @$_ ) for $g->edges_to( @_ );
      return $in;
  }
  
  sub in_degree {
      my $g = shift;
      $g->_in_degree( @_ );
  }
  
  sub _out_degree {
      my $g = shift;
      return undef unless @_ && $g->has_vertex( @_ );
      my $out = 0;
      $out += $g->get_edge_count( @$_ ) for $g->edges_from( @_ );
      return $out;
  }
  
  sub out_degree {
      my $g = shift;
      $g->_out_degree( @_ );
  }
  
  sub _total_degree {
      my $g = shift;
      return undef unless @_ && $g->has_vertex( @_ );
      $g->is_undirected ?
  	$g->_in_degree( @_ ) :
  	$g-> in_degree( @_ ) - $g-> out_degree( @_ );
  }
  
  sub degree {
      my $g = shift;
      if (@_) {
  	$g->_total_degree( @_ );
      } elsif ($g->is_undirected) {
  	my $total = 0;
  	$total += $g->_total_degree( $_ ) for $g->vertices05;
  	return $total;
      } else {
  	return 0;
      }
  }
  
  *vertex_degree = \&degree;
  
  sub is_sink_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->successors( @_ ) == 0 && $g->predecessors( @_ ) > 0;
  }
  
  sub is_source_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->predecessors( @_ ) == 0 && $g->successors( @_ ) > 0;
  }
  
  sub is_successorless_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->successors( @_ ) == 0;
  }
  
  sub is_predecessorless_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->predecessors( @_ ) == 0;
  }
  
  sub is_successorful_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->successors( @_ ) > 0;
  }
  
  sub is_predecessorful_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->predecessors( @_ ) > 0;
  }
  
  sub is_isolated_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->predecessors( @_ ) == 0 && $g->successors( @_ ) == 0;
  }
  
  sub is_interior_vertex {
      my $g = shift;
      return 0 unless @_;
      my $p = $g->predecessors( @_ );
      my $s = $g->successors( @_ );
      if ($g->is_self_loop_vertex( @_ )) {
  	$p--;
  	$s--;
      }
      $p > 0 && $s > 0;
  }
  
  sub is_exterior_vertex {
      my $g = shift;
      return 0 unless @_;
      $g->predecessors( @_ ) == 0 || $g->successors( @_ ) == 0;
  }
  
  sub is_self_loop_vertex {
      my $g = shift;
      return 0 unless @_;
      for my $s ( $g->successors( @_ ) ) {
  	return 1 if $s eq $_[0]; # @todo: multiedges, hypervertices
      }
      return 0;
  }
  
  sub sink_vertices {
      my $g = shift;
      grep { $g->is_sink_vertex($_) } $g->vertices05;
  }
  
  sub source_vertices {
      my $g = shift;
      grep { $g->is_source_vertex($_) } $g->vertices05;
  }
  
  sub successorless_vertices {
      my $g = shift;
      grep { $g->is_successorless_vertex($_) } $g->vertices05;
  }
  
  sub predecessorless_vertices {
      my $g = shift;
      grep { $g->is_predecessorless_vertex($_) } $g->vertices05;
  }
  
  sub successorful_vertices {
      my $g = shift;
      grep { $g->is_successorful_vertex($_) } $g->vertices05;
  }
  
  sub predecessorful_vertices {
      my $g = shift;
      grep { $g->is_predecessorful_vertex($_) } $g->vertices05;
  }
  
  sub isolated_vertices {
      my $g = shift;
      grep { $g->is_isolated_vertex($_) } $g->vertices05;
  }
  
  sub interior_vertices {
      my $g = shift;
      grep { $g->is_interior_vertex($_) } $g->vertices05;
  }
  
  sub exterior_vertices {
      my $g = shift;
      grep { $g->is_exterior_vertex($_) } $g->vertices05;
  }
  
  sub self_loop_vertices {
      my $g = shift;
      grep { $g->is_self_loop_vertex($_) } $g->vertices05;
  }
  
  ###
  # Paths and cycles.
  #
  
  sub add_path {
      my $g = shift;
      my $u = shift;
      while (@_) {
  	my $v = shift;
  	$g->add_edge($u, $v);
  	$u = $v;
      }
      return $g;
  }
  
  sub delete_path {
      my $g = shift;
      $g->expect_non_unionfind;
      my $u = shift;
      while (@_) {
  	my $v = shift;
  	$g->delete_edge($u, $v);
  	$u = $v;
      }
      return $g;
  }
  
  sub has_path {
      my $g = shift;
      my $u = shift;
      while (@_) {
  	my $v = shift;
  	return 0 unless $g->has_edge($u, $v);
  	$u = $v;
      }
      return $g;
  }
  
  sub add_cycle {
      my $g = shift;
      $g->add_path(@_, $_[0]);
  }
  
  sub delete_cycle {
      my $g = shift;
      $g->expect_non_unionfind;
      $g->delete_path(@_, $_[0]);
  }
  
  sub has_cycle {
      my $g = shift;
      @_ ? ($g->has_path(@_, $_[0]) ? 1 : 0) : 0;
  }
  
  sub has_a_cycle {
      my $g = shift;
      my @r = ( back_edge => \&Graph::Traversal::has_a_cycle );
      push @r,
        down_edge => \&Graph::Traversal::has_a_cycle
         if $g->is_undirected;
      my $t = Graph::Traversal::DFS->new($g, @r, @_);
      $t->dfs;
      return $t->get_state('has_a_cycle');
  }
  
  sub find_a_cycle {
      my $g = shift;
      my @r = ( back_edge => \&Graph::Traversal::find_a_cycle);
      push @r,
        down_edge => \&Graph::Traversal::find_a_cycle
  	if $g->is_undirected;
      my $t = Graph::Traversal::DFS->new($g, @r, @_);
      $t->dfs;
      $t->has_state('a_cycle') ? @{ $t->get_state('a_cycle') } : ();
  }
  
  ###
  # Attributes.
  
  # Vertex attributes.
  
  sub set_vertex_attribute {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $value = pop;
      my $attr  = pop;
      $g->add_vertex( @_ ) unless $g->has_vertex( @_ );
      $g->[ _V ]->_set_path_attr( @_, $attr, $value );
  }
  
  sub set_vertex_attribute_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $value = pop;
      my $attr  = pop;
      $g->add_vertex_by_id( @_ ) unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_set_path_attr( @_, $attr, $value );
  }
  
  sub set_vertex_attributes {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $attr = pop;
      $g->add_vertex( @_ ) unless $g->has_vertex( @_ );
      $g->[ _V ]->_set_path_attrs( @_, $attr );
  }
  
  sub set_vertex_attributes_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $attr = pop;
      $g->add_vertex_by_id( @_ ) unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_set_path_attrs( @_, $attr );
  }
  
  sub has_vertex_attributes {
      my $g = shift;
      $g->expect_non_multivertexed;
      return 0 unless $g->has_vertex( @_ );
      $g->[ _V ]->_has_path_attrs( @_ );
  }
  
  sub has_vertex_attributes_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      return 0 unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_has_path_attrs( @_ );
  }
  
  sub has_vertex_attribute {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $attr = pop;
      return 0 unless $g->has_vertex( @_ );
      $g->[ _V ]->_has_path_attr( @_, $attr );
  }
  
  sub has_vertex_attribute_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $attr = pop;
      return 0 unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_has_path_attr( @_, $attr );
  }
  
  sub get_vertex_attributes {
      my $g = shift;
      $g->expect_non_multivertexed;
      return unless $g->has_vertex( @_ );
      my $a = $g->[ _V ]->_get_path_attrs( @_ );
      ($g->is_compat02) ? (defined $a ? %{ $a } : ()) : $a;
  }
  
  sub get_vertex_attributes_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      return unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_get_path_attrs( @_ );
  }
  
  sub get_vertex_attribute {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $attr = pop;
      return unless $g->has_vertex( @_ );
      $g->[ _V ]->_get_path_attr( @_, $attr );
  }
  
  sub get_vertex_attribute_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $attr = pop;
      return unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_get_path_attr( @_, $attr );
  }
  
  sub get_vertex_attribute_names {
      my $g = shift;
      $g->expect_non_multivertexed;
      return unless $g->has_vertex( @_ );
      $g->[ _V ]->_get_path_attr_names( @_ );
  }
  
  sub get_vertex_attribute_names_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      return unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_get_path_attr_names( @_ );
  }
  
  sub get_vertex_attribute_values {
      my $g = shift;
      $g->expect_non_multivertexed;
      return unless $g->has_vertex( @_ );
      $g->[ _V ]->_get_path_attr_values( @_ );
  }
  
  sub get_vertex_attribute_values_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      return unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_get_path_attr_values( @_ );
  }
  
  sub delete_vertex_attributes {
      my $g = shift;
      $g->expect_non_multivertexed;
      return undef unless $g->has_vertex( @_ );
      $g->[ _V ]->_del_path_attrs( @_ );
  }
  
  sub delete_vertex_attributes_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      return undef unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_del_path_attrs( @_ );
  }
  
  sub delete_vertex_attribute {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $attr = pop;
      return undef unless $g->has_vertex( @_ );
      $g->[ _V ]->_del_path_attr( @_, $attr );
  }
  
  sub delete_vertex_attribute_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $attr = pop;
      return undef unless $g->has_vertex_by_id( @_ );
      $g->[ _V ]->_del_path_attr( @_, $attr );
  }
  
  # Edge attributes.
  
  sub _set_edge_attribute {
      my $g = shift;
      my $value = pop;
      my $attr  = pop;
      my $E = $g->[ _E ];
      my $f = $E->[ _f ];
      my @i;
      if ($E->[ _a ] == 2 && @_ == 2 && !($f & (_HYPER|_REF|_UNIQ))) { # Fast path.
  	@_ = sort @_ if ($f & _UNORD);
  	my $s = $E->[ _s ];
  	$g->add_edge( @_ ) unless exists $s->{ $_[0] } && exists $s->{ $_[0] }->{ $_[1] };
  	@i = @{ $g->[ _V ]->[ _s ] }{ @_ };
      } else {
  	$g->add_edge( @_ ) unless $g->has_edge( @_ );
  	@i = $g->_vertex_ids( @_ );
      }
      $g->[ _E ]->_set_path_attr( @i, $attr, $value );
  }
  
  sub set_edge_attribute {
      my $g = shift;
      $g->expect_non_multiedged;
      my $value = pop;
      my $attr  = pop;
      my $E = $g->[ _E ];
      $g->add_edge( @_ ) unless $g->has_edge( @_ );
      $E->_set_path_attr( $g->_vertex_ids( @_ ), $attr, $value );
  }
  
  sub set_edge_attribute_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $value = pop;
      my $attr  = pop;
      # $g->add_edge_by_id( @_ ) unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_set_path_attr( $g->_vertex_ids( @_ ), $id, $attr, $value );
  }
  
  sub set_edge_attributes {
      my $g = shift;
      $g->expect_non_multiedged;
      my $attr = pop;
      $g->add_edge( @_ ) unless $g->has_edge( @_ );
      $g->[ _E ]->_set_path_attrs( $g->_vertex_ids( @_ ), $attr );
  }
  
  sub set_edge_attributes_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $attr = pop;
      $g->add_edge_by_id( @_ ) unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_set_path_attrs( $g->_vertex_ids( @_ ), $id, $attr );
  }
  
  sub has_edge_attributes {
      my $g = shift;
      $g->expect_non_multiedged;
      return 0 unless $g->has_edge( @_ );
      $g->[ _E ]->_has_path_attrs( $g->_vertex_ids( @_ ) );
  }
  
  sub has_edge_attributes_by_id {
      my $g = shift;
      $g->expect_multiedged;
      return 0 unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_has_path_attrs( $g->_vertex_ids( @_ ), $id );
  }
  
  sub has_edge_attribute {
      my $g = shift;
      $g->expect_non_multiedged;
      my $attr = pop;
      return 0 unless $g->has_edge( @_ );
      $g->[ _E ]->_has_path_attr( $g->_vertex_ids( @_ ), $attr );
  }
  
  sub has_edge_attribute_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $attr = pop;
      return 0 unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_has_path_attr( $g->_vertex_ids( @_ ), $id, $attr );
  }
  
  sub get_edge_attributes {
      my $g = shift;
      $g->expect_non_multiedged;
      return unless $g->has_edge( @_ );
      my $a = $g->[ _E ]->_get_path_attrs( $g->_vertex_ids( @_ ) );
      ($g->is_compat02) ? (defined $a ? %{ $a } : ()) : $a;
  }
  
  sub get_edge_attributes_by_id {
      my $g = shift;
      $g->expect_multiedged;
      return unless $g->has_edge_by_id( @_ );
      my $id = pop;
      return $g->[ _E ]->_get_path_attrs( $g->_vertex_ids( @_ ), $id );
  }
  
  sub _get_edge_attribute { # Fast path; less checks.
      my $g = shift;
      my $attr = pop;
      my $E = $g->[ _E ];
      my $f = $E->[ _f ];
      if ($E->[ _a ] == 2 && @_ == 2 && !($f & (_HYPER|_REF|_UNIQ))) { # Fast path.
  	@_ = sort @_ if ($f & _UNORD);
  	my $s = $E->[ _s ];
  	return unless exists $s->{ $_[0] } && exists $s->{ $_[0] }->{ $_[1] };
      } else {
  	return unless $g->has_edge( @_ );
      }
      my @i = $g->_vertex_ids( @_ );
      $E->_get_path_attr( @i, $attr );
  }
  
  sub get_edge_attribute {
      my $g = shift;
      $g->expect_non_multiedged;
      my $attr = pop;
      return undef unless $g->has_edge( @_ );
      my @i = $g->_vertex_ids( @_ );
      return undef if @i == 0 && @_;
      my $E = $g->[ _E ];
      $E->_get_path_attr( @i, $attr );
  }
  
  sub get_edge_attribute_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $attr = pop;
      return unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_get_path_attr( $g->_vertex_ids( @_ ), $id, $attr );
  }
  
  sub get_edge_attribute_names {
      my $g = shift;
      $g->expect_non_multiedged;
      return unless $g->has_edge( @_ );
      $g->[ _E ]->_get_path_attr_names( $g->_vertex_ids( @_ ) );
  }
  
  sub get_edge_attribute_names_by_id {
      my $g = shift;
      $g->expect_multiedged;
      return unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_get_path_attr_names( $g->_vertex_ids( @_ ), $id );
  }
  
  sub get_edge_attribute_values {
      my $g = shift;
      $g->expect_non_multiedged;
      return unless $g->has_edge( @_ );
      $g->[ _E ]->_get_path_attr_values( $g->_vertex_ids( @_ ) );
  }
  
  sub get_edge_attribute_values_by_id {
      my $g = shift;
      $g->expect_multiedged;
      return unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_get_path_attr_values( $g->_vertex_ids( @_ ), $id );
  }
  
  sub delete_edge_attributes {
      my $g = shift;
      $g->expect_non_multiedged;
      return unless $g->has_edge( @_ );
      $g->[ _E ]->_del_path_attrs( $g->_vertex_ids( @_ ) );
  }
  
  sub delete_edge_attributes_by_id {
      my $g = shift;
      $g->expect_multiedged;
      return unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_del_path_attrs( $g->_vertex_ids( @_ ), $id );
  }
  
  sub delete_edge_attribute {
      my $g = shift;
      $g->expect_non_multiedged;
      my $attr = pop;
      return unless $g->has_edge( @_ );
      $g->[ _E ]->_del_path_attr( $g->_vertex_ids( @_ ), $attr );
  }
  
  sub delete_edge_attribute_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $attr = pop;
      return unless $g->has_edge_by_id( @_ );
      my $id = pop;
      $g->[ _E ]->_del_path_attr( $g->_vertex_ids( @_ ), $id, $attr );
  }
  
  ###
  # Compat.
  #
  
  sub vertex {
      my $g = shift;
      $g->has_vertex( @_ ) ? @_ : undef;
  }
  
  sub out_edges {
      my $g = shift;
      return unless @_ && $g->has_vertex( @_ );
      my @e = $g->edges_from( @_ );
      wantarray ? map { @$_ } @e : @e;
  }
  
  sub in_edges {
      my $g = shift;
      return unless @_ && $g->has_vertex( @_ );
      my @e = $g->edges_to( @_ );
      wantarray ? map { @$_ } @e : @e;
  }
  
  sub add_vertices {
      my $g = shift;
      $g->add_vertex( $_ ) for @_;
      return $g;
  }
  
  sub add_edges {
      my $g = shift;
      while (@_) {
  	my $u = shift @_;
  	if (ref $u eq 'ARRAY') {
  	    $g->add_edge( @$u );
  	} else {
  	    if (@_) {
  		my $v = shift @_;
  		$g->add_edge( $u, $v );
  	    } else {
  		require Carp;
  		Carp::croak("Graph::add_edges: missing end vertex");
  	    }
  	}
      }
      return $g;
  }
  
  ###
  # More constructors.
  #
  
  sub copy {
      my $g = shift;
      my %opt = _get_options( \@_ );
  
      my $c =
  	(ref $g)->new(map { $_ => $g->$_ ? 1 : 0 }
  		      qw(directed
  			 compat02
  			 refvertexed
  			 hypervertexed
  			 countvertexed
  			 multivertexed
  			 hyperedged
  			 countedged
  			 multiedged
  			 omniedged
  		         __stringified));
      for my $v ($g->isolated_vertices) { $c->add_vertex($v) }
      for my $e ($g->edges05)           { $c->add_edge(@$e)  }
  
      return $c;
  }
  
  *copy_graph = \&copy;
  
  sub _deep_copy_Storable {
      my $g = shift;
      my $safe = new Safe;
      local $Storable::Deparse = 1;
      local $Storable::Eval = sub { $safe->reval($_[0]) };
      return Storable::thaw(Storable::freeze($g));
  }
  
  sub _deep_copy_DataDumper {
      my $g = shift;
      my $d = Data::Dumper->new([$g]);
      use vars qw($VAR1);
      $d->Purity(1)->Terse(1)->Deepcopy(1);
      $d->Deparse(1) if $] >= 5.008;
      eval $d->Dump;
  }
  
  sub deep_copy {
      if (_can_deep_copy_Storable()) {
  	return _deep_copy_Storable(@_);
      } else {
  	return _deep_copy_DataDumper(@_);
      }
  }
  
  *deep_copy_graph = \&deep_copy;
  
  sub transpose_edge {
      my $g = shift;
      if ($g->is_directed) {
  	return undef unless $g->has_edge( @_ );
  	my $c = $g->get_edge_count( @_ );
  	my $a = $g->get_edge_attributes( @_ );
  	my @e = reverse @_;
  	$g->delete_edge( @_ ) unless $g->has_edge( @e );
  	$g->add_edge( @e ) for 1..$c;
  	$g->set_edge_attributes(@e, $a) if $a;
      }
      return $g;
  }
  
  sub transpose_graph {
      my $g = shift;
      my $t = $g->copy;
      if ($t->directed) {
  	for my $e ($t->edges05) {
  	    $t->transpose_edge(@$e);
  	}
      }
      return $t;
  }
  
  *transpose = \&transpose_graph;
  
  sub complete_graph {
      my $g = shift;
      my $c = $g->new( directed => $g->directed );
      my @v = $g->vertices05;
      for (my $i = 0; $i <= $#v; $i++ ) {
  	for (my $j = 0; $j <= $#v; $j++ ) {
  	    next if $i >= $j;
  	    if ($g->is_undirected) {
  		$c->add_edge($v[$i], $v[$j]);
  	    } else {
  		$c->add_edge($v[$i], $v[$j]);
  		$c->add_edge($v[$j], $v[$i]);
  	    }
  	}
      }
      return $c;
  }
  
  *complement = \&complement_graph;
  
  sub complement_graph {
      my $g = shift;
      my $c = $g->new( directed => $g->directed );
      my @v = $g->vertices05;
      for (my $i = 0; $i <= $#v; $i++ ) {
  	for (my $j = 0; $j <= $#v; $j++ ) {
  	    next if $i >= $j;
  	    if ($g->is_undirected) {
  		$c->add_edge($v[$i], $v[$j])
  		    unless $g->has_edge($v[$i], $v[$j]);
  	    } else {
  		$c->add_edge($v[$i], $v[$j])
  		    unless $g->has_edge($v[$i], $v[$j]);
  		$c->add_edge($v[$j], $v[$i])
  		    unless $g->has_edge($v[$j], $v[$i]);
  	    }
  	}
      }
      return $c;
  }
  
  *complete = \&complete_graph;
  
  ###
  # Transitivity.
  #
  
  sub is_transitive {
      my $g = shift;
      Graph::TransitiveClosure::is_transitive($g);
  }
  
  ###
  # Weighted vertices.
  #
  
  my $defattr = 'weight';
  
  sub _defattr {
      return $defattr;
  }
  
  sub add_weighted_vertex {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $w = pop;
      $g->add_vertex(@_);
      $g->set_vertex_attribute(@_, $defattr, $w);
  }
  
  sub add_weighted_vertices {
      my $g = shift;
      $g->expect_non_multivertexed;
      while (@_) {
  	my ($v, $w) = splice @_, 0, 2;
  	$g->add_vertex($v);
  	$g->set_vertex_attribute($v, $defattr, $w);
      }
  }
  
  sub get_vertex_weight {
      my $g = shift;
      $g->expect_non_multivertexed;
      $g->get_vertex_attribute(@_, $defattr);
  }
  
  sub has_vertex_weight {
      my $g = shift;
      $g->expect_non_multivertexed;
      $g->has_vertex_attribute(@_, $defattr);
  }
  
  sub set_vertex_weight {
      my $g = shift;
      $g->expect_non_multivertexed;
      my $w = pop;
      $g->set_vertex_attribute(@_, $defattr, $w);
  }
  
  sub delete_vertex_weight {
      my $g = shift;
      $g->expect_non_multivertexed;
      $g->delete_vertex_attribute(@_, $defattr);
  }
  
  sub add_weighted_vertex_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $w = pop;
      $g->add_vertex_by_id(@_);
      $g->set_vertex_attribute_by_id(@_, $defattr, $w);
  }
  
  sub add_weighted_vertices_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $id = pop;
      while (@_) {
  	my ($v, $w) = splice @_, 0, 2;
  	$g->add_vertex_by_id($v, $id);
  	$g->set_vertex_attribute_by_id($v, $id, $defattr, $w);
      }
  }
  
  sub get_vertex_weight_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      $g->get_vertex_attribute_by_id(@_, $defattr);
  }
  
  sub has_vertex_weight_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      $g->has_vertex_attribute_by_id(@_, $defattr);
  }
  
  sub set_vertex_weight_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      my $w = pop;
      $g->set_vertex_attribute_by_id(@_, $defattr, $w);
  }
  
  sub delete_vertex_weight_by_id {
      my $g = shift;
      $g->expect_multivertexed;
      $g->delete_vertex_attribute_by_id(@_, $defattr);
  }
  
  ###
  # Weighted edges.
  #
  
  sub add_weighted_edge {
      my $g = shift;
      $g->expect_non_multiedged;
      if ($g->is_compat02) {
  	my $w = splice @_, 1, 1;
  	$g->add_edge(@_);
  	$g->set_edge_attribute(@_, $defattr, $w);
      } else {
  	my $w = pop;
  	$g->add_edge(@_);
  	$g->set_edge_attribute(@_, $defattr, $w);
      }
  }
  
  sub add_weighted_edges {
      my $g = shift;
      $g->expect_non_multiedged;
      if ($g->is_compat02) {
  	while (@_) {
  	    my ($u, $w, $v) = splice @_, 0, 3;
  	    $g->add_edge($u, $v);
  	    $g->set_edge_attribute($u, $v, $defattr, $w);
  	}
      } else {
  	while (@_) {
  	    my ($u, $v, $w) = splice @_, 0, 3;
  	    $g->add_edge($u, $v);
  	    $g->set_edge_attribute($u, $v, $defattr, $w);
  	}
      }
  }
  
  sub add_weighted_edges_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $id = pop;
      while (@_) {
  	my ($u, $v, $w) = splice @_, 0, 3;
  	$g->add_edge_by_id($u, $v, $id);
  	$g->set_edge_attribute_by_id($u, $v, $id, $defattr, $w);
      }
  }
  
  sub add_weighted_path {
      my $g = shift;
      $g->expect_non_multiedged;
      my $u = shift;
      while (@_) {
  	my ($w, $v) = splice @_, 0, 2;
  	$g->add_edge($u, $v);
  	$g->set_edge_attribute($u, $v, $defattr, $w);
  	$u = $v;
      }
  }
  
  sub get_edge_weight {
      my $g = shift;
      $g->expect_non_multiedged;
      $g->get_edge_attribute(@_, $defattr);
  }
  
  sub has_edge_weight {
      my $g = shift;
      $g->expect_non_multiedged;
      $g->has_edge_attribute(@_, $defattr);
  }
  
  sub set_edge_weight {
      my $g = shift;
      $g->expect_non_multiedged;
      my $w = pop;
      $g->set_edge_attribute(@_, $defattr, $w);
  }
  
  sub delete_edge_weight {
      my $g = shift;
      $g->expect_non_multiedged;
      $g->delete_edge_attribute(@_, $defattr);
  }
  
  sub add_weighted_edge_by_id {
      my $g = shift;
      $g->expect_multiedged;
      if ($g->is_compat02) {
  	my $w = splice @_, 1, 1;
  	$g->add_edge_by_id(@_);
  	$g->set_edge_attribute_by_id(@_, $defattr, $w);
      } else {
  	my $w = pop;
  	$g->add_edge_by_id(@_);
  	$g->set_edge_attribute_by_id(@_, $defattr, $w);
      }
  }
  
  sub add_weighted_path_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $id = pop;
      my $u = shift;
      while (@_) {
  	my ($w, $v) = splice @_, 0, 2;
  	$g->add_edge_by_id($u, $v, $id);
  	$g->set_edge_attribute_by_id($u, $v, $id, $defattr, $w);
  	$u = $v;
      }
  }
  
  sub get_edge_weight_by_id {
      my $g = shift;
      $g->expect_multiedged;
      $g->get_edge_attribute_by_id(@_, $defattr);
  }
  
  sub has_edge_weight_by_id {
      my $g = shift;
      $g->expect_multiedged;
      $g->has_edge_attribute_by_id(@_, $defattr);
  }
  
  sub set_edge_weight_by_id {
      my $g = shift;
      $g->expect_multiedged;
      my $w = pop;
      $g->set_edge_attribute_by_id(@_, $defattr, $w);
  }
  
  sub delete_edge_weight_by_id {
      my $g = shift;
      $g->expect_multiedged;
      $g->delete_edge_attribute_by_id(@_, $defattr);
  }
  
  ###
  # Error helpers.
  #
  
  my %expected;
  @expected{qw(directed undirected acyclic)} = qw(undirected directed cyclic);
  
  sub _expected {
      my $exp = shift;
      my $got = @_ ? shift : $expected{$exp};
      $got = defined $got ? ", got $got" : "";
      if (my @caller2 = caller(2)) {
  	die "$caller2[3]: expected $exp graph$got, at $caller2[1] line $caller2[2].\n";
      } else {
  	my @caller1 = caller(1);
  	die "$caller1[3]: expected $exp graph$got, at $caller1[1] line $caller1[2].\n";
      }
  }
  
  sub expect_undirected {
      my $g = shift;
      _expected('undirected') unless $g->is_undirected;
  }
  
  sub expect_directed {
      my $g = shift;
      _expected('directed') unless $g->is_directed;
  }
  
  sub expect_acyclic {
      my $g = shift;
      _expected('acyclic') unless $g->is_acyclic;
  }
  
  sub expect_dag {
      my $g = shift;
      my @got;
      push @got, 'undirected' unless $g->is_directed;
      push @got, 'cyclic'     unless $g->is_acyclic;
      _expected('directed acyclic', "@got") if @got;
  }
  
  sub expect_multivertexed {
      my $g = shift;
      _expected('multivertexed') unless $g->is_multivertexed;
  }
  
  sub expect_non_multivertexed {
      my $g = shift;
      _expected('non-multivertexed') if $g->is_multivertexed;
  }
  
  sub expect_non_multiedged {
      my $g = shift;
      _expected('non-multiedged') if $g->is_multiedged;
  }
  
  sub expect_multiedged {
      my $g = shift;
      _expected('multiedged') unless $g->is_multiedged;
  }
  
  sub expect_non_unionfind {
      my $g = shift;
      _expected('non-unionfind') if $g->has_union_find;
  }
  
  sub _get_options {
      my @caller = caller(1);
      unless (@_ == 1 && ref $_[0] eq 'ARRAY') {
  	die "$caller[3]: internal error: should be called with only one array ref argument, at $caller[1] line $caller[2].\n";
      }
      my @opt = @{ $_[0] };
      unless (@opt  % 2 == 0) {
  	die "$caller[3]: expected an options hash, got a non-even number of arguments, at $caller[1] line $caller[2].\n";
      }
      return @opt;
  }
  
  ###
  # Random constructors and accessors.
  #
  
  sub __fisher_yates_shuffle (@) {
      # From perlfaq4, but modified to be non-modifying.
      my @a = @_;
      my $i = @a;
      while ($i--) {
  	my $j = int rand ($i+1);
  	@a[$i,$j] = @a[$j,$i];
      }
      return @a;
  }
  
  BEGIN {
      sub _shuffle(@);
      # Workaround for the Perl bug [perl #32383] where -d:Dprof and
      # List::Util::shuffle do not like each other: if any debugging
      # (-d) flags are on, fall back to our own Fisher-Yates shuffle.
      # The bug was fixed by perl changes #26054 and #26062, which
      # went to Perl 5.9.3.  If someone tests this with a pre-5.9.3
      # bleadperl that calls itself 5.9.3 but doesn't yet have the
      # patches, oh, well.
      *_shuffle = $^P && $] < 5.009003 ?
  	\&__fisher_yates_shuffle : \&List::Util::shuffle;
  }
  
  sub random_graph {
      my $class = (@_ % 2) == 0 ? 'Graph' : shift;
      my %opt = _get_options( \@_ );
      my $random_edge;
      unless (exists $opt{vertices} && defined $opt{vertices}) {
  	require Carp;
  	Carp::croak("Graph::random_graph: argument 'vertices' missing or undef");
      }
      if (exists $opt{random_seed}) {
  	srand($opt{random_seed});
  	delete $opt{random_seed};
      }
      if (exists $opt{random_edge}) {
  	$random_edge = $opt{random_edge};
  	delete $opt{random_edge};
      }
      my @V;
      if (my $ref = ref $opt{vertices}) {
  	if ($ref eq 'ARRAY') {
  	    @V = @{ $opt{vertices} };
  	} else {
  	    Carp::croak("Graph::random_graph: argument 'vertices' illegal");
  	}
      } else {
  	@V = 0..($opt{vertices} - 1);
      }
      delete $opt{vertices};
      my $V = @V;
      my $C = $V * ($V - 1) / 2;
      my $E;
      if (exists $opt{edges} && exists $opt{edges_fill}) {
  	Carp::croak("Graph::random_graph: both arguments 'edges' and 'edges_fill' specified");
      }
      $E = exists $opt{edges_fill} ? $opt{edges_fill} * $C : $opt{edges};
      delete $opt{edges};
      delete $opt{edges_fill};
      my $g = $class->new(%opt);
      $g->add_vertices(@V);
      return $g if $V < 2;
      $C *= 2 if $g->directed;
      $E = $C / 2 unless defined $E;
      $E = int($E + 0.5);
      my $p = $E / $C;
      $random_edge = sub { $p } unless defined $random_edge;
      # print "V = $V, E = $E, C = $C, p = $p\n";
      if ($p > 1.0 && !($g->countedged || $g->multiedged)) {
  	require Carp;
  	Carp::croak("Graph::random_graph: needs to be countedged or multiedged ($E > $C)");
      }
      my @V1 = @V;
      my @V2 = @V;
      # Shuffle the vertex lists so that the pairs at
      # the beginning of the lists are not more likely.
      @V1 = _shuffle @V1;
      @V2 = _shuffle @V2;
   LOOP:
      while ($E) {
  	for my $v1 (@V1) {
  	    for my $v2 (@V2) {
  		next if $v1 eq $v2; # TODO: allow self-loops?
  		my $q = $random_edge->($g, $v1, $v2, $p);
  		if ($q && ($q == 1 || rand() <= $q) &&
  		    !$g->has_edge($v1, $v2)) {
  		    $g->add_edge($v1, $v2);
  		    $E--;
  		    last LOOP unless $E;
  		}
  	    }
  	}
      }
      return $g;
  }
  
  sub random_vertex {
      my $g = shift;
      my @V = $g->vertices05;
      @V[rand @V];
  }
  
  sub random_edge {
      my $g = shift;
      my @E = $g->edges05;
      @E[rand @E];
  }
  
  sub random_successor {
      my ($g, $v) = @_;
      my @S = $g->successors($v);
      @S[rand @S];
  }
  
  sub random_predecessor {
      my ($g, $v) = @_;
      my @P = $g->predecessors($v);
      @P[rand @P];
  }
  
  ###
  # Algorithms.
  #
  
  my $MST_comparator = sub { ($_[0] || 0) <=> ($_[1] || 0) };
  
  sub _MST_attr {
      my $attr = shift;
      my $attribute =
  	exists $attr->{attribute}  ?
  	    $attr->{attribute}  : $defattr;
      my $comparator =
  	exists $attr->{comparator} ?
  	    $attr->{comparator} : $MST_comparator;
      return ($attribute, $comparator);
  }
  
  sub _MST_edges {
      my ($g, $attr) = @_;
      my ($attribute, $comparator) = _MST_attr($attr);
      map { $_->[1] }
          sort { $comparator->($a->[0], $b->[0], $a->[1], $b->[1]) }
               map { [ $g->get_edge_attribute(@$_, $attribute), $_ ] }
                   $g->edges05;
  }
  
  sub MST_Kruskal {
      my ($g, %attr) = @_;
  
      $g->expect_undirected;
  
      my $MST = Graph::Undirected->new;
  
      my $UF  = Graph::UnionFind->new;
      for my $v ($g->vertices05) { $UF->add($v) }
  
      for my $e ($g->_MST_edges(\%attr)) {
  	my ($u, $v) = @$e; # TODO: hyperedges
  	my $t0 = $UF->find( $u );
  	my $t1 = $UF->find( $v );
  	unless ($t0 eq $t1) {
  	    $UF->union($u, $v);
  	    $MST->add_edge($u, $v);
  	}
      }
  
      return $MST;
  }
  
  sub _MST_add {
      my ($g, $h, $HF, $r, $attr, $unseen) = @_;
      for my $s ( grep { exists $unseen->{ $_ } } $g->successors( $r ) ) {
  	$HF->add( Graph::MSTHeapElem->new( $r, $s, $g->get_edge_attribute( $r, $s, $attr ) ) );
      }
  }
  
  sub _next_alphabetic { shift; (sort               keys %{ $_[0] })[0] }
  sub _next_numeric    { shift; (sort { $a <=> $b } keys %{ $_[0] })[0] }
  sub _next_random     { shift; (values %{ $_[0] })[ rand keys %{ $_[0] } ] }
  
  sub _root_opt {
      my $g = shift;
      my %opt = @_ == 1 ? ( first_root => $_[0] ) : _get_options( \@_ );
      my %unseen;
      my @unseen = $g->vertices05;
      @unseen{ @unseen } = @unseen;
      @unseen = _shuffle @unseen;
      my $r;
      if (exists $opt{ start }) {
  	$opt{ first_root } = $opt{ start };
  	$opt{ next_root  } = undef;
      }
      if (exists $opt{ get_next_root }) {
  	$opt{ next_root  } = $opt{ get_next_root }; # Graph 0.201 compat.
      }
      if (exists $opt{ first_root }) {
  	if (ref $opt{ first_root } eq 'CODE') {
  	    $r = $opt{ first_root }->( $g, \%unseen );
  	} else {
  	    $r = $opt{ first_root };
  	}
      } else {
  	$r = shift @unseen;
      }
      my $next =
  	exists $opt{ next_root } ?
  	    $opt{ next_root } :
  		$opt{ next_alphabetic } ?
  		    \&_next_alphabetic :
  			$opt{ next_numeric } ? \&_next_numeric :
  			    \&_next_random;
      my $code = ref $next eq 'CODE';
      my $attr = exists $opt{ attribute } ? $opt{ attribute } : $defattr;
      return ( \%opt, \%unseen, \@unseen, $r, $next, $code, $attr );
  }
  
  sub _heap_walk {
      my ($g, $h, $add, $etc) = splice @_, 0, 4; # Leave %opt in @_.
  
      my ($opt, $unseenh, $unseena, $r, $next, $code, $attr) = $g->_root_opt(@_);
      my $HF = Heap071::Fibonacci->new;
  
      while (defined $r) {
  	# print "r = $r\n";
  	$add->($g, $h, $HF, $r, $attr, $unseenh, $etc);
  	delete $unseenh->{ $r };
  	while (defined $HF->top) {
  	    my $t = $HF->extract_top;
  	    # use Data::Dumper; print "t = ", Dumper($t);
  	    if (defined $t) {
  		my ($u, $v, $w) = $t->val;
  		# print "extracted top: $u $v $w\n";
  		if (exists $unseenh->{ $v }) {
  		    $h->set_edge_attribute($u, $v, $attr, $w);
  		    delete $unseenh->{ $v };
  		    $add->($g, $h, $HF, $v, $attr, $unseenh, $etc);
  		}
  	    }
  	}
  	return $h unless defined $next;
  	$r = $code ? $next->( $g, $unseenh ) : shift @$unseena;
      }
  
      return $h;
  }
  
  sub MST_Prim {
      my $g = shift;
      $g->expect_undirected;
      $g->_heap_walk(Graph::Undirected->new(), \&_MST_add, undef, @_);
  }
  
  *MST_Dijkstra = \&MST_Prim;
  
  *minimum_spanning_tree = \&MST_Prim;
  
  ###
  # Cycle detection.
  #
  
  *is_cyclic = \&has_a_cycle;
  
  sub is_acyclic {
      my $g = shift;
      return !$g->is_cyclic;
  }
  
  sub is_dag {
      my $g = shift;
      return $g->is_directed && $g->is_acyclic ? 1 : 0;
  }
  
  *is_directed_acyclic_graph = \&is_dag;
  
  ###
  # Backward compat.
  #
  
  sub average_degree {
      my $g = shift;
      my $V = $g->vertices05;
  
      return $V ? $g->degree / $V : 0;
  }
  
  sub density_limits {
      my $g = shift;
  
      my $V = $g->vertices05;
      my $M = $V * ($V - 1);
  
      $M /= 2 if $g->is_undirected;
  
      return ( 0.25 * $M, 0.75 * $M, $M );
  }
  
  sub density {
      my $g = shift;
      my ($sparse, $dense, $complete) = $g->density_limits;
  
      return $complete ? $g->edges / $complete : 0;
  }
  
  ###
  # Attribute backward compat
  #
  
  sub _attr02_012 {
      my ($g, $op, $ga, $va, $ea) = splice @_, 0, 5;
      if ($g->is_compat02) {
  	if    (@_ == 0) { return $ga->( $g ) }
  	elsif (@_ == 1) { return $va->( $g, @_ ) }
  	elsif (@_ == 2) { return $ea->( $g, @_ ) }
  	else {
  	    die sprintf "$op: wrong number of arguments (%d)", scalar @_;
  	}
      } else {
  	die "$op: not a compat02 graph"
      }
  }
  
  sub _attr02_123 {
      my ($g, $op, $ga, $va, $ea) = splice @_, 0, 5;
      if ($g->is_compat02) {
  	if    (@_ == 1) { return $ga->( $g, @_ ) }
  	elsif (@_ == 2) { return $va->( $g, @_[1, 0] ) }
  	elsif (@_ == 3) { return $ea->( $g, @_[1, 2, 0] ) }
  	else {
  	    die sprintf "$op: wrong number of arguments (%d)", scalar @_;
  	}
      } else {
  	die "$op: not a compat02 graph"
      }
  }
  
  sub _attr02_234 {
      my ($g, $op, $ga, $va, $ea) = splice @_, 0, 5;
      if ($g->is_compat02) {
  	if    (@_ == 2) { return $ga->( $g, @_ ) }
  	elsif (@_ == 3) { return $va->( $g, @_[1, 0, 2] ) }
  	elsif (@_ == 4) { return $ea->( $g, @_[1, 2, 0, 3] ) }
  	else {
  	    die sprintf "$op: wrong number of arguments (%d)", scalar @_;
  	}
      } else {
  	die "$op: not a compat02 graph";
      }
  }
  
  sub set_attribute {
      my $g = shift;
      $g->_attr02_234('set_attribute',
  		    \&Graph::set_graph_attribute,
  		    \&Graph::set_vertex_attribute,
  		    \&Graph::set_edge_attribute,
  		    @_);
  
  }
  
  sub set_attributes {
      my $g = shift;
      my $a = pop;
      $g->_attr02_123('set_attributes',
  		    \&Graph::set_graph_attributes,
  		    \&Graph::set_vertex_attributes,
  		    \&Graph::set_edge_attributes,
  		    $a, @_);
  
  }
  
  sub get_attribute {
      my $g = shift;
      $g->_attr02_123('get_attribute',
  		    \&Graph::get_graph_attribute,
  		    \&Graph::get_vertex_attribute,
  		    \&Graph::get_edge_attribute,
  		    @_);
  
  }
  
  sub get_attributes {
      my $g = shift;
      $g->_attr02_012('get_attributes',
  		    \&Graph::get_graph_attributes,
  		    \&Graph::get_vertex_attributes,
  		    \&Graph::get_edge_attributes,
  		    @_);
  
  }
  
  sub has_attribute {
      my $g = shift;
      return 0 unless @_;
      $g->_attr02_123('has_attribute',
  		    \&Graph::has_graph_attribute,
  		    \&Graph::has_vertex_attribute,
  		    \&Graph::get_edge_attribute,
  		    @_);
  
  }
  
  sub has_attributes {
      my $g = shift;
      $g->_attr02_012('has_attributes',
  		    \&Graph::has_graph_attributes,
  		    \&Graph::has_vertex_attributes,
  		    \&Graph::has_edge_attributes,
  		    @_);
  
  }
  
  sub delete_attribute {
      my $g = shift;
      $g->_attr02_123('delete_attribute',
  		    \&Graph::delete_graph_attribute,
  		    \&Graph::delete_vertex_attribute,
  		    \&Graph::delete_edge_attribute,
  		    @_);
  
  }
  
  sub delete_attributes {
      my $g = shift;
      $g->_attr02_012('delete_attributes',
  		    \&Graph::delete_graph_attributes,
  		    \&Graph::delete_vertex_attributes,
  		    \&Graph::delete_edge_attributes,
  		    @_);
  
  }
  
  ###
  # Simple DFS uses.
  #
  
  sub topological_sort {
      my $g = shift;
      my %opt = _get_options( \@_ );
      my $eic = $opt{ empty_if_cyclic };
      my $hac;
      if ($eic) {
  	$hac = $g->has_a_cycle;
      } else {
  	$g->expect_dag;
      }
      delete $opt{ empty_if_cyclic };
      my $t = Graph::Traversal::DFS->new($g, %opt);
      my @s = $t->dfs;
      $hac ? () : reverse @s;
  }
  
  *toposort = \&topological_sort;
  
  sub _undirected_copy_compute {
    my $g = shift;
    my $c = Graph::Undirected->new;
    for my $v ($g->isolated_vertices) { # TODO: if iv ...
      $c->add_vertex($v);
    }
    for my $e ($g->edges05) {
      $c->add_edge(@$e);
    }
    return $c;
  }
  
  sub undirected_copy {
      my $g = shift;
      $g->expect_directed;
      return _check_cache($g, 'undirected', \&_undirected_copy_compute);
  }
  
  *undirected_copy_graph = \&undirected_copy;
  
  sub directed_copy {
      my $g = shift;
      $g->expect_undirected;
      my $c = Graph::Directed->new;
      for my $v ($g->isolated_vertices) { # TODO: if iv ...
  	$c->add_vertex($v);
      }
      for my $e ($g->edges05) {
  	my @e = @$e;
  	$c->add_edge(@e);
  	$c->add_edge(reverse @e);
      }
      return $c;
  }
  
  *directed_copy_graph = \&directed_copy;
  
  ###
  # Cache or not.
  #
  
  my %_cache_type =
      (
       'connectivity'        => '_ccc',
       'strong_connectivity' => '_scc',
       'biconnectivity'      => '_bcc',
       'SPT_Dijkstra'        => '_spt_di',
       'SPT_Bellman_Ford'    => '_spt_bf',
       'undirected'          => '_undirected',
      );
  
  sub _check_cache {
      my ($g, $type, $code) = splice @_, 0, 3;
      my $c = $_cache_type{$type};
      if (defined $c) {
  	my $a = $g->get_graph_attribute($c);
  	unless (defined $a && $a->[ 0 ] == $g->[ _G ]) {
  	    $a->[ 0 ] = $g->[ _G ];
  	    $a->[ 1 ] = $code->( $g, @_ );
  	    $g->set_graph_attribute($c, $a);
  	}
  	return $a->[ 1 ];
      } else {
  	Carp::croak("Graph: unknown cache type '$type'");
      }
  }
  
  sub _clear_cache {
      my ($g, $type) = @_;
      my $c = $_cache_type{$type};
      if (defined $c) {
  	$g->delete_graph_attribute($c);
      } else {
  	Carp::croak("Graph: unknown cache type '$type'");
      }
  }
  
  sub connectivity_clear_cache {
      my $g = shift;
      _clear_cache($g, 'connectivity');
  }
  
  sub strong_connectivity_clear_cache {
      my $g = shift;
      _clear_cache($g, 'strong_connectivity');
  }
  
  sub biconnectivity_clear_cache {
      my $g = shift;
      _clear_cache($g, 'biconnectivity');
  }
  
  sub SPT_Dijkstra_clear_cache {
      my $g = shift;
      _clear_cache($g, 'SPT_Dijkstra');
      $g->delete_graph_attribute('SPT_Dijkstra_first_root');
  }
  
  sub SPT_Bellman_Ford_clear_cache {
      my $g = shift;
      _clear_cache($g, 'SPT_Bellman_Ford');
  }
  
  sub undirected_copy_clear_cache {
      my $g = shift;
      _clear_cache($g, 'undirected_copy');
  }
  
  ###
  # Connected components.
  #
  
  sub _connected_components_compute {
      my $g = shift;
      my %cce;
      my %cci;
      my $cc = 0;
      if ($g->has_union_find) {
  	my $UF = $g->_get_union_find();
  	my $V  = $g->[ _V ];
  	my %icce; # Isolated vertices.
  	my %icci;
  	my $icc = 0;
  	for my $v ( $g->unique_vertices ) {
  	    $cc = $UF->find( $V->_get_path_id( $v ) );
  	    if (defined $cc) {
  		$cce{ $v } = $cc;
  		push @{ $cci{ $cc } }, $v;
  	    } else {
  		$icce{ $v } = $icc;
  		push @{ $icci{ $icc } }, $v;
  		$icc++;
  	    }
  	}
  	if ($icc) {
  	    @cce{ keys %icce } = values %icce;
  	    @cci{ keys %icci } = values %icci;
  	}
      } else {
  	my @u = $g->unique_vertices;
  	my %r; @r{ @u } = @u;
  	my $froot = sub {
  	    (each %r)[1];
  	};
  	my $nroot = sub {
  	    $cc++ if keys %r;
  	    (each %r)[1];
  	};
  	my $t = Graph::Traversal::DFS->new($g,
  					   first_root => $froot,
  					   next_root  => $nroot,
  					   pre => sub {
  					       my ($v, $t) = @_;
  					       $cce{ $v } = $cc;
  					       push @{ $cci{ $cc } }, $v;
  					       delete $r{ $v };
  					   },
  					   @_);
  	$t->dfs;
      }
      return [ \%cce, \%cci ];
  }
  
  sub _connected_components {
      my $g = shift;
      my $ccc = _check_cache($g, 'connectivity',
  			   \&_connected_components_compute, @_);
      return @{ $ccc };
  }
  
  sub connected_component_by_vertex {
      my ($g, $v) = @_;
      $g->expect_undirected;
      my ($CCE, $CCI) = $g->_connected_components();
      return $CCE->{ $v };
  }
  
  sub connected_component_by_index {
      my ($g, $i) = @_;
      $g->expect_undirected;
      my ($CCE, $CCI) = $g->_connected_components();
      return defined $CCI->{ $i } ? @{ $CCI->{ $i } } : ( );
  }
  
  sub connected_components {
      my $g = shift;
      $g->expect_undirected;
      my ($CCE, $CCI) = $g->_connected_components();
      return values %{ $CCI };
  }
  
  sub same_connected_components {
      my $g = shift;
      $g->expect_undirected;
      if ($g->has_union_find) {
  	my $UF = $g->_get_union_find();
  	my $V  = $g->[ _V ];
  	my $u = shift;
  	my $c = $UF->find( $V->_get_path_id ( $u ) );
  	my $d;
  	for my $v ( @_) {
  	    return 0
  		unless defined($d = $UF->find( $V->_get_path_id( $v ) )) &&
  		       $d eq $c;
  	}
  	return 1;
      } else {
  	my ($CCE, $CCI) = $g->_connected_components();
  	my $u = shift;
  	my $c = $CCE->{ $u };
  	for my $v ( @_ ) {
  	    return 0
  		unless defined $CCE->{ $v } &&
  		       $CCE->{ $v } eq $c;
  	}
  	return 1;
      }
  }
  
  my $super_component = sub { join("+", sort @_) };
  
  sub connected_graph {
      my ($g, %opt) = @_;
      $g->expect_undirected;
      my $cg = Graph->new(undirected => 1);
      if ($g->has_union_find && $g->vertices == 1) {
  	# TODO: super_component?
  	$cg->add_vertices($g->vertices);
      } else {
  	my $sc_cb =
  	    exists $opt{super_component} ?
  		$opt{super_component} : $super_component;
  	for my $cc ( $g->connected_components() ) {
  	    my $sc = $sc_cb->(@$cc);
  	    $cg->add_vertex($sc);
  	    $cg->set_vertex_attribute($sc, 'subvertices', [ @$cc ]);
  	}
      }
      return $cg;
  }
  
  sub is_connected {
      my $g = shift;
      $g->expect_undirected;
      my ($CCE, $CCI) = $g->_connected_components();
      return keys %{ $CCI } == 1;
  }
  
  sub is_weakly_connected {
      my $g = shift;
      $g->expect_directed;
      $g->undirected_copy->is_connected(@_);
  }
  
  *weakly_connected = \&is_weakly_connected;
  
  sub weakly_connected_components {
      my $g = shift;
      $g->expect_directed;
      $g->undirected_copy->connected_components(@_);
  }
  
  sub weakly_connected_component_by_vertex {
      my $g = shift;
      $g->expect_directed;
      $g->undirected_copy->connected_component_by_vertex(@_);
  }
  
  sub weakly_connected_component_by_index {
      my $g = shift;
      $g->expect_directed;
      $g->undirected_copy->connected_component_by_index(@_);
  }
  
  sub same_weakly_connected_components {
      my $g = shift;
      $g->expect_directed;
      $g->undirected_copy->same_connected_components(@_);
  }
  
  sub weakly_connected_graph {
      my $g = shift;
      $g->expect_directed;
      $g->undirected_copy->connected_graph(@_);
  }
  
  sub _strongly_connected_components_compute {
      my $g = shift;
      my $t = Graph::Traversal::DFS->new($g);
      my @d = reverse $t->dfs;
      my @c;
      my $h = $g->transpose_graph;
      my $u =
  	Graph::Traversal::DFS->new($h,
  				   next_root => sub {
  				       my ($t, $u) = @_;
  				       my $root;
  				       while (defined($root = shift @d)) {
  					   last if exists $u->{ $root };
  				       }
  				       if (defined $root) {
  					   push @c, [];
  					   return $root;
  				       } else {
  					   return;
  				       }
  				   },
  				   pre => sub {
  				       my ($v, $t) = @_;
  				       push @{ $c[-1] }, $v;
  				   },
  				   @_);
      $u->dfs;
      return \@c;
  }
  
  sub _strongly_connected_components {
      my $g = shift;
      my $type = 'strong_connectivity';
      my $scc = _check_cache($g, $type,
  			   \&_strongly_connected_components_compute, @_);
      return defined $scc ? @$scc : ( );
  }
  
  sub strongly_connected_components {
      my $g = shift;
      $g->expect_directed;
      $g->_strongly_connected_components(@_);
  }
  
  sub strongly_connected_component_by_vertex {
      my $g = shift;
      my $v = shift;
      $g->expect_directed;
      my @scc = $g->_strongly_connected_components( next_alphabetic => 1, @_ );
      for (my $i = 0; $i <= $#scc; $i++) {
  	for (my $j = 0; $j <= $#{ $scc[$i] }; $j++) {
  	    return $i if $scc[$i]->[$j] eq $v;
  	}
      }
      return;
  }
  
  sub strongly_connected_component_by_index {
      my $g = shift;
      my $i = shift;
      $g->expect_directed;
      my $c = ( $g->_strongly_connected_components(@_) )[ $i ];
      return defined $c ? @{ $c } : ();
  }
  
  sub same_strongly_connected_components {
      my $g = shift;
      $g->expect_directed;
      my @scc = $g->_strongly_connected_components( next_alphabetic => 1, @_ );
      my @i;
      while (@_) {
  	my $v = shift;
  	for (my $i = 0; $i <= $#scc; $i++) {
  	    for (my $j = 0; $j <= $#{ $scc[$i] }; $j++) {
  		if ($scc[$i]->[$j] eq $v) {
  		    push @i, $i;
  		    return 0 if @i > 1 && $i[-1] ne $i[0];
  		}
  	    }
  	}
      }
      return 1;
  }
  
  sub is_strongly_connected {
      my $g = shift;
      $g->expect_directed;
      my $t = Graph::Traversal::DFS->new($g);
      my @d = reverse $t->dfs;
      my @c;
      my $h = $g->transpose;
      my $u =
  	Graph::Traversal::DFS->new($h,
  				   next_root => sub {
  				       my ($t, $u) = @_;
  				       my $root;
  				       while (defined($root = shift @d)) {
  					   last if exists $u->{ $root };
  				       }
  				       if (defined $root) {
  					   unless (@{ $t->{ roots } }) {
  					       push @c, [];
  					       return $root;
  					   } else {
  					       $t->terminate;
  					       return;
  					   }
  				       } else {
  					   return;
  				       }
  				   },
  				   pre => sub {
  				       my ($v, $t) = @_;
  				       push @{ $c[-1] }, $v;
  				   },
  				   @_);
      $u->dfs;
      return @{ $u->{ roots } } == 1 && keys %{ $u->{ unseen } } == 0;
  }
  
  *strongly_connected = \&is_strongly_connected;
  
  sub strongly_connected_graph {
      my $g = shift;
      my %attr = @_;
  
      $g->expect_directed;
  
      my $t = Graph::Traversal::DFS->new($g);
      my @d = reverse $t->dfs;
      my @c;
      my $h = $g->transpose;
      my $u =
  	Graph::Traversal::DFS->new($h,
  				   next_root => sub {
  				       my ($t, $u) = @_;
  				       my $root;
  				       while (defined($root = shift @d)) {
  					   last if exists $u->{ $root };
  				       }
  				       if (defined $root) {
  					   push @c, [];
  					   return $root;
  				       } else {
  					   return;
  				       }
  				   },
  				   pre => sub {
  				       my ($v, $t) = @_;
  				       push @{ $c[-1] }, $v;
  				   }
  				   );
  
      $u->dfs;
  
      my $sc_cb;
      my $hv_cb;
  
      _opt_get(\%attr, super_component => \$sc_cb);
      _opt_get(\%attr, hypervertex => \$hv_cb);
      _opt_unknown(\%attr);
  
      if (defined $hv_cb && !defined $sc_cb) {
  	$sc_cb = sub { $hv_cb->( [ @_ ] ) };
      }
      unless (defined $sc_cb) {
  	$sc_cb = $super_component;
      }
  
      my $s = Graph->new;
  
      my %c;
      my @s;
      for (my $i = 0; $i <  @c; $i++) {
  	my $c = $c[$i];
  	$s->add_vertex( $s[$i] = $sc_cb->(@$c) );
  	$s->set_vertex_attribute($s[$i], 'subvertices', [ @$c ]);
  	for my $v (@$c) {
  	    $c{$v} = $i;
  	}
      }
  
      my $n = @c;
      for my $v ($g->vertices) {
  	unless (exists $c{$v}) {
  	    $c{$v} = $n;
  	    $s[$n] = $v;
  	    $n++;
  	}
      }
  
      for my $e ($g->edges05) {
  	my ($u, $v) = @$e; # @TODO: hyperedges
  	unless ($c{$u} == $c{$v}) {
  	    my ($p, $q) = ( $s[ $c{ $u } ], $s[ $c{ $v } ] );
  	    $s->add_edge($p, $q) unless $s->has_edge($p, $q);
  	}
      }
  
      if (my @i = $g->isolated_vertices) {
  	$s->add_vertices(map { $s[ $c{ $_ } ] } @i);
      }
  
      return $s;
  }
  
  ###
  # Biconnectivity.
  #
  
  sub _biconnectivity_out {
    my ($state, $u, $v) = @_;
    if (exists $state->{stack}) {
      my @BC;
      while (@{$state->{stack}}) {
        my $e = pop @{$state->{stack}};
        push @BC, $e;
        last if defined $u && $e->[0] eq $u && $e->[1] eq $v;
      }
      if (@BC) {
        push @{$state->{BC}}, \@BC;
      }
    }
  }
  
  sub _biconnectivity_dfs {
    my ($g, $u, $state) = @_;
    $state->{num}->{$u} = $state->{dfs}++;
    $state->{low}->{$u} = $state->{num}->{$u};
    for my $v ($g->successors($u)) {
      unless (exists $state->{num}->{$v}) {
        push @{$state->{stack}}, [$u, $v];
        $state->{pred}->{$v} = $u;
        $state->{succ}->{$u}->{$v}++;
        _biconnectivity_dfs($g, $v, $state);
        if ($state->{low}->{$v} < $state->{low}->{$u}) {
  	$state->{low}->{$u} = $state->{low}->{$v};
        }
        if ($state->{low}->{$v} >= $state->{num}->{$u}) {
  	_biconnectivity_out($state, $u, $v);
        }
      } elsif (defined $state->{pred}->{$u} &&
  	     $state->{pred}->{$u} ne $v &&
  	     $state->{num}->{$v} < $state->{num}->{$u}) {
        push @{$state->{stack}}, [$u, $v];
        if ($state->{num}->{$v} < $state->{low}->{$u}) {
  	$state->{low}->{$u} = $state->{num}->{$v};
        }
      }
    }
  }
  
  sub _biconnectivity_compute {
      my ($g) = @_;
      my %state;
      @{$state{BC}} = ();
      @{$state{BR}} = ();
      %{$state{V2BC}} = ();
      %{$state{BC2V}} = ();
      @{$state{AP}} = ();
      $state{dfs} = 0;
      my @u = _shuffle $g->vertices;
      for my $u (@u) {
        unless (exists $state{num}->{$u}) {
  	_biconnectivity_dfs($g, $u, \%state);
  	_biconnectivity_out(\%state);
  	delete $state{stack};
        }
      }
  
      # Mark the components each vertex belongs to.
      my $bci = 0;
      for my $bc (@{$state{BC}}) {
        for my $e (@$bc) {
  	for my $v (@$e) {
  	  $state{V2BC}->{$v}->{$bci}++;
  	}
        }
        $bci++;
      }
  
      # Any isolated vertices get each their own component.
      for my $v ($g->vertices) {
        unless (exists $state{V2BC}->{$v}) {
  	$state{V2BC}->{$v}->{$bci++}++;
        }
      }
  
      for my $v ($g->vertices) {
        for my $bc (keys %{$state{V2BC}->{$v}}) {
  	$state{BC2V}->{$bc}->{$v}->{$bc}++;
        }
      }
  
      # Articulation points / cut vertices are the vertices
      # which belong to more than one component.
      for my $v (keys %{$state{V2BC}}) {
        if (keys %{$state{V2BC}->{$v}} > 1) {
  	push @{$state{AP}}, $v;
        }
      }
  
      # Bridges / cut edges are the components of two vertices.
      for my $v (keys %{$state{BC2V}}) {
        my @v = keys %{$state{BC2V}->{$v}};
        if (@v == 2) {
  	push @{$state{BR}}, \@v;
        }
      }
  
      # Create the subgraph components.
      my @sg;
      for my $bc (@{$state{BC}}) {
        my %v;
        my $w = Graph::Undirected->new();
        for my $e (@$bc) {
  	my ($u, $v) = @$e;
  	$v{$u}++;
  	$v{$v}++;
  	$w->add_edge($u, $v);
        }
        push @sg, [ keys %v ];
      }
  
      return [ $state{AP}, \@sg, $state{BR}, $state{V2BC}, ];
  }
  
  sub biconnectivity {
      my $g = shift;
      $g->expect_undirected;
      my $bcc = _check_cache($g, 'biconnectivity',
  			   \&_biconnectivity_compute, @_);
      return defined $bcc ? @$bcc : ( );
  }
  
  sub is_biconnected {
      my $g = shift;
      my ($ap) = ($g->biconnectivity(@_))[0];
      return $g->edges >= 2 ? @$ap == 0 : undef ;
  }
  
  sub is_edge_connected {
      my $g = shift;
      my ($br) = ($g->biconnectivity(@_))[2];
      return $g->edges >= 2 ? @$br == 0 : undef;
  }
  
  sub is_edge_separable {
      my $g = shift;
      my ($br) = ($g->biconnectivity(@_))[2];
      return $g->edges >= 2 ? @$br > 0 : undef;
  }
  
  sub articulation_points {
      my $g = shift;
      my ($ap) = ($g->biconnectivity(@_))[0];
      return @$ap;
  }
  
  *cut_vertices = \&articulation_points;
  
  sub biconnected_components {
      my $g = shift;
      my ($bc) = ($g->biconnectivity(@_))[1];
      return @$bc;
  }
  
  sub biconnected_component_by_index {
      my $g = shift;
      my $i = shift;
      my ($bc) = ($g->biconnectivity(@_))[1];
      return $bc->[ $i ];
  }
  
  sub biconnected_component_by_vertex {
      my $g = shift;
      my $v = shift;
      my ($v2bc) = ($g->biconnectivity(@_))[3];
      return defined $v2bc->{ $v } ? keys %{ $v2bc->{ $v } } : ();
  }
  
  sub same_biconnected_components {
      my $g = shift;
      my $u = shift;
      my @u = $g->biconnected_component_by_vertex($u, @_);
      return 0 unless @u;
      my %ubc; @ubc{ @u } = ();
      while (@_) {
  	my $v = shift;
  	my @v = $g->biconnected_component_by_vertex($v);
  	if (@v) {
  	    my %vbc; @vbc{ @v } = ();
  	    my $vi;
  	    for my $ui (keys %ubc) {
  		if (exists $vbc{ $ui }) {
  		    $vi = $ui;
  		    last;
  		}
  	    }
  	    return 0 unless defined $vi;
  	}
      }
      return 1;
  }
  
  sub biconnected_graph {
      my ($g, %opt) = @_;
      my ($bc, $v2bc) = ($g->biconnectivity, %opt)[1, 3];
      my $bcg = Graph::Undirected->new;
      my $sc_cb =
  	exists $opt{super_component} ?
  	    $opt{super_component} : $super_component;
      for my $c (@$bc) {
  	$bcg->add_vertex(my $s = $sc_cb->(@$c));
  	$bcg->set_vertex_attribute($s, 'subvertices', [ @$c ]);
      }
      my %k;
      for my $i (0..$#$bc) {
  	my @u = @{ $bc->[ $i ] };
  	my %i; @i{ @u } = ();
  	for my $j (0..$#$bc) {
  	    if ($i > $j) {
  		my @v = @{ $bc->[ $j ] };
  		my %j; @j{ @v } = ();
  		for my $u (@u) {
  		    if (exists $j{ $u }) {
  			unless ($k{ $i }{ $j }++) {
  			    $bcg->add_edge($sc_cb->(@{$bc->[$i]}),
  					   $sc_cb->(@{$bc->[$j]}));
  			}
  			last;
  		    }
  		}
  	    }
  	}
      }
      return $bcg;
  }
  
  sub bridges {
      my $g = shift;
      my ($br) = ($g->biconnectivity(@_))[2];
      return defined $br ? @$br : ();
  }
  
  ###
  # SPT.
  #
  
  sub _SPT_add {
      my ($g, $h, $HF, $r, $attr, $unseen, $etc) = @_;
      my $etc_r = $etc->{ $r } || 0;
      for my $s ( grep { exists $unseen->{ $_ } } $g->successors( $r ) ) {
  	my $t = $g->get_edge_attribute( $r, $s, $attr );
  	$t = 1 unless defined $t;
  	if ($t < 0) {
  	    require Carp;
  	    Carp::croak("Graph::SPT_Dijkstra: edge $r-$s is negative ($t)");
  	}
  	if (!defined($etc->{ $s }) || ($etc_r + $t) < $etc->{ $s }) {
  	    my $etc_s = $etc->{ $s } || 0;
  	    $etc->{ $s } = $etc_r + $t;
  	    # print "$r - $s : setting $s to $etc->{ $s } ($etc_r, $etc_s)\n";
  	    $h->set_vertex_attribute( $s, $attr, $etc->{ $s });
  	    $h->set_vertex_attribute( $s, 'p', $r );
  	    $HF->add( Graph::SPTHeapElem->new($r, $s, $etc->{ $s }) );
  	}
      }
  }
  
  sub _SPT_Dijkstra_compute {
  }
  
  sub SPT_Dijkstra {
      my $g = shift;
      my %opt = @_ == 1 ? (first_root => $_[0]) : @_;
      my $first_root = $opt{ first_root };
      unless (defined $first_root) {
  	$opt{ first_root } = $first_root = $g->random_vertex();
      }
      my $spt_di = $g->get_graph_attribute('_spt_di');
      unless (defined $spt_di && exists $spt_di->{ $first_root } && $spt_di->{ $first_root }->[ 0 ] == $g->[ _G ]) {
  	my %etc;
  	my $sptg = $g->_heap_walk($g->new, \&_SPT_add, \%etc, %opt);
  	$spt_di->{ $first_root } = [ $g->[ _G ], $sptg ];
  	$g->set_graph_attribute('_spt_di', $spt_di);
      }
  
      my $spt = $spt_di->{ $first_root }->[ 1 ];
  
      $spt->set_graph_attribute('SPT_Dijkstra_root', $first_root);
  
      return $spt;
  }
  
  *SSSP_Dijkstra = \&SPT_Dijkstra;
  
  *single_source_shortest_paths = \&SPT_Dijkstra;
  
  sub SP_Dijkstra {
      my ($g, $u, $v) = @_;
      my $sptg = $g->SPT_Dijkstra(first_root => $u);
      my @path = ($v);
      my %seen;
      my $V = $g->vertices;
      my $p;
      while (defined($p = $sptg->get_vertex_attribute($v, 'p'))) {
  	last if exists $seen{$p};
  	push @path, $p;
  	$v = $p;
  	$seen{$p}++;
  	last if keys %seen == $V || $u eq $v;
      }
      @path = () if @path && $path[-1] ne $u;
      return reverse @path;
  }
  
  sub __SPT_Bellman_Ford {
      my ($g, $u, $v, $attr, $d, $p, $c0, $c1) = @_;
      return unless $c0->{ $u };
      my $w = $g->get_edge_attribute($u, $v, $attr);
      $w = 1 unless defined $w;
      if (defined $d->{ $v }) {
  	if (defined $d->{ $u }) {
  	    if ($d->{ $v } > $d->{ $u } + $w) {
  		$d->{ $v } = $d->{ $u } + $w;
  		$p->{ $v } = $u;
  		$c1->{ $v }++;
  	    }
  	} # else !defined $d->{ $u } &&  defined $d->{ $v }
      } else {
  	if (defined $d->{ $u }) {
  	    #  defined $d->{ $u } && !defined $d->{ $v }
  	    $d->{ $v } = $d->{ $u } + $w;
  	    $p->{ $v } = $u;
  	    $c1->{ $v }++;
  	} # else !defined $d->{ $u } && !defined $d->{ $v }
      }
  }
  
  sub _SPT_Bellman_Ford {
      my ($g, $opt, $unseenh, $unseena, $r, $next, $code, $attr) = @_;
      my %d;
      return unless defined $r;
      $d{ $r } = 0;
      my %p;
      my $V = $g->vertices;
      my %c0; # Changed during the last iteration?
      $c0{ $r }++;
      for (my $i = 0; $i < $V; $i++) {
  	my %c1;
  	for my $e ($g->edges) {
  	    my ($u, $v) = @$e;
  	    __SPT_Bellman_Ford($g, $u, $v, $attr, \%d, \%p, \%c0, \%c1);
  	    if ($g->undirected) {
  		__SPT_Bellman_Ford($g, $v, $u, $attr, \%d, \%p, \%c0, \%c1);
  	    }
  	}
  	%c0 = %c1 unless $i == $V - 1;
      }
  
      for my $e ($g->edges) {
  	my ($u, $v) = @$e;
  	if (defined $d{ $u } && defined $d{ $v }) {
  	    my $d = $g->get_edge_attribute($u, $v, $attr);
  	    if (defined $d && $d{ $v } > $d{ $u } + $d) {
  		require Carp;
  		Carp::croak("Graph::SPT_Bellman_Ford: negative cycle exists");
  	    }
  	}
      }
  
      return (\%p, \%d);
  }
  
  sub _SPT_Bellman_Ford_compute {
  }
  
  sub SPT_Bellman_Ford {
      my $g = shift;
  
      my ($opt, $unseenh, $unseena, $r, $next, $code, $attr) = $g->_root_opt(@_);
  
      unless (defined $r) {
  	$r = $g->random_vertex();
  	return unless defined $r;
      }
  
      my $spt_bf = $g->get_graph_attribute('_spt_bf');
      unless (defined $spt_bf &&
  	    exists $spt_bf->{ $r } && $spt_bf->{ $r }->[ 0 ] == $g->[ _G ]) {
  	my ($p, $d) =
  	    $g->_SPT_Bellman_Ford($opt, $unseenh, $unseena,
  				  $r, $next, $code, $attr);
  	my $h = $g->new;
  	for my $v (keys %$p) {
  	    my $u = $p->{ $v };
  	    $h->add_edge( $u, $v );
  	    $h->set_edge_attribute( $u, $v, $attr,
  				    $g->get_edge_attribute($u, $v, $attr));
  	    $h->set_vertex_attribute( $v, $attr, $d->{ $v } );
  	    $h->set_vertex_attribute( $v, 'p', $u );
  	}
  	$spt_bf->{ $r } = [ $g->[ _G ], $h ];
  	$g->set_graph_attribute('_spt_bf', $spt_bf);
      }
  
      my $spt = $spt_bf->{ $r }->[ 1 ];
  
      $spt->set_graph_attribute('SPT_Bellman_Ford_root', $r);
  
      return $spt;
  }
  
  *SSSP_Bellman_Ford = \&SPT_Bellman_Ford;
  
  sub SP_Bellman_Ford {
      my ($g, $u, $v) = @_;
      my $sptg = $g->SPT_Bellman_Ford(first_root => $u);
      my @path = ($v);
      my %seen;
      my $V = $g->vertices;
      my $p;
      while (defined($p = $sptg->get_vertex_attribute($v, 'p'))) {
  	last if exists $seen{$p};
  	push @path, $p;
  	$v = $p;
  	$seen{$p}++;
  	last if keys %seen == $V;
      }
      # @path = () if @path && "$path[-1]" ne "$u";
      return reverse @path;
  }
  
  ###
  # Transitive Closure.
  #
  
  sub TransitiveClosure_Floyd_Warshall {
      my $self = shift;
      my $class = ref $self || $self;
      $self = shift unless ref $self;
      bless Graph::TransitiveClosure->new($self, @_), $class;
  }
  
  *transitive_closure = \&TransitiveClosure_Floyd_Warshall;
  
  sub APSP_Floyd_Warshall {
      my $self = shift;
      my $class = ref $self || $self;
      $self = shift unless ref $self;
      bless Graph::TransitiveClosure->new($self, path => 1, @_), $class;
  }
  
  *all_pairs_shortest_paths = \&APSP_Floyd_Warshall;
  
  sub _transitive_closure_matrix_compute {
  }
  
  sub transitive_closure_matrix {
      my $g = shift;
      my $tcm = $g->get_graph_attribute('_tcm');
      if (defined $tcm) {
  	if (ref $tcm eq 'ARRAY') { # YECHHH!
  	    if ($tcm->[ 0 ] == $g->[ _G ]) {
  		$tcm = $tcm->[ 1 ];
  	    } else {
  		undef $tcm;
  	    }
  	}
      }
      unless (defined $tcm) {
  	my $apsp = $g->APSP_Floyd_Warshall(@_);
  	$tcm = $apsp->get_graph_attribute('_tcm');
  	$g->set_graph_attribute('_tcm', [ $g->[ _G ], $tcm ]);
      }
  
      return $tcm;
  }
  
  sub path_length {
      my $g = shift;
      my $tcm = $g->transitive_closure_matrix;
      $tcm->path_length(@_);
  }
  
  sub path_predecessor {
      my $g = shift;
      my $tcm = $g->transitive_closure_matrix;
      $tcm->path_predecessor(@_);
  }
  
  sub path_vertices {
      my $g = shift;
      my $tcm = $g->transitive_closure_matrix;
      $tcm->path_vertices(@_);
  }
  
  sub is_reachable {
      my $g = shift;
      my $tcm = $g->transitive_closure_matrix;
      $tcm->is_reachable(@_);
  }
  
  sub for_shortest_paths {
      my $g = shift;
      my $c = shift;
      my $t = $g->transitive_closure_matrix;
      my @v = $g->vertices;
      my $n = 0;
      for my $u (@v) {
  	for my $v (@v) {
  	    next unless $t->is_reachable($u, $v);
  	    $n++;
  	    $c->($t, $u, $v, $n);
  	}
      }
      return $n;
  }
  
  sub _minmax_path {
      my $g = shift;
      my $min;
      my $max;
      my $minp;
      my $maxp;
      $g->for_shortest_paths(sub {
  			       my ($t, $u, $v, $n) = @_;
  			       my $l = $t->path_length($u, $v);
  			       return unless defined $l;
  			       my $p;
  			       if ($u ne $v && (!defined $max || $l > $max)) {
  				   $max = $l;
  				   $maxp = $p = [ $t->path_vertices($u, $v) ];
  			       }
  			       if ($u ne $v && (!defined $min || $l < $min)) {
  				   $min = $l;
  				   $minp = $p || [ $t->path_vertices($u, $v) ];
  			       }
  			   });
      return ($min, $max, $minp, $maxp);
  }
  
  sub diameter {
      my $g = shift;
      my ($min, $max, $minp, $maxp) = $g->_minmax_path(@_);
      return defined $maxp ? (wantarray ? @$maxp : $max) : undef;
  }
  
  *graph_diameter = \&diameter;
  
  sub longest_path {
      my ($g, $u, $v) = @_;
      my $t = $g->transitive_closure_matrix;
      if (defined $u) {
  	if (defined $v) {
  	    return wantarray ?
  		$t->path_vertices($u, $v) : $t->path_length($u, $v);
  	} else {
  	    my $max;
  	    my @max;
  	    for my $v ($g->vertices) {
  		next if $u eq $v;
  		my $l = $t->path_length($u, $v);
  		if (defined $l && (!defined $max || $l > $max)) {
  		    $max = $l;
  		    @max = $t->path_vertices($u, $v);
  		}
  	    }
  	    return wantarray ? @max : $max;
  	}
      } else {
  	if (defined $v) {
  	    my $max;
  	    my @max;
  	    for my $u ($g->vertices) {
  		next if $u eq $v;
  		my $l = $t->path_length($u, $v);
  		if (defined $l && (!defined $max || $l > $max)) {
  		    $max = $l;
  		    @max = $t->path_vertices($u, $v);
  		}
  	    }
  	    return wantarray ? @max : @max - 1;
  	} else {
  	    my ($min, $max, $minp, $maxp) = $g->_minmax_path(@_);
  	    return defined $maxp ? (wantarray ? @$maxp : $max) : undef;
  	}
      }
  }
  
  sub vertex_eccentricity {
      my ($g, $u) = @_;
      $g->expect_undirected;
      if ($g->is_connected) {
  	my $max;
  	for my $v ($g->vertices) {
  	    next if $u eq $v;
  	    my $l = $g->path_length($u, $v);
  	    if (defined $l && (!defined $max || $l > $max)) {
  		$max = $l;
  	    }
  	}
  	return $max;
      } else {
  	return Infinity();
      }
  }
  
  sub shortest_path {
      my ($g, $u, $v) = @_;
      $g->expect_undirected;
      my $t = $g->transitive_closure_matrix;
      if (defined $u) {
  	if (defined $v) {
  	    return wantarray ?
  		$t->path_vertices($u, $v) : $t->path_length($u, $v);
  	} else {
  	    my $min;
  	    my @min;
  	    for my $v ($g->vertices) {
  		next if $u eq $v;
  		my $l = $t->path_length($u, $v);
  		if (defined $l && (!defined $min || $l < $min)) {
  		    $min = $l;
  		    @min = $t->path_vertices($u, $v);
  		}
  	    }
  	    return wantarray ? @min : $min;
  	}
      } else {
  	if (defined $v) {
  	    my $min;
  	    my @min;
  	    for my $u ($g->vertices) {
  		next if $u eq $v;
  		my $l = $t->path_length($u, $v);
  		if (defined $l && (!defined $min || $l < $min)) {
  		    $min = $l;
  		    @min = $t->path_vertices($u, $v);
  		}
  	    }
  	    return wantarray ? @min : $min;
  	} else {
  	    my ($min, $max, $minp, $maxp) = $g->_minmax_path(@_);
  	    return defined $minp ? (wantarray ? @$minp : $min) : undef;
  	}
      }
  }
  
  sub radius {
      my $g = shift;
      $g->expect_undirected;
      my ($center, $radius) = (undef, Infinity());
      for my $v ($g->vertices) {
  	my $x = $g->vertex_eccentricity($v);
  	($center, $radius) = ($v, $x) if defined $x && $x < $radius;
      }
      return $radius;
  }
  
  sub center_vertices {
      my ($g, $delta) = @_;
      $g->expect_undirected;
      $delta = 0 unless defined $delta;
      $delta = abs($delta);
      my @c;
      my $r = $g->radius;
      if (defined $r) {
  	for my $v ($g->vertices) {
  	    my $e = $g->vertex_eccentricity($v);
  	    next unless defined $e;
  	    push @c, $v if abs($e - $r) <= $delta;
  	}
      }
      return @c;
  }
  
  *centre_vertices = \&center_vertices;
  
  sub average_path_length {
      my $g = shift;
      my @A = @_;
      my $d = 0;
      my $m = 0;
      my $n = $g->for_shortest_paths(sub {
  				       my ($t, $u, $v, $n) = @_;
  				       my $l = $t->path_length($u, $v);
  				       if ($l) {
  					   my $c = @A == 0 ||
  					       (@A == 1 && $u eq $A[0]) ||
  						   ((@A == 2) &&
  						    (defined $A[0] &&
  						     $u eq $A[0]) ||
  						    (defined $A[1] &&
  						     $v eq $A[1]));
  					   if ($c) {
  					       $d += $l;
  					       $m++;
  					   }
  				       }
  				   });
      return $m ? $d / $m : undef;
  }
  
  ###
  # Simple tests.
  #
  
  sub is_multi_graph {
      my $g = shift;
      return 0 unless $g->is_multiedged || $g->is_countedged;
      my $multiedges = 0;
      for my $e ($g->edges05) {
  	my ($u, @v) = @$e;
  	for my $v (@v) {
  	    return 0 if $u eq $v;
  	}
  	$multiedges++ if $g->get_edge_count(@$e) > 1;
      }
      return $multiedges;
  }
  
  sub is_simple_graph {
      my $g = shift;
      return 1 unless $g->is_countedged || $g->is_multiedged;
      for my $e ($g->edges05) {
  	return 0 if $g->get_edge_count(@$e) > 1;
      }
      return 1;
  }
  
  sub is_pseudo_graph {
      my $g = shift;
      my $m = $g->is_countedged || $g->is_multiedged;
      for my $e ($g->edges05) {
  	my ($u, @v) = @$e;
  	for my $v (@v) {
  	    return 1 if $u eq $v;
  	}
  	return 1 if $m && $g->get_edge_count($u, @v) > 1;
      }
      return 0;
  }
  
  ###
  # Rough isomorphism guess.
  #
  
  my %_factorial = (0 => 1, 1 => 1);
  
  sub __factorial {
      my $n = shift;
      for (my $i = 2; $i <= $n; $i++) {
  	next if exists $_factorial{$i};
  	$_factorial{$i} = $i * $_factorial{$i - 1};
      }
      $_factorial{$n};
  }
  
  sub _factorial {
      my $n = int(shift);
      if ($n < 0) {
  	require Carp;
  	Carp::croak("factorial of a negative number");
      }
      __factorial($n) unless exists $_factorial{$n};
      return $_factorial{$n};
  }
  
  sub could_be_isomorphic {
      my ($g0, $g1) = @_;
      return 0 unless $g0->vertices == $g1->vertices;
      return 0 unless $g0->edges05  == $g1->edges05;
      my %d0;
      for my $v0 ($g0->vertices) {
  	$d0{ $g0->in_degree($v0) }{ $g0->out_degree($v0) }++
      }
      my %d1;
      for my $v1 ($g1->vertices) {
  	$d1{ $g1->in_degree($v1) }{ $g1->out_degree($v1) }++
      }
      return 0 unless keys %d0 == keys %d1;
      for my $da (keys %d0) {
  	return 0
  	    unless exists $d1{$da} &&
  		   keys %{ $d0{$da} } == keys %{ $d1{$da} };
  	for my $db (keys %{ $d0{$da} }) {
  	    return 0
  		unless exists $d1{$da}{$db} && 
  		       $d0{$da}{$db} == $d1{$da}{$db};
  	}
      }
      for my $da (keys %d0) {
  	for my $db (keys %{ $d0{$da} }) {
  	    return 0 unless $d1{$da}{$db} == $d0{$da}{$db};
  	}
  	delete $d1{$da};
      }
      return 0 unless keys %d1 == 0;
      my $f = 1;
      for my $da (keys %d0) {
  	for my $db (keys %{ $d0{$da} }) {
  	    $f *= _factorial(abs($d0{$da}{$db}));
  	}
      }
      return $f;
  }
  
  ###
  # Analysis functions.
  
  sub subgraph_by_radius
  {
      my ($g, $n, $rad) = @_;
  
      return unless defined $n && defined $rad && $rad >= 0;
  
      my $r = (ref $g)->new;
  
      if ($rad == 0) {
  	return $r->add_vertex($n);
      }
  
      my %h;
      $h{1} = [ [ $n, $g->successors($n) ] ];
      for my $i (1..$rad) {
  	$h{$i+1} = [];
  	for my $arr (@{ $h{$i} }) {
  	    my ($p, @succ) = @{ $arr };
  	    for my $s (@succ) {
  		$r->add_edge($p, $s);
  		push(@{ $h{$i+1} }, [$s, $g->successors($s)]) if $i < $rad;
  	    }
  	}
      }
  
      return $r;
  }
  
  sub clustering_coefficient {
      my ($g) = @_;
      my %clustering;
  
      my $gamma = 0;
  
      for my $n ($g->vertices()) {
  	my $gamma_v = 0;
  	my @neigh = $g->successors($n);
  	my %c;
  	for my $u (@neigh) {
  	    for my $v (@neigh) {
  		if (!$c{"$u-$v"} && $g->has_edge($u, $v)) {
  		    $gamma_v++;
  		    $c{"$u-$v"} = 1;
  		    $c{"$v-$u"} = 1;
  		}
  	    }
  	}
  	if (@neigh > 1) {
  	    $clustering{$n} = $gamma_v/(@neigh * (@neigh - 1) / 2);
  	    $gamma += $gamma_v/(@neigh * (@neigh - 1) / 2);
  	} else {
  	    $clustering{$n} = 0;
  	}
      }
  
      $gamma /= $g->vertices();
  
      return wantarray ? ($gamma, %clustering) : $gamma;
  }
  
  sub betweenness {
      my $g = shift;
  
      my @V = $g->vertices();
  
      my %Cb; # C_b{w} = 0
  
      $Cb{$_} = 0 for @V;
  
      for my $s (@V) {
  	my @S; # stack (unshift, shift)
  
  	my %P; # P{w} = empty list
  	$P{$_} = [] for @V;
  
  	my %sigma; # \sigma{t} = 0
  	$sigma{$_} = 0 for @V;
  	$sigma{$s} = 1;
  
  	my %d; # d{t} = -1;
  	$d{$_} = -1 for @V;
  	$d{$s} = 0;
  
  	my @Q; # queue (push, shift)
  	push @Q, $s;
  
  	while (@Q) {
  	    my $v = shift @Q;
  	    unshift @S, $v;
  	    for my $w ($g->successors($v)) {
  		# w found for first time
  		if ($d{$w} < 0) {
  		    push @Q, $w;
  		    $d{$w} = $d{$v} + 1;
  		}
  		# Shortest path to w via v
  		if ($d{$w} == $d{$v} + 1) {
  		    $sigma{$w} += $sigma{$v};
  		    push @{ $P{$w} }, $v;
  		}
  	    }
  	}
  
  	my %delta;
  	$delta{$_} = 0 for @V;
  
  	while (@S) {
  	    my $w = shift @S;
  	    for my $v (@{ $P{$w} }) {
  		$delta{$v} += $sigma{$v}/$sigma{$w} * (1 + $delta{$w});
  	    }
  	    if ($w ne $s) {
  		$Cb{$w} += $delta{$w};
  	    }
  	}
      }
  
      return %Cb;
  }
  
  ###
  # Debugging.
  #
  
  sub _dump {
      require Data::Dumper;
      my $d = Data::Dumper->new([$_[0]],[ref $_[0]]);
      defined wantarray ? $d->Dump : print $d->Dump;
  }
  
  1;
GRAPH

$fatpacked{"Graph/AdjacencyMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_ADJACENCYMAP';
  package Graph::AdjacencyMap;
  
  use strict;
  
  require Exporter;
  use vars qw(@ISA @EXPORT_OK %EXPORT_TAGS);
  @ISA = qw(Exporter);
  @EXPORT_OK   = qw(_COUNT _MULTI _COUNTMULTI _GEN_ID
  		  _HYPER _UNORD _UNIQ _REF _UNORDUNIQ _UNIONFIND _LIGHT
  		  _STR _REFSTR
  		  _n _f _a _i _s _p _g _u _ni _nc _na _nm);
  %EXPORT_TAGS =
      (flags =>  [qw(_COUNT _MULTI _COUNTMULTI _GEN_ID
  		   _HYPER _UNORD _UNIQ _REF _UNORDUNIQ _UNIONFIND _LIGHT
  		   _STR _REFSTR)],
       fields => [qw(_n _f _a _i _s _p _g _u _ni _nc _na _nm)]);
  
  sub _COUNT       () {  0x00000001   }
  sub _MULTI       () {  0x00000002   }
  sub _COUNTMULTI  () { _COUNT|_MULTI }
  sub _HYPER       () {  0x00000004   }
  sub _UNORD       () {  0x00000008   }
  sub _UNIQ        () {  0x00000010   }
  sub _REF         () {  0x00000020   }
  sub _UNORDUNIQ   () { _UNORD|_UNIQ  }
  sub _UNIONFIND   () {  0x00000040   }
  sub _LIGHT       () {  0x00000080   }
  sub _STR         () {  0x00000100   }
  sub _REFSTR      () { _REF|_STR     }
  
  my $_GEN_ID = 0;
  
  sub _GEN_ID () { \$_GEN_ID }
  
  sub _ni () { 0 } # Node index.
  sub _nc () { 1 } # Node count.
  sub _na () { 2 } # Node attributes.
  sub _nm () { 3 } # Node map.
  
  sub _n () { 0 } # Next id.
  sub _f () { 1 } # Flags.
  sub _a () { 2 } # Arity.
  sub _i () { 3 } # Index to path.
  sub _s () { 4 } # Successors / Path to Index.
  sub _p () { 5 } # Predecessors.
  sub _g () { 6 } # Graph (AdjacencyMap::Light)
  
  sub _V () { 2 }  # Graph::_V()
  
  sub _new {
      my $class = shift;
      my $map = bless [ 0, @_ ], $class;
      return $map;
  }
  
  sub _ids {
      my $m = shift;
      return $m->[ _i ];
  }
  
  sub has_paths {
      my $m = shift;
      return defined $m->[ _i ] && keys %{ $m->[ _i ] };
  }
  
  sub _dump {
      my $d = Data::Dumper->new([$_[0]],[ref $_[0]]);
      defined wantarray ? $d->Dump : print $d->Dump;
  }
  
  sub _del_id {
      my ($m, $i) = @_;
      my @p = $m->_get_id_path( $i );
      $m->del_path( @p ) if @p;
  }
  
  sub _new_node {
      my ($m, $n, $id) = @_;
      my $f = $m->[ _f ];
      my $i = $m->[ _n ]++;
      if (($f & _MULTI)) {
  	$id = 0 if $id eq _GEN_ID;
  	$$n = [ $i, 0, undef, { $id => { } } ];
      } elsif (($f & _COUNT)) {
  	$$n = [ $i, 1 ];
      } else {
  	$$n = $i;
      }
      return $i;
  }
  
  sub _inc_node {
      my ($m, $n, $id) = @_;
      my $f = $m->[ _f ];
      if (($f & _MULTI)) {
  	if ($id eq _GEN_ID) {
  	    $$n->[ _nc ]++
  		while exists $$n->[ _nm ]->{ $$n->[ _nc ] };
  	    $id = $$n->[ _nc ];
  	}
  	$$n->[ _nm ]->{ $id } = { };
      } elsif (($f & _COUNT)) {
  	$$n->[ _nc ]++;
      }
      return $id;
  }
  
  sub __get_path_node {
      my $m = shift;
      my ($p, $k);
      my $f = $m->[ _f ];
      @_ = sort @_ if ($f & _UNORD);
      if ($m->[ _a ] == 2 && @_ == 2 && !($f & (_HYPER|_REF|_UNIQ))) { # Fast path.
  	return unless exists $m->[ _s ]->{ $_[0] };
  	$p = [ $m->[ _s ], $m->[ _s ]->{ $_[0] } ];
  	$k = [ $_[0], $_[1] ];
      } else {
  	($p, $k) = $m->__has_path( @_ );
      }
      return unless defined $p && defined $k;
      my $l = defined $k->[-1] ? $k->[-1] : "";
      return ( exists $p->[-1]->{ $l }, $p->[-1]->{ $l }, $p, $k, $l );
  }
  
  sub set_path_by_multi_id {
      my $m = shift;
      my ($p, $k) = $m->__set_path( @_ );
      return unless defined $p && defined $k;
      my $l = defined $k->[-1] ? $k->[-1] : "";
      return $m->__set_path_node( $p, $l, @_ );
  }
  
  sub get_multi_ids {
      my $m = shift;
      my $f = $m->[ _f ];
      return () unless ($f & _MULTI);
      my ($e, $n) = $m->__get_path_node( @_ );
      return $e ? keys %{ $n->[ _nm ] } : ();
  }
  
  sub _has_path_attrs {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	return keys %{ $p->[-1]->{ $l }->[ _nm ]->{ $id } } ? 1 : 0;
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	return ref $n && $#$n == _na && keys %{ $n->[ _na ] } ? 1 : 0;
      }
  }
  
  sub _set_path_attrs {
      my $m = shift;
      my $f = $m->[ _f ];
      my $attr = pop;
      my $id   = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( @_ );
      push @_, $id if ($f & _MULTI);
      my ($p, $k) = $m->__set_path( @_ );
      return unless defined $p && defined $k;
      my $l = defined $k->[-1] ? $k->[-1] : "";
      $m->__set_path_node( $p, $l, @_ ) unless exists $p->[-1]->{ $l };
      if (($f & _MULTI)) {
  	$p->[-1]->{ $l }->[ _nm ]->{ $id } = $attr;
      } else {
  	# Extend the node if it is a simple id node.
  	$p->[-1]->{ $l } = [ $p->[-1]->{ $l }, 1 ] unless ref $p->[-1]->{ $l };
  	$p->[-1]->{ $l }->[ _na ] = $attr;
      }
  }
  
  sub _has_path_attr {
      my $m = shift;
      my $f = $m->[ _f ];
      my $attr = pop;
      my $id   = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	exists $p->[-1]->{ $l }->[ _nm ]->{ $id }->{ $attr };
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	return ref $n && $#$n == _na ? exists $n->[ _na ]->{ $attr } : undef;
      }
  }
  
  sub _set_path_attr {
      my $m = shift;
      my $f = $m->[ _f ];
      my $val  = pop;
      my $attr = pop;
      my $id   = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      my ($p, $k);
      $m->__attr( \@_ ); # _LIGHT maps need this to get upgraded when needed.
      push @_, $id if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      if ($m->[ _a ] == 2 && @_ == 2 && !($f & (_REF|_UNIQ|_HYPER|_UNIQ))) {
  	$m->[ _s ]->{ $_[0] } ||= { };
  	$p = [ $m->[ _s ], $m->[ _s ]->{ $_[0] } ];
  	$k = [ $_[0], $_[1] ];
      } else {
  	($p, $k) = $m->__set_path( @_ );
      }
      return unless defined $p && defined $k;
      my $l = defined $k->[-1] ? $k->[-1] : "";
      $m->__set_path_node( $p, $l, @_ ) unless exists $p->[-1]->{ $l };
      if (($f & _MULTI)) {
  	$p->[-1]->{ $l }->[ _nm ]->{ $id }->{ $attr } = $val;
      } else {
  	# Extend the node if it is a simple id node.
  	$p->[-1]->{ $l } = [ $p->[-1]->{ $l }, 1 ] unless ref $p->[-1]->{ $l };
  	$p->[-1]->{ $l }->[ _na ]->{ $attr } = $val;
      }
      return $val;
  }
  
  sub _get_path_attrs {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id   = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	$p->[-1]->{ $l }->[ _nm ]->{ $id };
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return unless $e;
  	return $n->[ _na ] if ref $n && $#$n == _na;
  	return;
      }
  }
  
  sub _get_path_attr {
      my $m = shift;
      my $f = $m->[ _f ];
      my $attr = pop;
      my $id = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	return $p->[-1]->{ $l }->[ _nm ]->{ $id }->{ $attr };
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	return ref $n && $#$n == _na ? $n->[ _na ]->{ $attr } : undef;
      }
  }
  
  sub _get_path_attr_names {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	keys %{ $p->[-1]->{ $l }->[ _nm ]->{ $id } };
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	return keys %{ $n->[ _na ] } if ref $n && $#$n == _na;
  	return;
      }
  }
  
  sub _get_path_attr_values {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	values %{ $p->[-1]->{ $l }->[ _nm ]->{ $id } };
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	return values %{ $n->[ _na ] } if ref $n && $#$n == _na;
  	return;
      }
  }
  
  sub _del_path_attrs {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	delete $p->[-1]->{ $l }->[ _nm ]->{ $id };
  	unless (keys %{ $p->[-1]->{ $l }->[ _nm ] } ||
  		(defined $p->[-1]->{ $l }->[ _na ] &&
  		 keys %{ $p->[-1]->{ $l }->[ _na ] })) {
  	    delete $p->[-1]->{ $l };
  	}
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	if (ref $n) {
  	    $e = _na == $#$n && keys %{ $n->[ _na ] } ? 1 : 0;
  	    $#$n = _na - 1;
  	    return $e;
  	} else {
  	    return 0;
  	}
      }
  }
  
  sub _del_path_attr {
      my $m = shift;
      my $f = $m->[ _f ];
      my $attr = pop;
      my $id = pop if ($f & _MULTI);
      @_ = sort @_ if ($f & _UNORD);
      $m->__attr( \@_ );
      if (($f & _MULTI)) {
  	my ($p, $k) = $m->__has_path( @_ );
  	return unless defined $p && defined $k;
  	my $l = defined $k->[-1] ? $k->[-1] : "";
  	delete $p->[-1]->{ $l }->[ _nm ]->{ $id }->{ $attr };
  	$m->_del_path_attrs( @_, $id )
  	    unless keys %{ $p->[-1]->{ $l }->[ _nm ]->{ $id } };
      } else {
  	my ($e, $n) = $m->__get_path_node( @_ );
  	return undef unless $e;
  	if (ref $n && $#$n == _na && exists $n->[ _na ]->{ $attr }) {
  	    delete $n->[ _na ]->{ $attr };
  	    return 1;
  	} else {
  	    return 0;
  	}
      }
  }
  
  sub _is_COUNT { $_[0]->[ _f ] & _COUNT }
  sub _is_MULTI { $_[0]->[ _f ] & _MULTI }
  sub _is_HYPER { $_[0]->[ _f ] & _HYPER }
  sub _is_UNORD { $_[0]->[ _f ] & _UNORD }
  sub _is_UNIQ  { $_[0]->[ _f ] & _UNIQ  }
  sub _is_REF   { $_[0]->[ _f ] & _REF   }
  sub _is_STR   { $_[0]->[ _f ] & _STR   }
  
  sub __arg {
      my $m = shift;
      my $f = $m->[ _f ];
      my @a = @{$_[0]};
      if ($f & _UNIQ) {
  	my %u;
  	if ($f & _UNORD) {
  	    @u{ @a } = @a;
  	    @a = values %u;
  	} else {
  	    my @u;
  	    for my $e (@a) {
  		push @u, $e if $u{$e}++ == 0;
  	    }
  	    @a = @u;
  	}
      }
      # Alphabetic or numeric sort, does not matter as long as it unifies.
      @{$_[0]} = ($f & _UNORD) ? sort @a : @a;
  }
  
  sub _successors {
      my $E = shift;
      my $g = shift;
      my $V = $g->[ _V ];
      map { my @v = @{ $_->[ 1 ] };
  	  shift @v;
  	  map { $V->_get_id_path($_) } @v } $g->_edges_from( @_ );
  }
  
  sub _predecessors {
      my $E = shift;
      my $g = shift;
      my $V = $g->[ _V ];
      if (wantarray) {
  	map { my @v = @{ $_->[ 1 ] };
  	      pop @v;
  	      map { $V->_get_id_path($_) } @v } $g->_edges_to( @_ );
      } else {
  	return $g->_edges_to( @_ );
      }
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::AdjacencyMap - create and a map of graph vertices or edges
  
  =head1 SYNOPSIS
  
      Internal.
  
  =head1 DESCRIPTION
  
  B<This module is meant for internal use by the Graph module.>
  
  =head2 Object Methods
  
  =over 4
  
  =item del_path(@id)
  
  Delete a Map path by ids.
  
  =item del_path_by_multi_id($id)
  
  Delete a Map path by a multi(vertex) id.
  
  =item get_multi_ids
  
  Return the multi ids.
  
  =item has_path(@id)
  
  Return true if the Map has the path by ids, false if not.
  
  =item has_paths
  
  Return true if the Map has any paths, false if not.
  
  =item has_path_by_multi_id($id)
  
  Return true if the Map has the path by a multi(vertex) id, false if not.
  
  =item paths
  
  Return all the paths of the Map.
  
  =item set_path(@id)
  
  Set the path by @ids.
  
  =item set_path_by_multi_id
  
  Set the path in the Map by the multi id.
  
  =back
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_ADJACENCYMAP

$fatpacked{"Graph/AdjacencyMap/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_ADJACENCYMAP_HEAVY';
  package Graph::AdjacencyMap::Heavy;
  
  # THIS IS INTERNAL IMPLEMENTATION ONLY, NOT TO BE USED DIRECTLY.
  # THE INTERFACE IS HARD TO USE AND GOING TO STAY THAT WAY AND
  # ALMOST GUARANTEED TO CHANGE OR GO AWAY IN FUTURE RELEASES.
  
  use strict;
  
  # $SIG{__DIE__ } = sub { use Carp; confess };
  # $SIG{__WARN__} = sub { use Carp; confess };
  
  use Graph::AdjacencyMap qw(:flags :fields);
  use base 'Graph::AdjacencyMap';
  
  require overload; # for de-overloading
  
  require Data::Dumper;
  
  sub __set_path {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      if (@_ != $m->[ _a ] && !($f & _HYPER)) {
  	require Carp;
  	Carp::confess(sprintf "Graph::AdjacencyMap::Heavy: arguments %d expected %d",
  		      scalar @_, $m->[ _a ]);
      }
      my $p;
      $p = ($f & _HYPER) ?
  	(( $m->[ _s ] ||= [ ] )->[ @_ ] ||= { }) :
  	(  $m->[ _s ]                   ||= { });
      my @p = $p;
      my @k;
      while (@_) {
  	my $k = shift;
  	my $q = ref $k && ($f & _REF) && overload::Method($k, '""') ? overload::StrVal($k) : $k;
  	if (@_) {
  	    $p = $p->{ $q } ||= {};
  	    return unless $p;
  	    push @p, $p;
  	}
  	push @k, $q;
      }
      return (\@p, \@k);
  }
  
  sub __set_path_node {
      my ($m, $p, $l) = splice @_, 0, 3;
      my $f = $m->[ _f ] ;
      my $id = pop if ($f & _MULTI);
      unless (exists $p->[-1]->{ $l }) {
  	my $i = $m->_new_node( \$p->[-1]->{ $l }, $id );
  	$m->[ _i ]->{ defined $i ? $i : "" } = [ @_ ];
          return defined $id ? ($id eq _GEN_ID ? $$id : $id) : $i;
      } else {
  	return $m->_inc_node( \$p->[-1]->{ $l }, $id );
      }
  }
  
  sub set_path {
      my $m = shift;
      my $f = $m->[ _f ];
      if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
          else { $m->__arg(\@_) }
      }
      my ($p, $k) = $m->__set_path( @_ );
      return unless defined $p && defined $k;
      my $l = defined $k->[-1] ? $k->[-1] : "";
      return $m->__set_path_node( $p, $l, @_ );
  }
  
  sub __has_path {
      my $m = shift;
      my $f = $m->[ _f ];
      if (@_ != $m->[ _a ] && !($f & _HYPER)) {
  	require Carp;
  	Carp::confess(sprintf "Graph::AdjacencyMap::Heavy: arguments %d expected %d",
  		      scalar @_, $m->[ _a ]);
      }
      if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
          else { $m->__arg(\@_) }
      }
      my $p = $m->[ _s ];
      return unless defined $p;
      $p = $p->[ @_ ] if ($f & _HYPER);
      return unless defined $p;
      my @p = $p;
      my @k;
      while (@_) {
  	my $k = shift;
  	my $q = ref $k && ($f & _REF) && overload::Method($k, '""') ? overload::StrVal($k) : $k;
  	if (@_) {
  	    $p = $p->{ $q };
  	    return unless defined $p;
  	    push @p, $p;
  	}
  	push @k, $q;
      }
      return (\@p, \@k);
  }
  
  sub has_path {
      my $m = shift;
      my $f = $m->[ _f ];
      if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
          else { $m->__arg(\@_) }
      }
      my ($p, $k) = $m->__has_path( @_ );
      return unless defined $p && defined $k;
      return exists $p->[-1]->{ defined $k->[-1] ? $k->[-1] : "" };
  }
  
  sub has_path_by_multi_id {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop;
      if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
          else { $m->__arg(\@_) }
      }
      my ($e, $n) = $m->__get_path_node( @_ );
      return undef unless $e;
      return exists $n->[ _nm ]->{ $id };
  }
  
  sub _get_path_node {
      my $m = shift;
      my $f = $m->[ _f ];
      if ($m->[ _a ] == 2 && @_ == 2 && !($f & (_HYPER|_REF|_UNIQ))) { # Fast path.
  	@_ = sort @_ if ($f & _UNORD);
  	return unless exists $m->[ _s ]->{ $_[0] };
  	my $p = [ $m->[ _s ], $m->[ _s ]->{ $_[0] } ];
  	my $k = [ $_[0], $_[1] ];
  	my $l = $_[1];
  	return ( exists $p->[-1]->{ $l }, $p->[-1]->{ $l }, $p, $k, $l );
      } else {
  	if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	    if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
  	    else { $m->__arg(\@_) }
  	}
  	$m->__get_path_node( @_ );
      }
  }
  
  sub _get_path_id {
      my $m = shift;
      my $f = $m->[ _f ];
      my ($e, $n);
      if ($m->[ _a ] == 2 && @_ == 2 && !($f & (_HYPER|_REF|_UNIQ))) { # Fast path.
  	@_ = sort @_ if ($f & _UNORD);
  	return unless exists $m->[ _s ]->{ $_[0] };
  	my $p = $m->[ _s ]->{ $_[0] };
  	$e = exists $p->{ $_[1] };
  	$n = $p->{ $_[1] };
      } else {
  	($e, $n) = $m->_get_path_node( @_ );
      }
      return undef unless $e;
      return ref $n ? $n->[ _ni ] : $n;
  }
  
  sub _get_path_count {
      my $m = shift;
      my $f = $m->[ _f ];
      my ($e, $n) = $m->_get_path_node( @_ );
      return undef unless $e && defined $n;
      return
  	($f & _COUNT) ? $n->[ _nc ] :
  	($f & _MULTI) ? scalar keys %{ $n->[ _nm ] } : 1;
  }
  
  sub __attr {
      my $m = shift;
      if (@_) {
  	if (ref $_[0] && @{ $_[0] }) {
  	    if (@{ $_[0] } != $m->[ _a ]) {
  		require Carp;
  		Carp::confess(sprintf
  			      "Graph::AdjacencyMap::Heavy: arguments %d expected %d\n",
  			      scalar @{ $_[0] }, $m->[ _a ]);
  	    }
  	    my $f = $m->[ _f ];
  	    if (@{ $_[0] } > 1 && ($f & _UNORDUNIQ)) {
  		if (($f & _UNORDUNIQ) == _UNORD && @{ $_[0] } == 2) {
  		    @{ $_[0] } = sort @{ $_[0] }
  		} else { $m->__arg(\@_) }
  	    }
  	}
      }
  }
  
  sub _get_id_path {
      my ($m, $i) = @_;
      my $p = defined $i ? $m->[ _i ]->{ $i } : undef;
      return defined $p ? @$p : ( );
  }
  
  sub del_path {
      my $m = shift;
      my $f = $m->[ _f ];
      if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
          else { $m->__arg(\@_) }
      }
      my ($e, $n, $p, $k, $l) = $m->__get_path_node( @_ );
      return unless $e;
      my $c = ($f & _COUNT) ? --$n->[ _nc ] : 0;
      if ($c == 0) {
  	delete $m->[ _i ]->{ ref $n ? $n->[ _ni ] : $n };
  	delete $p->[-1]->{ $l };
  	while (@$p && @$k && keys %{ $p->[-1]->{ $k->[-1] } } == 0) {
  	    delete $p->[-1]->{ $k->[-1] };
  	    pop @$p;
  	    pop @$k;
  	}
      }
      return 1;
  }
  
  sub del_path_by_multi_id {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop;
      if (@_ > 1 && ($f & _UNORDUNIQ)) {
  	if (($f & _UNORDUNIQ) == _UNORD && @_ == 2) { @_ = sort @_ }
          else { $m->__arg(\@_) }
      }
      my ($e, $n, $p, $k, $l) = $m->__get_path_node( @_ );
      return unless $e;
      delete $n->[ _nm ]->{ $id };
      unless (keys %{ $n->[ _nm ] }) {
  	delete $m->[ _i ]->{ $n->[ _ni ] };
  	delete $p->[-1]->{ $l };
  	while (@$p && @$k && keys %{ $p->[-1]->{ $k->[-1] } } == 0) {
  	    delete $p->[-1]->{ $k->[-1] };
  	    pop @$p;
  	    pop @$k;
  	}
      }
      return 1;
  }
  
  sub paths {
      my $m = shift;
      return values %{ $m->[ _i ] } if defined $m->[ _i ];
      wantarray ? ( ) : 0;
  }
  
  1;
  __END__
GRAPH_ADJACENCYMAP_HEAVY

$fatpacked{"Graph/AdjacencyMap/Light.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_ADJACENCYMAP_LIGHT';
  package Graph::AdjacencyMap::Light;
  
  # THIS IS INTERNAL IMPLEMENTATION ONLY, NOT TO BE USED DIRECTLY.
  # THE INTERFACE IS HARD TO USE AND GOING TO STAY THAT WAY AND
  # ALMOST GUARANTEED TO CHANGE OR GO AWAY IN FUTURE RELEASES.
  
  use strict;
  
  use Graph::AdjacencyMap qw(:flags :fields);
  use base 'Graph::AdjacencyMap';
  
  use Scalar::Util qw(weaken);
  
  use Graph::AdjacencyMap::Heavy;
  use Graph::AdjacencyMap::Vertex;
  
  sub _V () { 2 } # Graph::_V
  sub _E () { 3 } # Graph::_E
  sub _F () { 0 } # Graph::_F
  
  sub _new {
      my ($class, $graph, $flags, $arity) = @_;
      my $m = bless [ ], $class;
      $m->[ _n ] = 0;
      $m->[ _f ] = $flags | _LIGHT;
      $m->[ _a ] = $arity;
      $m->[ _i ] = { };
      $m->[ _s ] = { };
      $m->[ _p ] = { };
      $m->[ _g ] = $graph;
      weaken $m->[ _g ]; # So that DESTROY finds us earlier.
      return $m;
  }
  
  sub set_path {
      my $m = shift;
      my ($n, $f, $a, $i, $s, $p) = @$m;
      if ($a == 2) {
  	@_ = sort @_ if ($f & _UNORD);
      }
      my $e0 = shift;
      if ($a == 2) {
  	my $e1 = shift;
  	unless (exists $s->{ $e0 } && exists $s->{ $e0 }->{ $e1 }) {
  	    $n = $m->[ _n ]++;
  	    $i->{ $n } = [ $e0, $e1 ];
  	    $s->{ $e0 }->{ $e1 } = $n;
  	    $p->{ $e1 }->{ $e0 } = $n;
  	}
      } else {
  	unless (exists $s->{ $e0 }) {
  	    $n = $m->[ _n ]++;
  	    $s->{ $e0 } = $n;
  	    $i->{ $n } = $e0;
  	}
      }
  }
  
  sub has_path {
      my $m = shift;
      my ($n, $f, $a, $i, $s) = @$m;
      return 0 unless $a == @_;
      my $e;
      if ($a == 2) {
  	@_ = sort @_ if ($f & _UNORD);
  	$e = shift;
  	return 0 unless exists $s->{ $e };
          $s = $s->{ $e };
      }
      $e = shift;
      exists $s->{ $e };
  }
  
  sub _get_path_id {
      my $m = shift;
      my ($n, $f, $a, $i, $s) = @$m;
      return undef unless $a == @_;
      my $e;
      if ($a == 2) {
  	@_ = sort @_ if ($f & _UNORD);
  	$e = shift;
  	return undef unless exists $s->{ $e };
          $s = $s->{ $e };
      }
      $e = shift;
      $s->{ $e };
  }
  
  sub _get_path_count {
      my $m = shift;
      my ($n, $f, $a, $i, $s) = @$m;
      my $e;
      if (@_ == 2) {
  	@_ = sort @_ if ($f & _UNORD);
  	$e = shift;
  	return undef unless exists $s->{ $e };
          $s = $s->{ $e };
      }
      $e = shift;
      return exists $s->{ $e } ? 1 : 0;
  }
  
  sub has_paths {
      my $m = shift;
      my ($n, $f, $a, $i, $s) = @$m;
      keys %$s;
  }
  
  sub paths {
      my $m = shift;
      my ($n, $f, $a, $i) = @$m;
      if (defined $i) {
  	my ($k, $v) = each %$i;
  	if (ref $v) {
  	    return values %{ $i };
  	} else {
  	    return map { [ $_ ] } values %{ $i };
  	}
      } else {
  	return ( );
      }
  }
  
  sub _get_id_path {
      my $m = shift;
      my ($n, $f, $a, $i) = @$m;
      my $p = $i->{ $_[ 0 ] };
      defined $p ? ( ref $p eq 'ARRAY' ? @$p : $p ) : ( );
  }
  
  sub del_path {
      my $m = shift;
      my ($n, $f, $a, $i, $s, $p) = @$m;
      if (@_ == 2) {
  	@_ = sort @_ if ($f & _UNORD);
  	my $e0 = shift;
  	return 0 unless exists $s->{ $e0 };
  	my $e1 = shift;
  	if (defined($n = $s->{ $e0 }->{ $e1 })) {
  	    delete $i->{ $n };
              delete $s->{ $e0 }->{ $e1 };
              delete $p->{ $e1 }->{ $e0 };
  	    delete $s->{ $e0 } unless keys %{ $s->{ $e0 } };
  	    delete $p->{ $e1 } unless keys %{ $p->{ $e1 } };
  	    return 1;
  	}
      } else {
  	my $e = shift;
  	if (defined($n = $s->{ $e })) {
  	    delete $i->{ $n };
  	    delete $s->{ $e };
  	    return 1;
  	}
      }
      return 0;
  }
  
  sub __successors {
      my $E = shift;
      return wantarray ? () : 0 unless defined $E->[ _s ];
      my $g = shift;
      my $V = $g->[ _V ];
      return wantarray ? () : 0 unless defined $V && defined $V->[ _s ];
      # my $i = $V->_get_path_id( $_[0] );
      my $i =
  	($V->[ _f ] & _LIGHT) ?
  	    $V->[ _s ]->{ $_[0] } :
  	    $V->_get_path_id( $_[0] );
      return wantarray ? () : 0 unless defined $i && defined $E->[ _s ]->{ $i };
      return keys %{ $E->[ _s ]->{ $i } };
  }
  
  sub _successors {
      my $E = shift;
      my $g = shift;
      my @s = $E->__successors($g, @_);
      if (($E->[ _f ] & _UNORD)) {
  	push @s, $E->__predecessors($g, @_);
  	my %s; @s{ @s } = ();
  	@s = keys %s;
      }
      my $V = $g->[ _V ];
      return wantarray ? map { $V->[ _i ]->{ $_ } } @s : @s;
  }
  
  sub __predecessors {
      my $E = shift;
      return wantarray ? () : 0 unless defined $E->[ _p ];
      my $g = shift;
      my $V = $g->[ _V ];
      return wantarray ? () : 0 unless defined $V && defined $V->[ _s ];
      # my $i = $V->_get_path_id( $_[0] );
      my $i =
  	($V->[ _f ] & _LIGHT) ?
  	    $V->[ _s ]->{ $_[0] } :
  	    $V->_get_path_id( $_[0] );
      return wantarray ? () : 0 unless defined $i && defined $E->[ _p ]->{ $i };
      return keys %{ $E->[ _p ]->{ $i } };
  }
  
  sub _predecessors {
      my $E = shift;
      my $g = shift;
      my @p = $E->__predecessors($g, @_);
      if ($E->[ _f ] & _UNORD) {
  	push @p, $E->__successors($g, @_);
  	my %p; @p{ @p } = ();
  	@p = keys %p;
      }
      my $V = $g->[ _V ];
      return wantarray ? map { $V->[ _i ]->{ $_ } } @p : @p;
  }
  
  sub __attr {
      # Major magic takes place here: we rebless the appropriate 'light'
      # map into a more complex map and then redispatch the method.
      my $m = $_[0];
      my ($n, $f, $a, $i, $s, $p, $g) = @$m;
      my ($k, $v) = each %$i;
      my @V = @{ $g->[ _V ] };
      my @E = $g->edges; # TODO: Both these (ZZZ) lines are mysteriously needed!
      # ZZZ: an example of failing tests is t/52_edge_attributes.t.
      if (ref $v eq 'ARRAY') { # Edges, then.
  	# print "Reedging.\n";
  	@E = $g->edges; # TODO: Both these (ZZZ) lines are mysteriously needed!
  	$g->[ _E ] = $m = Graph::AdjacencyMap::Heavy->_new($f, 2);
  	$g->add_edges( @E );
      } else {
  	# print "Revertexing.\n";
  	$m = Graph::AdjacencyMap::Vertex->_new(($f & ~_LIGHT), 1);
  	$m->[ _n ] = $V[ _n ];
  	$m->[ _i ] = $V[ _i ];
  	$m->[ _s ] = $V[ _s ];
  	$m->[ _p ] = $V[ _p ];
  	$g->[ _V ] = $m;
      }
      $_[0] = $m;
      goto &{ ref($m) . "::__attr" }; # Redispatch.
  }
  
  sub _is_COUNT    () { 0 }
  sub _is_MULTI    () { 0 }
  sub _is_HYPER    () { 0 }
  sub _is_UNIQ     () { 0 }
  sub _is_REF      () { 0 }
  
  1;
GRAPH_ADJACENCYMAP_LIGHT

$fatpacked{"Graph/AdjacencyMap/Vertex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_ADJACENCYMAP_VERTEX';
  package Graph::AdjacencyMap::Vertex;
  
  # THIS IS INTERNAL IMPLEMENTATION ONLY, NOT TO BE USED DIRECTLY.
  # THE INTERFACE IS HARD TO USE AND GOING TO STAY THAT WAY AND
  # ALMOST GUARANTEED TO CHANGE OR GO AWAY IN FUTURE RELEASES.
  
  use strict;
  
  # $SIG{__DIE__ } = sub { use Carp; confess };
  # $SIG{__WARN__} = sub { use Carp; confess };
  
  use Graph::AdjacencyMap qw(:flags :fields);
  use base 'Graph::AdjacencyMap';
  
  use Scalar::Util qw(weaken);
  
  sub _new {
      my ($class, $flags, $arity) = @_;
      bless [ 0, $flags, $arity ], $class;
  }
  
  require overload; # for de-overloading
  
  sub __strval {
    my ($k, $f) = @_;
    ref $k && ($f & _REF) &&
      (($f & _STR) ? !overload::Method($k, '""') : overload::Method($k, '""')) ?
  	overload::StrVal($k) : $k;
  }
  
  sub __set_path {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      if (@_ != 1) {
  	require Carp;
  	Carp::confess(sprintf "Graph::AdjacencyMap::Vertex: arguments %d expected 1", scalar @_);
      }
      my $p;
      $p = $m->[ _s ] ||= { };
      my @p = $p;
      my @k;
      my $k = shift;
      my $q = __strval($k, $f);
      push @k, $q;
      return (\@p, \@k);
  }
  
  sub __set_path_node {
      my ($m, $p, $l) = splice @_, 0, 3;
      my $f = $m->[ _f ];
      my $id = pop if ($f & _MULTI);
      unless (exists $p->[-1]->{ $l }) {
  	my $i = $m->_new_node( \$p->[-1]->{ $l }, $id );
  	$m->[ _i ]->{ defined $i ? $i : "" } = $_[0];
      } else {
  	$m->_inc_node( \$p->[-1]->{ $l }, $id );
      }
  }
  
  sub set_path {
      my $m = shift;
      my $f = $m->[ _f ];
      my ($p, $k) = $m->__set_path( @_ );
      return unless defined $p && defined $k;
      my $l = defined $k->[-1] ? $k->[-1] : "";
      my $set = $m->__set_path_node( $p, $l, @_ );
      return $set;
  }
  
  sub __has_path {
      my $m = shift;
      my $f = $m->[ _f ];
      if (@_ != 1) {
  	require Carp;
  	Carp::confess(sprintf
  		      "Graph::AdjacencyMap: arguments %d expected 1\n",
  		      scalar @_);
      }
      my $p = $m->[ _s ];
      return unless defined $p;
      my @p = $p;
      my @k;
      my $k = shift;
      my $q = __strval($k, $f);
      push @k, $q;
      return (\@p, \@k);
  }
  
  sub has_path {
      my $m = shift;
      my ($p, $k) = $m->__has_path( @_ );
      return unless defined $p && defined $k;
      return exists $p->[-1]->{ defined $k->[-1] ? $k->[-1] : "" };
  }
  
  sub has_path_by_multi_id {
      my $m = shift;
      my $id = pop;
      my ($e, $n) = $m->__get_path_node( @_ );
      return undef unless $e;
      return exists $n->[ _nm ]->{ $id };
  }
  
  sub _get_path_id {
      my $m = shift;
      my $f = $m->[ _f ];
      my ($e, $n) = $m->__get_path_node( @_ );
      return undef unless $e;
      return ref $n ? $n->[ _ni ] : $n;
  }
  
  sub _get_path_count {
      my $m = shift;
      my $f = $m->[ _f ];
      my ($e, $n) = $m->__get_path_node( @_ );
      return 0 unless $e && defined $n;
      return
  	($f & _COUNT) ? $n->[ _nc ] :
  	($f & _MULTI) ? scalar keys %{ $n->[ _nm ] } : 1;
  }
  
  sub __attr {
      my $m = shift;
      if (@_ && ref $_[0] && @{ $_[0] } != $m->[ _a ]) {
  	require Carp;
  	Carp::confess(sprintf "Graph::AdjacencyMap::Vertex: arguments %d expected %d",
  		      scalar @{ $_[0] }, $m->[ _a ]);
      }
  }
  
  sub _get_id_path {
      my ($m, $i) = @_;
      return defined $m->[ _i ] ? $m->[ _i ]->{ $i } : undef;
  }
  
  sub del_path {
      my $m = shift;
      my $f = $m->[ _f ];
      my ($e, $n, $p, $k, $l) = $m->__get_path_node( @_ );
      return unless $e;
      my $c = ($f & _COUNT) ? --$n->[ _nc ] : 0;
      if ($c == 0) {
  	delete $m->[ _i ]->{ ref $n ? $n->[ _ni ] : $n };
  	delete $p->[ -1 ]->{ $l };
      }
      return 1;
  }
  
  sub del_path_by_multi_id {
      my $m = shift;
      my $f = $m->[ _f ];
      my $id = pop;
      my ($e, $n, $p, $k, $l) = $m->__get_path_node( @_ );
      return unless $e;
      delete $n->[ _nm ]->{ $id };
      unless (keys %{ $n->[ _nm ] }) {
  	delete $m->[ _i ]->{ $n->[ _ni ] };
  	delete $p->[-1]->{ $l };
      }
      return 1;
  }
  
  sub paths {
      my $m = shift;
      return map { [ $_ ] } values %{ $m->[ _i ] } if defined $m->[ _i ];
      wantarray ? ( ) : 0;
  }
  
  1;
  =pod
  
  =head1 NAME
  
  Graph::AdjacencyMap - create and a map of graph vertices or edges
  
  =head1 SYNOPSIS
  
      Internal.
  
  =head1 DESCRIPTION
  
  B<This module is meant for internal use by the Graph module.>
  
  =head2 Object Methods
  
  =over 4
  
  =item del_path(@id)
  
  Delete a Map path by ids.
  
  =item del_path_by_multi_id($id)
  
  Delete a Map path by a multi(vertex) id.
  
  =item has_path(@id)
  
  Return true if the Map has the path by ids, false if not.
  
  =item has_path_by_multi_id($id)
  
  Return true ifd the a Map has the path by a multi(vertex) id, false if not.
  
  =item paths
  
  Return all the paths of the Map.
  
  =item set_path(@id)
  
  Set the path by @ids.
  
  =back
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_ADJACENCYMAP_VERTEX

$fatpacked{"Graph/AdjacencyMatrix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_ADJACENCYMATRIX';
  package Graph::AdjacencyMatrix;
  
  use strict;
  
  use Graph::BitMatrix;
  use Graph::Matrix;
  
  use base 'Graph::BitMatrix';
  
  use Graph::AdjacencyMap qw(:flags :fields);
  
  sub _V () { 2 } # Graph::_V
  sub _E () { 3 } # Graph::_E
  
  sub new {
      my ($class, $g, %opt) = @_;
      my $n;
      my @V = $g->vertices;
      my $want_distance;
      if (exists $opt{distance_matrix}) {
  	$want_distance = $opt{distance_matrix};
  	delete $opt{distance_matrix};
      }
      my $d = Graph::_defattr();
      if (exists $opt{attribute_name}) {
  	$d = $opt{attribute_name};
  	$want_distance++;
      }
      delete $opt{attribute_name};
      my $want_transitive = 0;
      if (exists $opt{is_transitive}) {
  	$want_transitive = $opt{is_transitive};
  	delete $opt{is_transitive};
      }
      Graph::_opt_unknown(\%opt);
      if ($want_distance) {
  	$n = Graph::Matrix->new($g);
  	for my $v (@V) { $n->set($v, $v, 0) }
      }
      my $m = Graph::BitMatrix->new($g, connect_edges => $want_distance);
      if ($want_distance) {
  	# for my $u (@V) {
  	#     for my $v (@V) {
  	#         if ($g->has_edge($u, $v)) {
  	#             $n->set($u, $v,
  	#                    $g->get_edge_attribute($u, $v, $d));
          #        }
          #     }
          # }
  	my $Vi = $g->[_V]->[_i];
  	my $Ei = $g->[_E]->[_i];
  	my %V; @V{ @V } = 0 .. $#V;
  	my $n0 = $n->[0];
  	my $n1 = $n->[1];
  	if ($g->is_undirected) {
  	    for my $e (keys %{ $Ei }) {
  		my ($i0, $j0) = @{ $Ei->{ $e } };
  		my $i1 = $V{ $Vi->{ $i0 } };
  		my $j1 = $V{ $Vi->{ $j0 } };
  		my $u = $V[ $i1 ];
  		my $v = $V[ $j1 ];
  		$n0->[ $i1 ]->[ $j1 ] = 
  		    $g->get_edge_attribute($u, $v, $d);
  		$n0->[ $j1 ]->[ $i1 ] =
  		    $g->get_edge_attribute($v, $u, $d);
  	    }
  	} else {
  	    for my $e (keys %{ $Ei }) {
  		my ($i0, $j0) = @{ $Ei->{ $e } };
  		my $i1 = $V{ $Vi->{ $i0 } };
  		my $j1 = $V{ $Vi->{ $j0 } };
  		my $u = $V[ $i1 ];
  		my $v = $V[ $j1 ];
  		$n0->[ $i1 ]->[ $j1 ] =
  		    $g->get_edge_attribute($u, $v, $d);
  	    }
  	}
      }
      bless [ $m, $n, [ @V ] ], $class;
  }
  
  sub adjacency_matrix {
      my $am = shift;
      $am->[0];
  }
  
  sub distance_matrix {
      my $am = shift;
      $am->[1];
  }
  
  sub vertices {
      my $am = shift;
      @{ $am->[2] };
  }
  
  sub is_adjacent {
      my ($m, $u, $v) = @_;
      $m->[0]->get($u, $v) ? 1 : 0;
  }
  
  sub distance {
      my ($m, $u, $v) = @_;
      defined $m->[1] ? $m->[1]->get($u, $v) : undef;
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::AdjacencyMatrix - create and query the adjacency matrix of graph G
  
  =head1 SYNOPSIS
  
      use Graph::AdjacencyMatrix;
      use Graph::Directed; # or Undirected
  
      my $g  = Graph::Directed->new;
      $g->add_...(); # build $g
  
      my $am = Graph::AdjacencyMatrix->new($g);
      $am->is_adjacent($u, $v)
  
      my $am = Graph::AdjacencyMatrix->new($g, distance_matrix => 1);
      $am->distance($u, $v)
  
      my $am = Graph::AdjacencyMatrix->new($g, attribute_name => 'length');
      $am->distance($u, $v)
  
      my $am = Graph::AdjacencyMatrix->new($g, ...);
      my @V  = $am->vertices();
  
  =head1 DESCRIPTION
  
  You can use C<Graph::AdjacencyMatrix> to compute the adjacency matrix
  and optionally also the distance matrix of a graph, and after that
  query the adjacencyness between vertices by using the C<is_adjacent()>
  method, or query the distance between vertices by using the
  C<distance()> method.
  
  By default the edge attribute used for distance is C<w>, but you
  can change that in new(), see below.
  
  If you modify the graph after creating the adjacency matrix of it,
  the adjacency matrix and the distance matrix may become invalid.
  
  =head1 Methods
  
  =head2 Class Methods
  
  =over 4
  
  =item new($g)
  
  Construct the adjacency matrix of the graph $g.
  
  =item new($g, options)
  
  Construct the adjacency matrix of the graph $g with options as a hash.
  The known options are
  
  =over 8
  
  =item distance_matrix => boolean
  
  By default only the adjacency matrix is computed.  To compute also the
  distance matrix, use the attribute C<distance_matrix> with a true value
  to the new() constructor.
  
  =item attribute_name => attribute_name
  
  By default the edge attribute used for distance is C<w>.  You can
  change that by giving another attribute name with the C<attribute_name>
  attribute to new() constructor.  Using this attribute also implicitly
  causes the distance matrix to be computed.
  
  =back
  
  =back
  
  =head2 Object Methods
  
  =over 4
  
  =item is_adjacent($u, $v)
  
  Return true if the vertex $v is adjacent to vertex $u, or false if not.
  
  =item distance($u, $v)
  
  Return the distance between the vertices $u and $v, or C<undef> if
  the vertices are not adjacent.
  
  =item adjacency_matrix
  
  Return the adjacency matrix itself (a list of bitvector scalars).
  
  =item vertices
  
  Return the list of vertices (useful for indexing the adjacency matrix).
  
  =back
  
  =head1 ALGORITHM
  
  The algorithm used to create the matrix is two nested loops, which is
  O(V**2) in time, and the returned matrices are O(V**2) in space.
  
  =head1 SEE ALSO
  
  L<Graph::TransitiveClosure>, L<Graph::BitMatrix>
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_ADJACENCYMATRIX

$fatpacked{"Graph/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_ATTRIBUTE';
  package Graph::Attribute;
  
  use strict;
  
  sub _F () { 0 }
  sub _COMPAT02 () { 0x00000001 }
  
  sub import {
      my $package = shift;
      my %attr = @_;
      my $caller = caller(0);
      if (exists $attr{array}) {
  	my $i = $attr{array};
  	no strict 'refs';
  	*{"${caller}::_get_attributes"} = sub { $_[0]->[ $i ] };
  	*{"${caller}::_set_attributes"} =
  	    sub { $_[0]->[ $i ] ||= { };
  		  $_[0]->[ $i ] = $_[1] if @_ == 2;
  		  $_[0]->[ $i ] };
  	*{"${caller}::_has_attributes"} = sub { defined $_[0]->[ $i ] };
  	*{"${caller}::_delete_attributes"} = sub { undef $_[0]->[ $i ]; 1 };
      } elsif (exists $attr{hash}) {
  	my $k = $attr{hash};
  	no strict 'refs';
  	*{"${caller}::_get_attributes"} = sub { $_[0]->{ $k } };
  	*{"${caller}::_set_attributes"} =
  	    sub { $_[0]->{ $k } ||= { };
  		  $_[0]->{ $k } = $_[1] if @_ == 2;
  		  $_[0]->{ $k } };
  	*{"${caller}::_has_attributes"} = sub { defined $_[0]->{ $k } };
  	*{"${caller}::_delete_attributes"} = sub { delete $_[0]->{ $k } };
      } else {
  	die "Graph::Attribute::import($package @_) caller $caller\n";
      }
      my @api = qw(get_attribute
  		 get_attributes
  		 set_attribute
  		 set_attributes
  		 has_attribute
  		 has_attributes
  		 delete_attribute
  		 delete_attributes
  		 get_attribute_names
  		 get_attribute_values);
      if (exists $attr{map}) {
  	my $map = $attr{map};
  	for my $api (@api) {
  	    my ($first, $rest) = ($api =~ /^(\w+?)_(.+)/);
  	    no strict 'refs';
  	    *{"${caller}::${first}_${map}_${rest}"} = \&$api;
  	}
      }
  }
  
  sub set_attribute {
      my $g = shift;
      my $v = pop;
      my $a = pop;
      my $p = $g->_set_attributes;
      $p->{ $a } = $v;
      return 1;
  }
  
  sub set_attributes {
      my $g = shift;
      my $a = pop;
      my $p = $g->_set_attributes( $a );
      return 1;
  }
  
  sub has_attribute {
      my $g = shift;
      my $a = pop;
      my $p = $g->_get_attributes;
      $p ? exists $p->{ $a } : 0;
  }
  
  sub has_attributes {
      my $g = shift;
      $g->_get_attributes ? 1 : 0;
  }
  
  sub get_attribute {
      my $g = shift;
      my $a = pop;
      my $p = $g->_get_attributes;
      $p ? $p->{ $a } : undef;
  }
  
  sub delete_attribute {
      my $g = shift;
      my $a = pop;
      my $p = $g->_get_attributes;
      if (defined $p) {
  	delete $p->{ $a };
  	return 1;
      } else {
  	return 0;
      }
  }
  
  sub delete_attributes {
      my $g = shift;
      if ($g->_has_attributes) {
  	$g->_delete_attributes;
  	return 1;
      } else {
  	return 0;
      }
  }
  
  sub get_attribute_names {
      my $g = shift;
      my $p = $g->_get_attributes;
      defined $p ? keys %{ $p } : ( );
  }
  
  sub get_attribute_values {
      my $g = shift;
      my $p = $g->_get_attributes;
      defined $p ? values %{ $p } : ( );
  }
  
  sub get_attributes {
      my $g = shift;
      my $a = $g->_get_attributes;
      ($g->[ _F ] & _COMPAT02) ? (defined $a ? %{ $a } : ()) : $a;
  }
  
  1;
GRAPH_ATTRIBUTE

$fatpacked{"Graph/BitMatrix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_BITMATRIX';
  package Graph::BitMatrix;
  
  use strict;
  
  # $SIG{__DIE__ } = sub { use Carp; confess };
  # $SIG{__WARN__} = sub { use Carp; confess };
  
  sub _V () { 2 } # Graph::_V()
  sub _E () { 3 } # Graph::_E()
  sub _i () { 3 } # Index to path.
  sub _s () { 4 } # Successors / Path to Index.
  
  sub new {
      my ($class, $g, %opt) = @_;
      my @V = $g->vertices;
      my $V = @V;
      my $Z = "\0" x (($V + 7) / 8);
      my %V; @V{ @V } = 0 .. $#V;
      my $bm = bless [ [ ( $Z ) x $V ], \%V ], $class;
      my $bm0 = $bm->[0];
      my $connect_edges;
      if (exists $opt{connect_edges}) {
  	$connect_edges = $opt{connect_edges};
  	delete $opt{connect_edges};
      }
      $connect_edges = 1 unless defined $connect_edges;
      Graph::_opt_unknown(\%opt);
      if ($connect_edges) {
  	# for (my $i = 0; $i <= $#V; $i++) {
  	#    my $u = $V[$i];
  	#    for (my $j = 0; $j <= $#V; $j++) {
  	#	vec($bm0->[$i], $j, 1) = 1 if $g->has_edge($u, $V[$j]);
  	#    }
  	# }
  	my $Vi = $g->[_V]->[_i];
  	my $Ei = $g->[_E]->[_i];
  	if ($g->is_undirected) {
  	    for my $e (keys %{ $Ei }) {
  		my ($i0, $j0) = @{ $Ei->{ $e } };
  		my $i1 = $V{ $Vi->{ $i0 } };
  		my $j1 = $V{ $Vi->{ $j0 } };
  		vec($bm0->[$i1], $j1, 1) = 1;
  		vec($bm0->[$j1], $i1, 1) = 1;
  	    }
  	} else {
  	    for my $e (keys %{ $Ei }) {
  		my ($i0, $j0) = @{ $Ei->{ $e } };
  		vec($bm0->[$V{ $Vi->{ $i0 } }], $V{ $Vi->{ $j0 } }, 1) = 1;
  	    }
  	}
      }
      return $bm;
  }
  
  sub set {
      my ($m, $u, $v) = @_;
      my ($i, $j) = map { $m->[1]->{ $_ } } ($u, $v);
      vec($m->[0]->[$i], $j, 1) = 1 if defined $i && defined $j;
  }
  
  sub unset {
      my ($m, $u, $v) = @_;
      my ($i, $j) = map { $m->[1]->{ $_ } } ($u, $v);
      vec($m->[0]->[$i], $j, 1) = 0 if defined $i && defined $j;
  }
  
  sub get {
      my ($m, $u, $v) = @_;
      my ($i, $j) = map { $m->[1]->{ $_ } } ($u, $v);
      defined $i && defined $j ? vec($m->[0]->[$i], $j, 1) : undef;
  }
  
  sub set_row {
      my ($m, $u) = splice @_, 0, 2;
      my $m0 = $m->[0];
      my $m1 = $m->[1];
      my $i = $m1->{ $u };
      return unless defined $i;
      for my $v (@_) {
  	my $j = $m1->{ $v };
  	vec($m0->[$i], $j, 1) = 1 if defined $j;
      }
  }
  
  sub unset_row {
      my ($m, $u) = splice @_, 0, 2;
      my $m0 = $m->[0];
      my $m1 = $m->[1];
      my $i = $m1->{ $u };
      return unless defined $i;
      for my $v (@_) {
  	my $j = $m1->{ $v };
  	vec($m0->[$i], $j, 1) = 0 if defined $j;
      }
  }
  
  sub get_row {
      my ($m, $u) = splice @_, 0, 2;
      my $m0 = $m->[0];
      my $m1 = $m->[1];
      my $i = $m1->{ $u };
      return () x @_ unless defined $i;
      my @r;
      for my $v (@_) {
  	my $j = $m1->{ $v };
  	push @r, defined $j ? (vec($m0->[$i], $j, 1) ? 1 : 0) : undef;
      }
      return @r;
  }
  
  sub vertices {
      my ($m, $u, $v) = @_;
      keys %{ $m->[1] };
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::BitMatrix - create and manipulate a V x V bit matrix of graph G
  
  =head1 SYNOPSIS
  
      use Graph::BitMatrix;
      use Graph::Directed;
      my $g  = Graph::Directed->new;
      $g->add_...(); # build $g
      my $m = Graph::BitMatrix->new($g, %opt);
      $m->get($u, $v)
      $m->set($u, $v)
      $m->unset($u, $v)
      $m->get_row($u, $v1, $v2, ..., $vn)
      $m->set_row($u, $v1, $v2, ..., $vn)
      $m->unset_row($u, $v1, $v2, ..., $vn)
      $a->vertices()
  
  =head1 DESCRIPTION
  
  This class enables creating bit matrices that compactly describe
  the connected of the graphs.
  
  =head2 Class Methods
  
  =over 4
  
  =item new($g)
  
  Create a bit matrix from a Graph $g.  The C<%opt>, if present,
  can have the following options:
  
  =over 8
  
  =item *
  
  connect_edges
  
  If true or if not present, set the bits in the bit matrix that
  correspond to edges.  If false, do not set any bits.  In either
  case the bit matrix of V x V bits is allocated.
  
  =back
  
  =back
  
  =head2 Object Methods
  
  =over 4
  
  =item get($u, $v)
  
  Return true if the bit matrix has a "one bit" between the vertices
  $u and $v; in other words, if there is (at least one) a vertex going from
  $u to $v.  If there is no vertex and therefore a "zero bit", return false.
  
  =item set($u, $v)
  
  Set the bit between the vertices $u and $v; in other words, connect
  the vertices $u and $v by an edge.  The change does not get mirrored
  back to the original graph.  Returns nothing.
  
  =item unset($u, $v)
  
  Unset the bit between the vertices $u and $v; in other words, disconnect
  the vertices $u and $v by an edge.  The change does not get mirrored
  back to the original graph.  Returns nothing.
  
  =item get_row($u, $v1, $v2, ..., $vn)
  
  Test the row at vertex C<u> for the vertices C<v1>, C<v2>, ..., C<vn>
  Returns a list of I<n> truth values.
  
  =item set_row($u, $v1, $v2, ..., $vn)
  
  Sets the row at vertex C<u> for the vertices C<v1>, C<v2>, ..., C<vn>,
  in other words, connects the vertex C<u> to the vertices C<vi>.
  The changes do not get mirrored back to the original graph.
  Returns nothing.
  
  =item unset_row($u, $v1, $v2, ..., $vn)
  
  Unsets the row at vertex C<u> for the vertices C<v1>, C<v2>, ..., C<vn>,
  in other words, disconnects the vertex C<u> from the vertices C<vi>.
  The changes do not get mirrored back to the original graph.
  Returns nothing.
  
  =item vertices
  
  Return the list of vertices in the bit matrix.
  
  =back
  
  =head1 ALGORITHM
  
  The algorithm used to create the matrix is two nested loops, which is
  O(V**2) in time, and the returned matrices are O(V**2) in space.
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_BITMATRIX

$fatpacked{"Graph/Directed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_DIRECTED';
  package Graph::Directed;
  
  use Graph;
  use base 'Graph';
  use strict;
  
  =pod
  
  =head1 NAME
  
  Graph::Directed - directed graphs
  
  =head1 SYNOPSIS
  
      use Graph::Directed;
      my $g = Graph::Directed->new;
  
      # Or alternatively:
  
      use Graph;
      my $g = Graph->new(directed => 1);
      my $g = Graph->new(undirected => 0);
  
  =head1 DESCRIPTION
  
  Graph::Directed allows you to create directed graphs.
  
  For the available methods, see L<Graph>.
  
  =head1 SEE ALSO
  
  L<Graph>, L<Graph::Undirected>
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
  
  1;
GRAPH_DIRECTED

$fatpacked{"Graph/MSTHeapElem.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_MSTHEAPELEM';
  package Graph::MSTHeapElem;
  
  use strict;
  use vars qw($VERSION @ISA);
  use Heap071::Elem;
  
  use base 'Heap071::Elem';
  
  $VERSION = 0.01;
  
  sub new {
      my $class = shift;
      bless { u => $_[0], v => $_[1], w => $_[2] }, $class;
  }
  
  sub cmp {
      ($_[0]->{ w } || 0) <=> ($_[1]->{ w } || 0);
  }
  
  sub val {
      @{ $_[0] }{ qw(u v w) };
  }
  
  1;
GRAPH_MSTHEAPELEM

$fatpacked{"Graph/Matrix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_MATRIX';
  package Graph::Matrix;
  
  # $SIG{__DIE__ } = sub { use Carp; confess };
  # $SIG{__WARN__} = sub { use Carp; confess };
  
  use strict;
  
  sub new {
      my ($class, $g) = @_;
      my @V = $g->vertices;
      my $V = @V;
      my %V; @V{ @V } = 0 .. $#V;
      bless [ [ map { [ ] } 0 .. $#V ], \%V ], $class;
  }
  
  sub set {
      my ($m, $u, $v, $val) = @_;
      my ($i, $j) = map { $m->[1]->{ $_ } } ($u, $v);
      $m->[0]->[$i]->[$j] = $val;
  }
  
  sub get {
      my ($m, $u, $v) = @_;
      my ($i, $j) = map { $m->[1]->{ $_ } } ($u, $v);
      $m->[0]->[$i]->[$j];
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::Matrix - create and manipulate a V x V matrix of graph G
  
  =head1 SYNOPSIS
  
      use Graph::Matrix;
      use Graph::Directed;
      my $g  = Graph::Directed->new;
      $g->add_...(); # build $g
      my $m = Graph::Matrix->new($g);
      $m->get($u, $v)
      $s->get($u, $v, $val)
  
  =head1 DESCRIPTION
  
  B<This module is meant for internal use by the Graph module.>
  
  =head2 Class Methods
  
  =over 4
  
  =item new($g)
  
  Construct a new Matrix from the Graph $g.
  
  =back
  
  =head2 Object Methods
  
  =over 4
  
  =item get($u, $v)
  
  Return the value at the edge from $u to $v.
  
  =item set($u, $v, $val)
  
  Set the edge from $u to $v to value $val.
  
  =back
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_MATRIX

$fatpacked{"Graph/SPTHeapElem.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_SPTHEAPELEM';
  package Graph::SPTHeapElem;
  
  use strict;
  use vars qw($VERSION @ISA);
  use Heap071::Elem;
  
  use base 'Heap071::Elem';
  
  $VERSION = 0.01;
  
  sub new {
      my $class = shift;
      bless { u => $_[0], v => $_[1], w => $_[2] }, $class;
  }
  
  sub cmp {
      ($_[0]->{ w } || 0) <=> ($_[1]->{ w } || 0) ||
      ($_[0]->{ u } cmp $_[1]->{ u }) ||
      ($_[0]->{ u } cmp $_[1]->{ v });
  }
  
  sub val {
      @{ $_[0] }{ qw(u v w) };
  }
  
  1;
GRAPH_SPTHEAPELEM

$fatpacked{"Graph/TransitiveClosure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_TRANSITIVECLOSURE';
  package Graph::TransitiveClosure;
  
  use strict;
  
  # COMMENT THESE OUT FOR TESTING AND PRODUCTION.
  # $SIG{__DIE__ } = sub { use Carp; confess };
  # $SIG{__WARN__} = sub { use Carp; confess };
  
  use base 'Graph';
  use Graph::TransitiveClosure::Matrix;
  
  sub _G () { Graph::_G() }
  
  sub new {
      my ($class, $g, %opt) = @_;
      $g->expect_non_multiedged;
      %opt = (path_vertices => 1) unless %opt;
      my $attr = Graph::_defattr();
      if (exists $opt{ attribute_name }) {
  	$attr = $opt{ attribute_name };
  	# No delete $opt{ attribute_name } since we need to pass it on.
      }
      $opt{ reflexive } = 1 unless exists $opt{ reflexive };
      my $tcm = $g->new( $opt{ reflexive } ?
  		       ( vertices => [ $g->vertices ] ) : ( ) );
      my $tcg = $g->get_graph_attribute('_tcg');
      if (defined $tcg && $tcg->[ 0 ] == $g->[ _G ]) {
  	$tcg = $tcg->[ 1 ];
      } else {
  	$tcg = Graph::TransitiveClosure::Matrix->new($g, %opt);
  	$g->set_graph_attribute('_tcg', [ $g->[ _G ], $tcg ]);
      }
      my $tcg00 = $tcg->[0]->[0];
      my $tcg11 = $tcg->[1]->[1];
      for my $u ($tcg->vertices) {
  	my $tcg00i = $tcg00->[ $tcg11->{ $u } ];
  	for my $v ($tcg->vertices) {
  	    next if $u eq $v && ! $opt{ reflexive };
  	    my $j = $tcg11->{ $v };
  	    if (
  		# $tcg->is_transitive($u, $v)
  		# $tcg->[0]->get($u, $v)
  		vec($tcg00i, $j, 1)
  	       ) {
  		my $val = $g->_get_edge_attribute($u, $v, $attr);
  		$tcm->_set_edge_attribute($u, $v, $attr,
  					  defined $val ? $val :
  					  $u eq $v ?
  					  0 : 1);
  	    }
  	}
      }
      $tcm->set_graph_attribute('_tcm', $tcg);
      bless $tcm, $class;
  }
  
  sub is_transitive {
      my $g = shift;
      Graph::TransitiveClosure::Matrix::is_transitive($g);
  }
  
  1;
  __END__
  =pod
  
  Graph::TransitiveClosure - create and query transitive closure of graph
  
  =head1 SYNOPSIS
  
      use Graph::TransitiveClosure;
      use Graph::Directed; # or Undirected
  
      my $g  = Graph::Directed->new;
      $g->add_...(); # build $g
  
      # Compute the transitive closure graph.
      my $tcg = Graph::TransitiveClosure->new($g);
      $tcg->is_reachable($u, $v) # Identical to $tcg->has_edge($u, $v)
  
      # Being reflexive is the default, meaning that null transitions
      # (transitions from a vertex to the same vertex) are included.
      my $tcg = Graph::TransitiveClosure->new($g, reflexive => 1);
      my $tcg = Graph::TransitiveClosure->new($g, reflexive => 0);
  
      # is_reachable(u, v) is always reflexive.
      $tcg->is_reachable($u, $v)
  
      # The reflexivity of is_transitive(u, v) depends of the reflexivity
      # of the transitive closure.
      $tcg->is_transitive($u, $v)
  
      # You can check any graph for transitivity.
      $g->is_transitive()
  
      my $tcg = Graph::TransitiveClosure->new($g, path_length => 1);
      $tcg->path_length($u, $v)
  
      # path_vertices is automatically always on so this is a no-op.
      my $tcg = Graph::TransitiveClosure->new($g, path_vertices => 1);
      $tcg->path_vertices($u, $v)
  
      # Both path_length and path_vertices.
      my $tcg = Graph::TransitiveClosure->new($g, path => 1);
      $tcg->path_vertices($u, $v)
      $tcg->length($u, $v)
  
      my $tcg = Graph::TransitiveClosure->new($g, attribute_name => 'length');
      $tcg->path_length($u, $v)
  
  =head1 DESCRIPTION
  
  You can use C<Graph::TransitiveClosure> to compute the transitive
  closure graph of a graph and optionally also the minimum paths
  (lengths and vertices) between vertices, and after that query the
  transitiveness between vertices by using the C<is_reachable()> and
  C<is_transitive()> methods, and the paths by using the
  C<path_length()> and C<path_vertices()> methods.
  
  For further documentation, see the L<Graph::TransitiveClosure::Matrix>.
  
  =head2 Class Methods
  
  =over 4
  
  =item new($g, %opt)
  
  Construct a new transitive closure object.  Note that strictly speaking
  the returned object is not a graph; it is a graph plus other stuff.  But
  you should be able to use it as a graph plus a couple of methods inherited
  from the Graph::TransitiveClosure::Matrix class.
  
  =back
  
  =head2 Object Methods
  
  These are only the methods 'native' to the class: see
  L<Graph::TransitiveClosure::Matrix> for more.
  
  =over 4
  
  =item is_transitive($g)
  
  Return true if the Graph $g is transitive.
  
  =item transitive_closure_matrix
  
  Return the transitive closure matrix of the transitive closure object.
  
  =back
  
  =head2 INTERNALS
  
  The transitive closure matrix is stored as an attribute of the graph
  called C<_tcm>, and any methods not found in the graph class are searched
  in the transitive closure matrix class. 
  
  =cut
GRAPH_TRANSITIVECLOSURE

$fatpacked{"Graph/TransitiveClosure/Matrix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_TRANSITIVECLOSURE_MATRIX';
  package Graph::TransitiveClosure::Matrix;
  
  use strict;
  
  use Graph::AdjacencyMatrix;
  use Graph::Matrix;
  
  sub _new {
      my ($g, $class, $opt, $want_transitive, $want_reflexive, $want_path, $want_path_vertices) = @_;
      my $m = Graph::AdjacencyMatrix->new($g, %$opt);
      my @V = $g->vertices;
      my $am = $m->adjacency_matrix;
      my $dm; # The distance matrix.
      my $pm; # The predecessor matrix.
      my @di;
      my %di; @di{ @V } = 0..$#V;
      my @ai = @{ $am->[0] };
      my %ai = %{ $am->[1] };
      my @pi;
      my %pi;
      unless ($want_transitive) {
  	$dm = $m->distance_matrix;
  	@di = @{ $dm->[0] };
  	%di = %{ $dm->[1] };
  	$pm = Graph::Matrix->new($g);
  	@pi = @{ $pm->[0] };
  	%pi = %{ $pm->[1] };
  	for my $u (@V) {
  	    my $diu = $di{$u};
  	    my $aiu = $ai{$u};
  	    for my $v (@V) {
  		my $div = $di{$v};
  		my $aiv = $ai{$v};
  		next unless
  		    # $am->get($u, $v)
  		    vec($ai[$aiu], $aiv, 1)
  			;
  		# $dm->set($u, $v, $u eq $v ? 0 : 1)
  		$di[$diu]->[$div] = $u eq $v ? 0 : 1
  		    unless
  			defined
  			    # $dm->get($u, $v)
  			    $di[$diu]->[$div]
  			    ;
  		$pi[$diu]->[$div] = $v unless $u eq $v;
  	    }
  	}
      }
      # XXX (see the bits below): sometimes, being nice and clean is the
      # wrong thing to do.  In this case, using the public API for graph
      # transitive matrices and bitmatrices makes things awfully slow.
      # Instead, we go straight for the jugular of the data structures.
      for my $u (@V) {
  	my $diu = $di{$u};
  	my $aiu = $ai{$u};
  	my $didiu = $di[$diu];
  	my $aiaiu = $ai[$aiu];
  	for my $v (@V) {
  	    my $div = $di{$v};
  	    my $aiv = $ai{$v};
  	    my $didiv = $di[$div];
  	    my $aiaiv = $ai[$aiv];
  	    if (
  		# $am->get($v, $u)
  		vec($aiaiv, $aiu, 1)
  		|| ($want_reflexive && $u eq $v)) {
  		my $aivivo = $aiaiv;
  		if ($want_transitive) {
  		    if ($want_reflexive) {
  			for my $w (@V) {
  			    next if $w eq $u;
  			    my $aiw = $ai{$w};
  			    return 0
  				if  vec($aiaiu, $aiw, 1) &&
  				   !vec($aiaiv, $aiw, 1);
  			}
  			# See XXX above.
  			# for my $w (@V) {
  			#    my $aiw = $ai{$w};
  			#    if (
  			#	# $am->get($u, $w)
  			#	vec($aiaiu, $aiw, 1)
  			#	|| ($u eq $w)) {
  			#	return 0
  			#	    if $u ne $w &&
  			#		# !$am->get($v, $w)
  			#		!vec($aiaiv, $aiw, 1)
  			#		    ;
  			#	# $am->set($v, $w)
  			#	vec($aiaiv, $aiw, 1) = 1
  			#	    ;
  			#     }
  			# }
  		    } else {
  			# See XXX above.
  			# for my $w (@V) {
  			#     my $aiw = $ai{$w};
  			#     if (
  			#	# $am->get($u, $w)
  			#	vec($aiaiu, $aiw, 1)
  			#       ) {
  			#	return 0
  			#	    if $u ne $w &&
  			#		# !$am->get($v, $w)
  			#		!vec($aiaiv, $aiw, 1)
  			#		    ;
  			# 	# $am->set($v, $w)
  			# 	vec($aiaiv, $aiw, 1) = 1
  			# 	    ;
  			#     }
  			# }
  			$aiaiv |= $aiaiu;
  		    }
  		} else {
  		    if ($want_reflexive) {
  			$aiaiv |= $aiaiu;
  			vec($aiaiv, $aiu, 1) = 1;
  			# See XXX above.
  			# for my $w (@V) {
  			#     my $aiw = $ai{$w};
  			#     if (
  			# 	# $am->get($u, $w)
  			#	vec($aiaiu, $aiw, 1)
  			#	|| ($u eq $w)) {
  			#	# $am->set($v, $w)
  			#	vec($aiaiv, $aiw, 1) = 1
  			#	    ;
  			#     }
  			# }
  		    } else {
  			$aiaiv |= $aiaiu;
  			# See XXX above.
  			# for my $w (@V) {
  			#    my $aiw = $ai{$w};
  			#    if (
  			#	# $am->get($u, $w)
  			#	vec($aiaiu, $aiw, 1)
  			#       ) {
  			#	# $am->set($v, $w)
  			#	vec($aiaiv, $aiw, 1) = 1
  			#	    ;
  			#     }
  			# }
  		    }
  		}
  		if ($aiaiv ne $aivivo) {
  		    $ai[$aiv] = $aiaiv;
  		    $aiaiu = $aiaiv if $u eq $v;
  		}
  	    }
  	    if ($want_path && !$want_transitive) {
  		for my $w (@V) {
  		    my $aiw = $ai{$w};
  		    next unless
  			# See XXX above.
  			# $am->get($v, $u)
  			vec($aiaiv, $aiu, 1)
  			    &&
  			# See XXX above.
  			# $am->get($u, $w)
  			vec($aiaiu, $aiw, 1)
  			    ;
  		    my $diw = $di{$w};
  		    my ($d0, $d1a, $d1b);
  		    if (defined $dm) {
  			# See XXX above.
  			# $d0  = $dm->get($v, $w);
  			# $d1a = $dm->get($v, $u) || 1;
  			# $d1b = $dm->get($u, $w) || 1;
  			$d0  = $didiv->[$diw];
  			$d1a = $didiv->[$diu] || 1;
  			$d1b = $didiu->[$diw] || 1;
  		    } else {
  			$d1a = 1;
  			$d1b = 1;
  		    }
  		    my $d1 = $d1a + $d1b;
  		    if (!defined $d0 || ($d1 < $d0)) {
  			# print "d1 = $d1a ($v, $u) + $d1b ($u, $w) = $d1 ($v, $w) (".(defined$d0?$d0:"-").")\n";
  			# See XXX above.
  			# $dm->set($v, $w, $d1);
  			$didiv->[$diw] = $d1;
  			$pi[$div]->[$diw] = $pi[$div]->[$diu]
  			    if $want_path_vertices;
  		    }
  		}
  		# $dm->set($u, $v, 1)
  		$didiu->[$div] = 1
  		    if $u ne $v &&
  		       # $am->get($u, $v)
  		       vec($aiaiu, $aiv, 1)
  			   &&
  		       # !defined $dm->get($u, $v);
  		       !defined $didiu->[$div];
  	    }
  	}
      }
      return 1 if $want_transitive;
      my %V; @V{ @V } = @V;
      $am->[0] = \@ai;
      $am->[1] = \%ai;
      if (defined $dm) {
  	$dm->[0] = \@di;
  	$dm->[1] = \%di;
      }
      if (defined $pm) {
  	$pm->[0] = \@pi;
  	$pm->[1] = \%pi;
      }
      bless [ $am, $dm, $pm, \%V ], $class;
  }
  
  sub new {
      my ($class, $g, %opt) = @_;
      my %am_opt = (distance_matrix => 1);
      if (exists $opt{attribute_name}) {
  	$am_opt{attribute_name} = $opt{attribute_name};
  	delete $opt{attribute_name};
      }
      if ($opt{distance_matrix}) {
  	$am_opt{distance_matrix} = $opt{distance_matrix};
      }
      delete $opt{distance_matrix};
      if (exists $opt{path}) {
  	$opt{path_length}   = $opt{path};
  	$opt{path_vertices} = $opt{path};
  	delete $opt{path};
      }
      my $want_path_length;
      if (exists $opt{path_length}) {
  	$want_path_length = $opt{path_length};
  	delete $opt{path_length};
      }
      my $want_path_vertices;
      if (exists $opt{path_vertices}) {
  	$want_path_vertices = $opt{path_vertices};
  	delete $opt{path_vertices};
      }
      my $want_reflexive;
      if (exists $opt{reflexive}) {
  	$want_reflexive = $opt{reflexive};
  	delete $opt{reflexive};
      }
      my $want_transitive;
      if (exists $opt{is_transitive}) {
  	$want_transitive = $opt{is_transitive};
  	$am_opt{is_transitive} = $want_transitive;
  	delete $opt{is_transitive};
      }
      die "Graph::TransitiveClosure::Matrix::new: Unknown options: @{[map { qq['$_' => $opt{$_}]} keys %opt]}"
  	if keys %opt;
      $want_reflexive = 1 unless defined $want_reflexive;
      my $want_path = $want_path_length || $want_path_vertices;
      # $g->expect_dag if $want_path;
      _new($g, $class,
  	 \%am_opt,
  	 $want_transitive, $want_reflexive,
  	 $want_path, $want_path_vertices);
  }
  
  sub has_vertices {
      my $tc = shift;
      for my $v (@_) {
  	return 0 unless exists $tc->[3]->{ $v };
      }
      return 1;
  }
  
  sub is_reachable {
      my ($tc, $u, $v) = @_;
      return undef unless $tc->has_vertices($u, $v);
      return 1 if $u eq $v;
      $tc->[0]->get($u, $v);
  }
  
  sub is_transitive {
      if (@_ == 1) {	# Any graph.
  	__PACKAGE__->new($_[0], is_transitive => 1);	# Scary.
      } else {		# A TC graph.
  	my ($tc, $u, $v) = @_;
  	return undef unless $tc->has_vertices($u, $v);
  	$tc->[0]->get($u, $v);
      }
  }
  
  sub vertices {
      my $tc = shift;
      values %{ $tc->[3] };
  }
  
  sub path_length {
      my ($tc, $u, $v) = @_;
      return undef unless $tc->has_vertices($u, $v);
      return 0 if $u eq $v;
      $tc->[1]->get($u, $v);
  }
  
  sub path_predecessor {
      my ($tc, $u, $v) = @_;
      return undef if $u eq $v;
      return undef unless $tc->has_vertices($u, $v);
      $tc->[2]->get($u, $v);
  }
  
  sub path_vertices {
      my ($tc, $u, $v) = @_;
      return unless $tc->is_reachable($u, $v);
      return wantarray ? () : 0 if $u eq $v;
      my @v = ( $u );
      while ($u ne $v) {
  	last unless defined($u = $tc->path_predecessor($u, $v));
  	push @v, $u;
      }
      $tc->[2]->set($u, $v, [ @v ]) if @v;
      return @v;
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::TransitiveClosure::Matrix - create and query transitive closure of graph
  
  =head1 SYNOPSIS
  
      use Graph::TransitiveClosure::Matrix;
      use Graph::Directed; # or Undirected
  
      my $g  = Graph::Directed->new;
      $g->add_...(); # build $g
  
      # Compute the transitive closure matrix.
      my $tcm = Graph::TransitiveClosure::Matrix->new($g);
  
      # Being reflexive is the default,
      # meaning that null transitions are included.
      my $tcm = Graph::TransitiveClosure::Matrix->new($g, reflexive => 1);
      $tcm->is_reachable($u, $v)
  
      # is_reachable(u, v) is always reflexive.
      $tcm->is_reachable($u, $v)
  
      # The reflexivity of is_transitive(u, v) depends of the reflexivity
      # of the transitive closure.
      $tcg->is_transitive($u, $v)
  
      my $tcm = Graph::TransitiveClosure::Matrix->new($g, path_length => 1);
      my $n = $tcm->path_length($u, $v)
  
      my $tcm = Graph::TransitiveClosure::Matrix->new($g, path_vertices => 1);
      my @v = $tcm->path_vertices($u, $v)
  
      my $tcm =
          Graph::TransitiveClosure::Matrix->new($g,
                                                attribute_name => 'length');
      my $n = $tcm->path_length($u, $v)
  
      my @v = $tcm->vertices
  
  =head1 DESCRIPTION
  
  You can use C<Graph::TransitiveClosure::Matrix> to compute the
  transitive closure matrix of a graph and optionally also the minimum
  paths (lengths and vertices) between vertices, and after that query
  the transitiveness between vertices by using the C<is_reachable()> and
  C<is_transitive()> methods, and the paths by using the
  C<path_length()> and C<path_vertices()> methods.
  
  If you modify the graph after computing its transitive closure,
  the transitive closure and minimum paths may become invalid.
  
  =head1 Methods
  
  =head2 Class Methods
  
  =over 4
  
  =item new($g)
  
  Construct the transitive closure matrix of the graph $g.
  
  =item new($g, options)
  
  Construct the transitive closure matrix of the graph $g with options
  as a hash. The known options are
  
  =over 8
  
  =item C<attribute_name> => I<attribute_name>
  
  By default the edge attribute used for distance is C<w>.  You can
  change that by giving another attribute name with the C<attribute_name>
  attribute to the new() constructor.
  
  =item reflexive => boolean
  
  By default the transitive closure matrix is not reflexive: that is,
  the adjacency matrix has zeroes on the diagonal.  To have ones on
  the diagonal, use true for the C<reflexive> option.
  
  B<NOTE>: this behaviour has changed from Graph 0.2xxx: transitive
  closure graphs were by default reflexive.
  
  =item path_length => boolean
  
  By default the path lengths are not computed, only the boolean transitivity.
  By using true for C<path_length> also the path lengths will be computed,
  they can be retrieved using the path_length() method.
  
  =item path_vertices => boolean
  
  By default the paths are not computed, only the boolean transitivity.
  By using true for C<path_vertices> also the paths will be computed,
  they can be retrieved using the path_vertices() method.
  
  =back
  
  =back
  
  =head2 Object Methods
  
  =over 4
  
  =item is_reachable($u, $v)
  
  Return true if the vertex $v is reachable from the vertex $u,
  or false if not.
  
  =item path_length($u, $v)
  
  Return the minimum path length from the vertex $u to the vertex $v,
  or undef if there is no such path.
  
  =item path_vertices($u, $v)
  
  Return the minimum path (as a list of vertices) from the vertex $u to
  the vertex $v, or an empty list if there is no such path, OR also return
  an empty list if $u equals $v.
  
  =item has_vertices($u, $v, ...)
  
  Return true if the transitive closure matrix has all the listed vertices,
  false if not.
  
  =item is_transitive($u, $v)
  
  Return true if the vertex $v is transitively reachable from the vertex $u,
  false if not.
  
  =item vertices
  
  Return the list of vertices in the transitive closure matrix.
  
  =item path_predecessor
  
  Return the predecessor of vertex $v in the transitive closure path
  going back to vertex $u.
  
  =back
  
  =head1 RETURN VALUES
  
  For path_length() the return value will be the sum of the appropriate
  attributes on the edges of the path, C<weight> by default.  If no
  attribute has been set, one (1) will be assumed.
  
  If you try to ask about vertices not in the graph, undefs and empty
  lists will be returned.
  
  =head1 ALGORITHM
  
  The transitive closure algorithm used is Warshall and Floyd-Warshall
  for the minimum paths, which is O(V**3) in time, and the returned
  matrices are O(V**2) in space.
  
  =head1 SEE ALSO
  
  L<Graph::AdjacencyMatrix>
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_TRANSITIVECLOSURE_MATRIX

$fatpacked{"Graph/Traversal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_TRAVERSAL';
  package Graph::Traversal;
  
  use strict;
  
  # $SIG{__DIE__ } = sub { use Carp; confess };
  # $SIG{__WARN__} = sub { use Carp; confess };
  
  sub DEBUG () { 0 }
  
  sub reset {
      my $self = shift;
      $self->{ unseen } = { map { $_ => $_ } $self->{ graph }->vertices };
      $self->{ seen   } = { };
      $self->{ order     } = [ ];
      $self->{ preorder  } = [ ];
      $self->{ postorder } = [ ];
      $self->{ roots     } = [ ];
      $self->{ tree      } =
  	Graph->new( directed => $self->{ graph }->directed );
      delete $self->{ terminate };
  }
  
  my $see = sub {
      my $self = shift;
      $self->see;
  };
  
  my $see_active = sub {
      my $self = shift;
      delete @{ $self->{ active } }{ $self->see };
  };
  
  sub has_a_cycle {
      my ($u, $v, $t, $s) = @_;
      $s->{ has_a_cycle } = 1;
      $t->terminate;
  }
  
  sub find_a_cycle {
      my ($u, $v, $t, $s) = @_;
      my @cycle = ( $u );
      push @cycle, $v unless $u eq $v;
      my $path  = $t->{ order };
      if (@$path) {
  	my $i = $#$path;
  	while ($i >= 0 && $path->[ $i ] ne $v) { $i-- }
  	if ($i >= 0) {
  	    unshift @cycle, @{ $path }[ $i+1 .. $#$path ];
  	}
      }
      $s->{ a_cycle } = \@cycle;
      $t->terminate;
  }
  
  sub configure {
      my ($self, %attr) = @_;
      $self->{ pre  } = $attr{ pre }  if exists $attr{ pre  };
      $self->{ post } = $attr{ post } if exists $attr{ post };
      $self->{ pre_vertex  } = $attr{ pre_vertex }  if exists $attr{ pre_vertex  };
      $self->{ post_vertex } = $attr{ post_vertex } if exists $attr{ post_vertex };
      $self->{ pre_edge  } = $attr{ pre_edge  } if exists $attr{ pre_edge  };
      $self->{ post_edge } = $attr{ post_edge } if exists $attr{ post_edge };
      if (exists $attr{ successor }) { # Graph 0.201 compatibility.
  	$self->{ tree_edge } = $self->{ non_tree_edge } = $attr{ successor };
      }
      if (exists $attr{ unseen_successor }) {
  	if (exists $self->{ tree_edge }) { # Graph 0.201 compatibility.
  	    my $old_tree_edge = $self->{ tree_edge };
  	    $self->{ tree_edge } = sub {
  		$old_tree_edge->( @_ );
  		$attr{ unseen_successor }->( @_ );
  	    };
  	} else {
  	    $self->{ tree_edge } = $attr{ unseen_successor };
  	}
      }
      if ($self->graph->multiedged || $self->graph->countedged) {
  	$self->{ seen_edge } = $attr{ seen_edge } if exists $attr{ seen_edge };
  	if (exists $attr{ seen_successor }) { # Graph 0.201 compatibility.
  	    $self->{ seen_edge } = $attr{ seen_edge };
  	}
      }
      $self->{ non_tree_edge } = $attr{ non_tree_edge } if exists $attr{ non_tree_edge };
      $self->{ pre_edge  } = $attr{ tree_edge } if exists $attr{ tree_edge };
      $self->{ back_edge } = $attr{ back_edge } if exists $attr{ back_edge };
      $self->{ down_edge } = $attr{ down_edge } if exists $attr{ down_edge };
      $self->{ cross_edge } = $attr{ cross_edge } if exists $attr{ cross_edge };
      if (exists $attr{ start }) {
  	$attr{ first_root } = $attr{ start };
  	$attr{ next_root  } = undef;
      }
      if (exists $attr{ get_next_root }) {
  	$attr{ next_root  } = $attr{ get_next_root }; # Graph 0.201 compat.
      }
      $self->{ next_root } =
  	exists $attr{ next_root } ?
  	    $attr{ next_root } :
  		$attr{ next_alphabetic } ?
  		    \&Graph::_next_alphabetic :
  			$attr{ next_numeric } ?
  			    \&Graph::_next_numeric :
  				\&Graph::_next_random;
      $self->{ first_root } =
  	exists $attr{ first_root } ?
  	    $attr{ first_root } :
  		exists $attr{ next_root } ?
  		    $attr{ next_root } :
  			$attr{ next_alphabetic } ?
  			    \&Graph::_next_alphabetic :
  				$attr{ next_numeric } ?
  				    \&Graph::_next_numeric :
  					\&Graph::_next_random;
      $self->{ next_successor } =
  	exists $attr{ next_successor } ?
  	    $attr{ next_successor } :
  		$attr{ next_alphabetic } ?
  		    \&Graph::_next_alphabetic :
  			$attr{ next_numeric } ?
  			    \&Graph::_next_numeric :
  				\&Graph::_next_random;
      if (exists $attr{ has_a_cycle }) {
  	my $has_a_cycle =
  	    ref $attr{ has_a_cycle } eq 'CODE' ?
  		$attr{ has_a_cycle } : \&has_a_cycle;
  	$self->{ back_edge } = $has_a_cycle;
  	if ($self->{ graph }->is_undirected) {
  	    $self->{ down_edge } = $has_a_cycle;
  	}
      }
      if (exists $attr{ find_a_cycle }) {
  	my $find_a_cycle =
  	    ref $attr{ find_a_cycle } eq 'CODE' ?
  		$attr{ find_a_cycle } : \&find_a_cycle;
  	$self->{ back_edge } = $find_a_cycle;
  	if ($self->{ graph }->is_undirected) {
  	    $self->{ down_edge } = $find_a_cycle;
  	}
      }
      $self->{ add } = \&add_order;
      $self->{ see } = $see;
      delete @attr{ qw(
  		     pre post pre_edge post_edge
  		     successor unseen_successor seen_successor
  		     tree_edge non_tree_edge
  		     back_edge down_edge cross_edge seen_edge
  		     start get_next_root
  		     next_root next_alphabetic next_numeric next_random next_successor
  		     first_root
  		     has_a_cycle find_a_cycle
  		    ) };
      if (keys %attr) {
  	require Carp;
  	my @attr = sort keys %attr;
  	Carp::croak(sprintf "Graph::Traversal: unknown attribute%s @{[map { qq['$_'] } @attr]}\n", @attr == 1 ? '' : 's');
      }
  }
  
  sub new {
      my $class = shift;
      my $g = shift;
      unless (ref $g && $g->isa('Graph')) {
  	require Carp;
  	Carp::croak("Graph::Traversal: first argument is not a Graph");
      }
      my $self = { graph => $g, state => { } };
      bless $self, $class;
      $self->reset;
      $self->configure( @_ );
      return $self;
  }
  
  sub terminate {
      my $self = shift;
      $self->{ terminate } = 1;
  }
  
  sub add_order {
      my ($self, @next) = @_;
      push @{ $self->{ order } }, @next;
  }
  
  sub visit {
      my ($self, @next) = @_;
      delete @{ $self->{ unseen } }{ @next };
      print "unseen = @{[sort keys %{$self->{unseen}}]}\n" if DEBUG;
      @{ $self->{ seen } }{ @next } = @next;
      print "seen = @{[sort keys %{$self->{seen}}]}\n" if DEBUG;
      $self->{ add }->( $self, @next );
      print "order = @{$self->{order}}\n" if DEBUG;
      if (exists $self->{ pre }) {
  	my $p = $self->{ pre };
  	for my $v (@next) {
  	    $p->( $v, $self );
  	}
      }
  }
  
  sub visit_preorder {
      my ($self, @next) = @_;
      push @{ $self->{ preorder } }, @next;
      for my $v (@next) {
  	$self->{ preordern }->{ $v } = $self->{ preorderi }++;
      }
      print "preorder = @{$self->{preorder}}\n" if DEBUG;
      $self->visit( @next );
  }
  
  sub visit_postorder {
      my ($self) = @_;
      my @post = reverse $self->{ see }->( $self );
      push @{ $self->{ postorder } }, @post;
      for my $v (@post) {
  	$self->{ postordern }->{ $v } = $self->{ postorderi }++;
      }
      print "postorder = @{$self->{postorder}}\n" if DEBUG;
      if (exists $self->{ post }) {
  	my $p = $self->{ post };
  	for my $v (@post) {
  	    $p->( $v, $self ) ;
  	}
      }
      if (exists $self->{ post_edge }) {
  	my $p = $self->{ post_edge };
  	my $u = $self->current;
  	if (defined $u) {
  	    for my $v (@post) {
  		$p->( $u, $v, $self, $self->{ state });
  	    }
  	}
      }
  }
  
  sub _callbacks {
      my ($self, $current, @all) = @_;
      return unless @all;
      my $nontree  = $self->{ non_tree_edge };
      my $back     = $self->{ back_edge };
      my $down     = $self->{ down_edge };
      my $cross    = $self->{ cross_edge };
      my $seen     = $self->{ seen_edge };
      my $bdc = defined $back || defined $down || defined $cross;
      if (defined $nontree || $bdc || defined $seen) {
  	my $u = $current;
  	my $preu  = $self->{ preordern  }->{ $u };
  	my $postu = $self->{ postordern }->{ $u };
  	for my $v ( @all ) {
  	    my $e = $self->{ tree }->has_edge( $u, $v );
  	    if ( !$e && (defined $nontree || $bdc) ) {
  		if ( exists $self->{ seen }->{ $v }) {
  		    $nontree->( $u, $v, $self, $self->{ state })
  			if $nontree;
  		    if ($bdc) {
  			my $postv = $self->{ postordern }->{ $v };
  			if ($back &&
  			    (!defined $postv || $postv >= $postu)) {
  			    $back ->( $u, $v, $self, $self->{ state });
  			} else {
  			    my $prev = $self->{ preordern }->{ $v };
  			    if ($down && $prev > $preu) {
  				$down ->( $u, $v, $self, $self->{ state });
  			    } elsif ($cross && $prev < $preu) {
  				$cross->( $u, $v, $self, $self->{ state });
  			    }
  			}
  		    }
  		}
  	    }
  	    if ($seen) {
  		my $c = $self->graph->get_edge_count($u, $v);
  		while ($c-- > 1) {
  		    $seen->( $u, $v, $self, $self->{ state } );
  		}
  	    }
  	}
      }
  }
  
  sub next {
      my $self = shift;
      return undef if $self->{ terminate };
      my @next;
      while ($self->seeing) {
  	my $current = $self->current;
  	print "current = $current\n" if DEBUG;
  	@next = $self->{ graph }->successors( $current );
  	print "next.0 - @next\n" if DEBUG;
  	my %next; @next{ @next } = @next;
  	print "next.1 - @next\n" if DEBUG;
  	@next = keys %next;
  	my @all = @next;
  	print "all = @all\n" if DEBUG;
  	for my $s (keys %next) {
  	    delete $next{$s} if exists $self->{seen}->{$s};
  	}
  	@next = keys %next;
  	print "next.2 - @next\n" if DEBUG;
  	if (@next) {
  	    @next = $self->{ next_successor }->( $self, \%next );
  	    print "next.3 - @next\n" if DEBUG;
  	    for my $v (@next) {
  		$self->{ tree }->add_edge( $current, $v );
  	    }
  	    if (exists $self->{ pre_edge }) {
  		my $p = $self->{ pre_edge };
  		my $u = $self->current;
  		for my $v (@next) {
  		    $p->( $u, $v, $self, $self->{ state });
  		}
  	    }
  	    last;
  	} else {
  	    $self->visit_postorder;
  	}
  	return undef if $self->{ terminate };
  	$self->_callbacks($current, @all);
      }
      print "next.4 - @next\n" if DEBUG;
      unless (@next) {
  	unless ( @{ $self->{ roots } } ) {
  	    my $first = $self->{ first_root };
  	    if (defined $first) {
  		@next =
  		    ref $first eq 'CODE' ? 
  			$self->{ first_root }->( $self, $self->{ unseen } ) :
  			$first;
  		return unless @next;
  	    }
  	}
  	unless (@next) {
  	    return unless defined $self->{ next_root };
  	    return unless @next =
  		$self->{ next_root }->( $self, $self->{ unseen } );
  	}
  	return if exists $self->{ seen }->{ $next[0] }; # Sanity check.
  	print "next.5 - @next\n" if DEBUG;
  	push @{ $self->{ roots } }, $next[0];
      }
      print "next.6 - @next\n" if DEBUG;
      if (@next) {
  	$self->visit_preorder( @next );
      }
      return $next[0];
  }
  
  sub _order {
      my ($self, $order) = @_;
      1 while defined $self->next;
      my $wantarray = wantarray;
      if ($wantarray) {
  	@{ $self->{ $order } };
      } elsif (defined $wantarray) {
  	shift @{ $self->{ $order } };
      }
  }
  
  sub preorder {
      my $self = shift;
      $self->_order( 'preorder' );
  }
  
  sub postorder {
      my $self = shift;
      $self->_order( 'postorder' );
  }
  
  sub unseen {
      my $self = shift;
      values %{ $self->{ unseen } };
  }
  
  sub seen {
      my $self = shift;
      values %{ $self->{ seen } };
  }
  
  sub seeing {
      my $self = shift;
      @{ $self->{ order } };
  }
  
  sub roots {
      my $self = shift;
      @{ $self->{ roots } };
  }
  
  sub is_root {
      my ($self, $v) = @_;
      for my $u (@{ $self->{ roots } }) {
  	return 1 if $u eq $v;
      }
      return 0;
  }
  
  sub tree {
      my $self = shift;
      $self->{ tree };
  }
  
  sub graph {
      my $self = shift;
      $self->{ graph };
  }
  
  sub vertex_by_postorder {
      my ($self, $i) = @_;
      exists $self->{ postorder } && $self->{ postorder }->[ $i ];
  }
  
  sub postorder_by_vertex {
      my ($self, $v) = @_;
      exists $self->{ postordern } && $self->{ postordern }->{ $v };
  }
  
  sub postorder_vertices {
      my ($self, $v) = @_;
      exists $self->{ postordern } ? %{ $self->{ postordern } } : ();
  }
  
  sub vertex_by_preorder {
      my ($self, $i) = @_;
      exists $self->{ preorder } && $self->{ preorder }->[ $i ];
  }
  
  sub preorder_by_vertex {
      my ($self, $v) = @_;
      exists $self->{ preordern } && $self->{ preordern }->{ $v };
  }
  
  sub preorder_vertices {
      my ($self, $v) = @_;
      exists $self->{ preordern } ? %{ $self->{ preordern } } : ();
  }
  
  sub has_state {
      my ($self, $var) = @_;
      exists $self->{ state } && exists $self->{ state }->{ $var };
  }
  
  sub get_state {
      my ($self, $var) = @_;
      exists $self->{ state } ? $self->{ state }->{ $var } : undef;
  }
  
  sub set_state {
      my ($self, $var, $val) = @_;
      $self->{ state }->{ $var } = $val;
      return 1;
  }
  
  sub delete_state {
      my ($self, $var) = @_;
      delete $self->{ state }->{ $var };
      delete $self->{ state } unless keys %{ $self->{ state } };
      return 1;
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::Traversal - traverse graphs
  
  =head1 SYNOPSIS
  
  Don't use Graph::Traversal directly, use Graph::Traversal::DFS
  or Graph::Traversal::BFS instead.
  
      use Graph;
      my $g = Graph->new;
      $g->add_edge(...);
      use Graph::Traversal::...;
      my $t = Graph::Traversal::...->new($g, %opt);
      $t->...
  
  =head1 DESCRIPTION
  
  You can control how the graph is traversed by the various callback
  parameters in the C<%opt>.  In the parameters descriptions below the
  $u and $v are vertices, and the $self is the traversal object itself.
  
  =head2 Callback parameters
  
  The following callback parameters are available:
  
  =over 4
  
  =item tree_edge
  
  Called when traversing an edge that belongs to the traversal tree.
  Called with arguments ($u, $v, $self).
  
  =item non_tree_edge
  
  Called when an edge is met which either leads back to the traversal tree
  (either a C<back_edge>, a C<down_edge>, or a C<cross_edge>).
  Called with arguments ($u, $v, $self).
  
  =item pre_edge
  
  Called for edges in preorder.
  Called with arguments ($u, $v, $self).
  
  =item post_edge
  
  Called for edges in postorder.
  Called with arguments ($u, $v, $self).
  
  =item back_edge
  
  Called for back edges.
  Called with arguments ($u, $v, $self).
  
  =item down_edge
  
  Called for down edges.
  Called with arguments ($u, $v, $self).
  
  =item cross_edge
  
  Called for cross edges.
  Called with arguments ($u, $v, $self).
  
  =item pre
  
  =item pre_vertex
  
  Called for vertices in preorder.
  Called with arguments ($v, $self).
  
  =item post
  
  =item post_vertex
  
  Called for vertices in postorder.
  Called with arguments ($v, $self).
  
  =item first_root
  
  Called when choosing the first root (start) vertex for traversal.
  Called with arguments ($self, $unseen) where $unseen is a hash
  reference with the unseen vertices as keys.
  
  =item next_root
  
  Called when choosing the next root (after the first one) vertex for
  traversal (useful when the graph is not connected).  Called with
  arguments ($self, $unseen) where $unseen is a hash reference with
  the unseen vertices as keys.  If you want only the first reachable
  subgraph to be processed, set the next_root to C<undef>.
  
  =item start
  
  Identical to defining C<first_root> and undefining C<next_root>.
  
  =item next_alphabetic
  
  Set this to true if you want the vertices to be processed in
  alphabetic order (and leave first_root/next_root undefined).
  
  =item next_numeric
  
  Set this to true if you want the vertices to be processed in
  numeric order (and leave first_root/next_root undefined).
  
  =item next_successor
  
  Called when choosing the next vertex to visit.  Called with arguments
  ($self, $next) where $next is a hash reference with the possible
  next vertices as keys.  Use this to provide a custom ordering for
  choosing vertices, as opposed to C<next_numeric> or C<next_alphabetic>.
  
  =back
  
  The parameters C<first_root> and C<next_successor> have a 'hierarchy'
  of how they are determined: if they have been explicitly defined, use
  that value.  If not, use the value of C<next_alphabetic>, if that has
  been defined.  If not, use the value of C<next_numeric>, if that has
  been defined.  If not, the next vertex to be visited is chose randomly.
  
  =head2 Methods
  
  The following methods are available:
  
  =over 4
  
  =item unseen
  
  Return the unseen vertices in random order.
  
  =item seen
  
  Return the seen vertices in random order.
  
  =item seeing
  
  Return the active fringe vertices in random order.
  
  =item preorder
  
  Return the vertices in preorder traversal order.
  
  =item postorder
  
  Return the vertices in postorder traversal order.
  
  =item vertex_by_preorder
  
      $v = $t->vertex_by_preorder($i)
  
  Return the ith (0..$V-1) vertex by preorder.
  
  =item preorder_by_vertex
  
      $i = $t->preorder_by_vertex($v)
  
  Return the preorder index (0..$V-1) by vertex.
  
  =item vertex_by_postorder
  
      $v = $t->vertex_by_postorder($i)
  
  Return the ith (0..$V-1) vertex by postorder.
  
  =item postorder_by_vertex
  
      $i = $t->postorder_by_vertex($v)
  
  Return the postorder index (0..$V-1) by vertex.
  
  =item preorder_vertices
  
  Return a hash with the vertices as the keys and their preorder indices
  as the values.
  
  =item postorder_vertices
  
  Return a hash with the vertices as the keys and their postorder
  indices as the values.
  
  =item tree
  
  Return the traversal tree as a graph.
  
  =item has_state
  
      $t->has_state('s')
  
  Test whether the traversal has state 's' attached to it.
  
  =item get_state
  
      $t->get_state('s')
  
  Get the state 's' attached to the traversal (C<undef> if none).
  
  =item set_state
  
      $t->set_state('s', $s)
  
  Set the state 's' attached to the traversal.
  
  =item delete_state
  
      $t->delete_state('s')
  
  Delete the state 's' from the traversal.
  
  =back
  
  =head2 Backward compatibility
  
  The following parameters are for backward compatibility to Graph 0.2xx:
  
  =over 4
  
  =item get_next_root
  
  Like C<next_root>.
  
  =item successor
  
  Identical to having C<tree_edge> both C<non_tree_edge> defined
  to be the same.
  
  =item unseen_successor
  
  Like C<tree_edge>.
  
  =item seen_successor
  
  Like C<seed_edge>.
  
  =back
  
  =head2 Special callbacks
  
  If in a callback you call the special C<terminate> method,
  the traversal is terminated, no more vertices are traversed.
  
  =head1 SEE ALSO
  
  L<Graph::Traversal::DFS>, L<Graph::Traversal::BFS>
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
GRAPH_TRAVERSAL

$fatpacked{"Graph/Traversal/BFS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_TRAVERSAL_BFS';
  package Graph::Traversal::BFS;
  
  use strict;
  
  use Graph::Traversal;
  use base 'Graph::Traversal';
  
  sub current {
      my $self = shift;
      $self->{ order }->[ 0 ];
  }
  
  sub see {
      my $self = shift;
      shift @{ $self->{ order } };
  }
  
  *bfs = \&Graph::Traversal::postorder;
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::Traversal::BFS - breadth-first traversal of graphs
  
  =head1 SYNOPSIS
  
      use Graph;
      my $g = Graph->new;
      $g->add_edge(...);
      use Graph::Traversal::BFS;
      my $b = Graph::Traversal::BFS->new($g, %opt);
      $b->bfs; # Do the traversal.
  
  =head1 DESCRIPTION
  
  With this class one can traverse a Graph in breadth-first order.
  
  The callback parameters %opt are explained in L<Graph::Traversal>.
  
  =head2 Methods
  
  The following methods are available:
  
  =over 4
  
  =item bfs
  
  Traverse the graph in breadth-first order.  Returns all vertices
  traversed in post-order.
  
  =back
  
  =head1 SEE ALSO
  
  L<Graph::Traversal>, L<Graph::Traversal::DFS>, L<Graph>.
  
  =cut
GRAPH_TRAVERSAL_BFS

$fatpacked{"Graph/Traversal/DFS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_TRAVERSAL_DFS';
  package Graph::Traversal::DFS;
  
  use strict;
  
  use Graph::Traversal;
  use base 'Graph::Traversal';
  
  sub current {
      my $self = shift;
      $self->{ order }->[ -1 ];
  }
  
  sub see {
      my $self = shift;
      pop @{ $self->{ order } };
  }
  
  *dfs = \&Graph::Traversal::postorder;
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::Traversal::DFS - depth-first traversal of graphs
  
  =head1 SYNOPSIS
  
      use Graph;
      my $g = Graph->new;
      $g->add_edge(...);
      use Graph::Traversal::DFS;
      my $d = Graph::Traversal::DFS->new($g, %opt);
      $d->dfs; # Do the traversal.
  
  =head1 DESCRIPTION
  
  With this class one can traverse a Graph in depth-first order.
  
  The callback parameters %opt are explained in L<Graph::Traversal>.
  
  =head2 Methods
  
  The following methods are available:
  
  =over 4
  
  =item dfs
  
  Traverse the graph in depth-first order.  Returns all vertices
  traversed in post-order.
  
  =back
  
  =head1 SEE ALSO
  
  L<Graph::Traversal>, L<Graph::Traversal::BFS>, L<Graph>.
  
  =cut
GRAPH_TRAVERSAL_DFS

$fatpacked{"Graph/Undirected.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_UNDIRECTED';
  package Graph::Undirected;
  
  use Graph;
  use base 'Graph';
  use strict;
  
  =pod
  
  =head1 NAME
  
  Graph::Undirected - undirected graphs
  
  =head1 SYNOPSIS
  
      use Graph::Undirected;
      my $g = Graph::Undirected->new;
  
      # Or alternatively:
  
      use Graph;
      my $g = Graph->new(undirected => 1);
      my $g = Graph->new(directed => 0);
  
  =head1 DESCRIPTION
  
  Graph::Undirected allows you to create undirected graphs.
  
  For the available methods, see L<Graph>.
  
  =head1 SEE ALSO
  
  L<Graph>, L<Graph::Directed>
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
  
  sub new {
      my $class = shift;
      bless Graph->new(undirected => 1, @_), ref $class || $class;
  }
  
  1;
GRAPH_UNDIRECTED

$fatpacked{"Graph/UnionFind.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRAPH_UNIONFIND';
  package Graph::UnionFind;
  
  use strict;
  
  sub _PARENT  () { 0 }
  sub _RANK    () { 1 }
  
  sub new {
      my $class = shift;
      bless { }, $class;
  }
  
  sub add {
      my ($self, $elem) = @_;
      $self->{ $elem } = [ $elem, 0 ] unless defined $self->{$elem};
  }
  
  sub has {
      my ($self, $elem) = @_;
      exists $self->{ $elem };
  }
  
  sub _parent {
      return undef unless defined $_[1];
      if (@_ == 2) {
  	exists $_[0]->{ $_[ 1 ] } ? $_[0]->{ $_[1] }->[ _PARENT ] : undef;
      } elsif (@_ == 3) {
  	$_[0]->{ $_[1] }->[ _PARENT ] = $_[2];
      } else {
  	require Carp;
  	Carp::croak(__PACKAGE__ . "::_parent: bad arity");
      }
  }
  
  sub _rank {
      return unless defined $_[1];
      if (@_ == 2) {
  	exists $_[0]->{ $_[1] } ? $_[0]->{ $_[1] }->[ _RANK ] : undef;
      } elsif (@_ == 3) {
  	$_[0]->{ $_[1] }->[ _RANK ] = $_[2];
      } else {
  	require Carp;
  	Carp::croak(__PACKAGE__ . "::_rank: bad arity");
      }
  }
  
  sub find {
      my ($self, $x) = @_;
      my $px = $self->_parent( $x );
      return unless defined $px;
      $self->_parent( $x, $self->find( $px ) ) if $px ne $x;
      $self->_parent( $x );
  }
  
  sub union {
      my ($self, $x, $y) = @_;
      $self->add($x) unless $self->has($x);
      $self->add($y) unless $self->has($y);
      my $px = $self->find( $x );
      my $py = $self->find( $y );
      return if $px eq $py;
      my $rx = $self->_rank( $px );
      my $ry = $self->_rank( $py );
      # print "union($x, $y): px = $px, py = $py, rx = $rx, ry = $ry\n";
      if ( $rx > $ry ) {
  	$self->_parent( $py, $px );
      } else {
  	$self->_parent( $px, $py );
  	$self->_rank( $py, $ry + 1 ) if $rx == $ry;
      }
  }
  
  sub same {
      my ($uf, $u, $v) = @_;
      my $fu = $uf->find($u);
      return undef unless defined $fu;
      my $fv = $uf->find($v);
      return undef unless defined $fv;
      $fu eq $fv;
  }
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  Graph::UnionFind - union-find data structures
  
  =head1 SYNOPSIS
  
      use Graph::UnionFind;
      my $uf = Graph::UnionFind->new;
  
      # Add the vertices to the data structure.
      $uf->add($u);
      $uf->add($v);
  
      # Join the partitions of the vertices.
      $uf->union( $u, $v );
  
      # Find the partitions the vertices belong to
      # in the union-find data structure.  If they
      # are equal, they are in the same partition.
      # If the vertex has not been seen,
      # undef is returned.
      my $pu = $uf->find( $u );
      my $pv = $uf->find( $v );
      $uf->same($u, $v) # Equal to $pu eq $pv. 
  
      # Has the union-find seen this vertex?
      $uf->has( $v )
  
  =head1 DESCRIPTION
  
  I<Union-find> is a special data structure that can be used to track the
  partitioning of a set into subsets (a problem known also as I<disjoint sets>).
  
  Graph::UnionFind() is used for Graph::connected_components(),
  Graph::connected_component(), and Graph::same_connected_components()
  if you specify a true C<union_find> parameter when you create an undirected
  graph.
  
  Note that union-find is one way: you cannot (easily) 'ununion'
  vertices once you have 'unioned' them.  This means that if you
  delete edges from a C<union_find> graph, you will get wrong results
  from the Graph::connected_components(), Graph::connected_component(),
  and Graph::same_connected_components().
  
  =head2 API
  
  =over 4
  
  =item add
  
      $uf->add($v)
  
  Add the vertex v to the union-find.
  
  =item union
  
      $uf->union($u, $v)
  
  Add the edge u-v to the union-find.  Also implicitly adds the vertices.
  
  =item has
  
      $uf->has($v)
  
  Return true if the vertex v has been added to the union-find, false otherwise.
  
  =item find
  
      $uf->find($v)
  
  Return the union-find partition the vertex v belongs to,
  or C<undef> if it has not been added.
  
  =item new
  
      $uf = Graph::UnionFind->new()
  
  The constructor.
  
  =item same
  
      $uf->same($u, $v)
  
  Return true of the vertices belong to the same union-find partition
  the vertex v belongs to, false otherwise.
  
  =back
  
  =head1 AUTHOR AND COPYRIGHT
  
  Jarkko Hietaniemi F<jhi@iki.fi>
  
  =head1 LICENSE
  
  This module is licensed under the same terms as Perl itself.
  
  =cut
  
GRAPH_UNIONFIND

$fatpacked{"Heap071/Elem.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HEAP071_ELEM';
  package Heap071::Elem;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
  
  require Exporter;
  require AutoLoader;
  
  @ISA = qw(Exporter AutoLoader);
  
  # No names exported.
  # No names available for export.
  
  @EXPORT = ( );
  
  $VERSION = '0.71';
  
  
  # Preloaded methods go here.
  
  # new will usually be superceded by child,
  # but provide an empty hash as default and
  # accept any provided filling for it.
  sub new {
      my $self = shift;
      my $class = ref($self) || $self;
  
      return bless { heap=>undef, @_ }, $class;
  }
  
  sub heap {
      my $self = shift;
      @_ ? ($self->{heap} = shift) : $self->{heap};
  }
  
  sub cmp {
      die "This cmp method must be superceded by one that knows how to compare elements."
  }
  
  # Autoload methods go after =cut, and are processed by the autosplit program.
  
  1;
  __END__
  # Below is the stub of documentation for your module. You better edit it!
  
  =head1 NAME
  
  Heap::Elem - Perl extension for elements to be put in Heaps
  
  =head1 SYNOPSIS
  
    use Heap::Elem::SomeInheritor;
  
    use Heap::SomeHeapClass;
  
    $elem = Heap::Elem::SomeInheritor->new( $value );
    $heap = Heap::SomeHeapClass->new;
  
    $heap->add($elem);
  
  =head1 DESCRIPTION
  
  This is an inheritable class for Heap Elements.  It provides
  the interface documentation and some inheritable methods.
  Only a child classes can be used - this class is not complete.
  
  =head1 METHODS
  
  =over 4
  
  =item $elem = Heap::Elem::SomeInheritor->new( [args] );
  
  Creates a new Elem.
  
  =item $elem->heap( $val ); $elem->heap;
  
  Provides a method for use by the Heap processing routines.
  If a value argument is provided, it will be saved.  The
  new saved value is always returned.  If no value argument
  is provided, the old saved value is returned.
  
  The Heap processing routines use this method to map an element
  into its internal structure.  This is needed to support the
  Heap methods that affect elements that are not are the top
  of the heap - I<decrease_key> and I<delete>.
  
  The Heap processing routines will ensure that this value is
  undef when this elem is removed from a heap, and is not undef
  after it is inserted into a heap.  This means that you can
  check whether an element is currently contained within a heap
  or not.  (It cannot be used to determine which heap an element
  is contained in, if you have multiple heaps.  Keeping that
  information accurate would make the operation of merging two
  heaps into a single one take longer - it would have to traverse
  all of the elements in the merged heap to update them; for
  Binomial and Fibonacci heaps that would turn an O(1) operation
  into an O(n) one.)
  
  =item $elem1->cmp($elem2)
  
  A routine to compare two elements.  It must return a negative
  value if this element should go higher on the heap than I<$elem2>,
  0 if they are equal, or a positive value if this element should
  go lower on the heap than I<$elem2>.  Just as with sort, the
  Perl operators <=> and cmp cause the smaller value to be returned
  first; similarly you can negate the meaning to reverse the order
  - causing the heap to always return the largest element instead
  of the smallest.
  
  =back
  
  =head1 INHERITING
  
  This class can be inherited to provide an oject with the
  ability to be heaped.  If the object is implemented as
  a hash, and if it can deal with a key of I<heap>, leaving
  it unchanged for use by the heap routines, then the following
  implemetation will work.
  
    package myObject;
  
    require Exporter;
  
    @ISA = qw(Heap::Elem);
  
    sub new {
        my $self = shift;
        my $class = ref($self) || $self;
  
        my $self = SUPER::new($class);
  
        # set $self->{key} = $value;
    }
  
    sub cmp {
        my $self = shift;
        my $other = shift;
  
        $self->{key} cmp $other->{key};
    }
  
    # other methods for the rest of myObject's functionality
  
  =head1 AUTHOR
  
  John Macdonald, jmm@perlwolf.com
  
  =head1 COPYRIGHT
  
  Copyright 1998-2003, O'Reilly & Associates.
  
  This code is distributed under the same copyright terms as perl itself.
  
  =head1 SEE ALSO
  
  Heap(3), Heap::Elem::Num(3), Heap::Elem::NumRev(3),
  Heap::Elem::Str(3), Heap::Elem::StrRev(3).
  
  =cut
HEAP071_ELEM

$fatpacked{"Heap071/Fibonacci.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HEAP071_FIBONACCI';
  package Heap071::Fibonacci;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
  
  require Exporter;
  require AutoLoader;
  
  @ISA = qw(Exporter AutoLoader);
  
  # No names exported.
  # No names available for export.
  @EXPORT = ( );
  
  $VERSION = '0.71';
  
  
  # Preloaded methods go here.
  
  # common names
  #	h	- heap head
  #	el	- linkable element, contains user-provided value
  #	v	- user-provided value
  
  ################################################# debugging control
  
  my $debug = 0;
  my $validate = 0;
  
  # enable/disable debugging output
  sub debug {
      @_ ? ($debug = shift) : $debug;
  }
  
  # enable/disable validation checks on values
  sub validate {
      @_ ? ($validate = shift) : $validate;
  }
  
  my $width = 3;
  my $bar = ' | ';
  my $corner = ' +-';
  my $vfmt = "%3d";
  
  sub set_width {
      $width = shift;
      $width = 2 if $width < 2;
  
      $vfmt = "%${width}d";
      $bar = $corner = ' ' x $width;
      substr($bar,-2,1) = '|';
      substr($corner,-2,2) = '+-';
  }
  
  sub hdump;
  
  sub hdump {
      my $el = shift;
      my $l1 = shift;
      my $b = shift;
  
      my $ch;
      my $ch1;
  
      unless( $el ) {
  	print $l1, "\n";
  	return;
      }
  
      hdump $ch1 = $el->{child},
  	$l1 . sprintf( $vfmt, $el->{val}->val),
  	$b . $bar;
  
      if( $ch1 ) {
  	for( $ch = $ch1->{right}; $ch != $ch1; $ch = $ch->{right} ) {
  	    hdump $ch, $b . $corner, $b . $bar;
  	}
      }
  }
  
  sub heapdump {
      my $h;
  
      while( $h = shift ) {
  	my $top = $$h or last;
  	my $el = $top;
  
  	do {
  	    hdump $el, sprintf( "%02d: ", $el->{degree}), '    ';
  	    $el = $el->{right};
  	} until $el == $top;
  	print "\n";
      }
  }
  
  sub bhcheck;
  
  sub bhcheck {
      my $el = shift;
      my $p = shift;
  
      my $cur = $el;
      my $prev;
      my $ch;
      do {
  	$prev = $cur;
  	$cur = $cur->{right};
  	die "bad back link" unless $cur->{left} == $prev;
  	die "bad parent link"
  	    unless (defined $p && defined $cur->{p} && $cur->{p} == $p)
  		|| (!defined $p && !defined $cur->{p});
  	die "bad degree( $cur->{degree} > $p->{degree} )"
  	    if $p && $p->{degree} <= $cur->{degree};
  	die "not heap ordered"
  	    if $p && $p->{val}->cmp($cur->{val}) > 0;
  	$ch = $cur->{child} and bhcheck $ch, $cur;
      } until $cur == $el;
  }
  
  
  sub heapcheck {
      my $h;
      my $el;
      while( $h = shift ) {
  	heapdump $h if $validate >= 2;
  	$el = $$h and bhcheck $el, undef;
      }
  }
  
  
  ################################################# forward declarations
  
  sub ascending_cut;
  sub elem;
  sub elem_DESTROY;
  sub link_to_left_of;
  
  ################################################# heap methods
  
  # Cormen et al. use two values for the heap, a pointer to an element in the
  # list at the top, and a count of the number of elements.  The count is only
  # used to determine the size of array required to hold log(count) pointers,
  # but perl can set array sizes as needed and doesn't need to know their size
  # when they are created, so we're not maintaining that field.
  sub new {
      my $self = shift;
      my $class = ref($self) || $self;
      my $h = undef;
      bless \$h, $class;
  }
  
  sub DESTROY {
      my $h = shift;
  
      elem_DESTROY $$h;
  }
  
  sub add {
      my $h = shift;
      my $v = shift;
      $validate && do {
  	die "Method 'heap' required for element on heap"
  	    unless $v->can('heap');
  	die "Method 'cmp' required for element on heap"
  	    unless $v->can('cmp');
      };
      my $el = elem $v;
      my $top;
      if( !($top = $$h) ) {
  	$$h = $el;
      } else {
  	link_to_left_of $top->{left}, $el ;
  	link_to_left_of $el,$top;
  	$$h = $el if $v->cmp($top->{val}) < 0;
      }
  }
  
  sub top {
      my $h = shift;
      $$h && $$h->{val};
  }
  
  *minimum = \&top;
  
  sub extract_top {
      my $h = shift;
      my $el = $$h or return undef;
      my $ltop = $el->{left};
      my $cur;
      my $next;
  
      # $el is the heap with the lowest value on it
      # move all of $el's children (if any) to the top list (between
      # $ltop and $el)
      if( $cur = $el->{child} ) {
  	# remember the beginning of the list of children
  	my $first = $cur;
  	do {
  	    # the children are moving to the top, clear the p
  	    # pointer for all of them
  	    $cur->{p} = undef;
  	} until ($cur = $cur->{right}) == $first;
  
  	# remember the end of the list
  	$cur = $cur->{left};
  	link_to_left_of $ltop, $first;
  	link_to_left_of $cur, $el;
      }
  
      if( $el->{right} == $el ) {
  	# $el had no siblings or children, the top only contains $el
  	# and $el is being removed
  	$$h = undef;
      } else {
  	link_to_left_of $el->{left}, $$h = $el->{right};
  	# now all those loose ends have to be merged together as we
  	# search for the
  	# new smallest element
  	$h->consolidate;
      }
  
      # extract the actual value and return that, $el is no longer used
      # but break all of its links so that it won't be pointed to...
      my $top = $el->{val};
      $top->heap(undef);
      $el->{left} = $el->{right} = $el->{p} = $el->{child} = $el->{val} =
  	undef;
      $top;
  }
  
  *extract_minimum = \&extract_top;
  
  sub absorb {
      my $h = shift;
      my $h2 = shift;
  
      my $el = $$h;
      unless( $el ) {
  	$$h = $$h2;
  	$$h2 = undef;
  	return $h;
      }
  
      my $el2 = $$h2 or return $h;
  
      # add $el2 and its siblings to the head list for $h
      # at start, $ell -> $el -> ... -> $ell is on $h (where $ell is
      #				$el->{left})
      #           $el2l -> $el2 -> ... -> $el2l are on $h2
      # at end, $ell -> $el2l -> ... -> $el2 -> $el -> ... -> $ell are
      #				all on $h
      my $el2l = $el2->{left};
      link_to_left_of $el->{left}, $el2;
      link_to_left_of $el2l, $el;
  
      # change the top link if needed
      $$h = $el2 if $el->{val}->cmp( $el2->{val} ) > 0;
  
      # clean out $h2
      $$h2 = undef;
  
      # return the heap
      $h;
  }
  
  # a key has been decreased, it may have to percolate up in its heap
  sub decrease_key {
      my $h = shift;
      my $top = $$h;
      my $v = shift;
      my $el = $v->heap or return undef;
      my $p;
  
      # first, link $h to $el if it is now the smallest (we will
      # soon link $el to $top to properly put it up to the top list,
      # if it isn't already there)
      $$h = $el if $top->{val}->cmp( $v ) > 0;
  
      if( $p = $el->{p} and $v->cmp($p->{val}) < 0 ) {
  	# remove $el from its parent's list - it is now smaller
  
  	ascending_cut $top, $p, $el;
      }
  
      $v;
  }
  
  
  # to delete an item, we bubble it to the top of its heap (as if its key
  # had been decreased to -infinity), and then remove it (as in extract_top)
  sub delete {
      my $h = shift;
      my $v = shift;
      my $el = $v->heap or return undef;
  
      # if there is a parent, cut $el to the top (as if it had just had its
      # key decreased to a smaller value than $p's value
      my $p;
      $p = $el->{p} and ascending_cut $$h, $p, $el;
  
      # $el is in the top list now, make it look like the smallest and
      # remove it
      $$h = $el;
      $h->extract_top;
  }
  
  
  ################################################# internal utility functions
  
  sub elem {
      my $v = shift;
      my $el = undef;
      $el = {
  	p	=>	undef,
  	degree	=>	0,
  	mark	=>	0,
  	child	=>	undef,
  	val	=>	$v,
  	left	=>	undef,
  	right	=>	undef,
      };
      $el->{left} = $el->{right} = $el;
      $v->heap($el);
      $el;
  }
  
  sub elem_DESTROY {
      my $el = shift;
      my $ch;
      my $next;
      $el->{left}->{right} = undef;
  
      while( $el ) {
  	$ch = $el->{child} and elem_DESTROY $ch;
  	$next = $el->{right};
  
  	defined $el->{val} and $el->{val}->heap(undef);
  	$el->{child} = $el->{right} = $el->{left} = $el->{p} = $el->{val}
  	    = undef;
  	$el = $next;
      }
  }
  
  sub link_to_left_of {
      my $l = shift;
      my $r = shift;
  
      $l->{right} = $r;
      $r->{left} = $l;
  }
  
  sub link_as_parent_of {
      my $p = shift;
      my $c = shift;
  
      my $pc;
  
      if( $pc = $p->{child} ) {
  	link_to_left_of $pc->{left}, $c;
  	link_to_left_of $c, $pc;
      } else {
  	link_to_left_of $c, $c;
      }
      $p->{child} = $c;
      $c->{p} = $p;
      $p->{degree}++;
      $c->{mark} = 0;
      $p;
  }
  
  sub consolidate {
      my $h = shift;
  
      my $cur;
      my $this;
      my $next = $$h;
      my $last = $next->{left};
      my @a;
      do {
  	# examine next item on top list
  	$this = $cur = $next;
  	$next = $cur->{right};
  	my $d = $cur->{degree};
  	my $alt;
  	while( $alt = $a[$d] ) {
  	    # we already saw another item of the same degree,
  	    # put the larger valued one under the smaller valued
  	    # one - switch $cur and $alt if necessary so that $cur
  	    # is the smaller
  	    ($cur,$alt) = ($alt,$cur)
  		if $cur->{val}->cmp( $alt->{val} ) > 0;
  	    # remove $alt from the top list
  	    link_to_left_of $alt->{left}, $alt->{right};
  	    # and put it under $cur
  	    link_as_parent_of $cur, $alt;
  	    # make sure that $h still points to a node at the top
  	    $$h = $cur;
  	    # we've removed the old $d degree entry
  	    $a[$d] = undef;
  	    # and we now have a $d+1 degree entry to try to insert
  	    # into @a
  	    ++$d;
  	}
  	# found a previously unused degree
  	$a[$d] = $cur;
      } until $this == $last;
      $cur = $$h;
      for $cur (grep defined, @a) {
  	$$h = $cur if $$h->{val}->cmp( $cur->{val} ) > 0;
      }
  }
  
  sub ascending_cut {
      my $top = shift;
      my $p = shift;
      my $el = shift;
  
      while( 1 ) {
  	if( --$p->{degree} ) {
  	    # there are still other children below $p
  	    my $l = $el->{left};
  	    $p->{child} = $l;
  	    link_to_left_of $l, $el->{right};
  	} else {
  	    # $el was the only child of $p
  	    $p->{child} = undef;
  	}
  	link_to_left_of $top->{left}, $el;
  	link_to_left_of $el, $top;
  	$el->{p} = undef;
  	$el->{mark} = 0;
  
  	# propagate up the list
  	$el = $p;
  
  	# quit at the top
  	last unless $p = $el->{p};
  
  	# quit if we can mark $el
  	$el->{mark} = 1, last unless $el->{mark};
      }
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Heap::Fibonacci - a Perl extension for keeping data partially sorted
  
  =head1 SYNOPSIS
  
    use Heap::Fibonacci;
  
    $heap = Heap::Fibonacci->new;
    # see Heap(3) for usage
  
  =head1 DESCRIPTION
  
  Keeps elements in heap order using a linked list of Fibonacci trees.
  The I<heap> method of an element is used to store a reference to
  the node in the list that refers to the element.
  
  See L<Heap> for details on using this module.
  
  =head1 AUTHOR
  
  John Macdonald, jmm@perlwolf.com
  
  =head1 COPYRIGHT
  
  Copyright 1998-2003, O'Reilly & Associates.
  
  This code is distributed under the same copyright terms as perl itself.
  
  =head1 SEE ALSO
  
  Heap(3), Heap::Elem(3).
  
  =cut
HEAP071_FIBONACCI

$fatpacked{"Modern/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODERN_PERL';
  package Modern::Perl;
  {
    $Modern::Perl::VERSION = '1.20140107';
  }
  # ABSTRACT: enable all of the features of Modern Perl with one import
  
  use 5.010_000;
  
  use strict;
  use warnings;
  
  use mro     ();
  use feature ();
  
  # enable methods on filehandles; unnecessary when 5.14 autoloads them
  use IO::File   ();
  use IO::Handle ();
  
  our $VERSION;
  
  my $wanted_date;
  sub VERSION
  {
      my ($self, $version) = @_;
  
      return $VERSION unless defined $version;
      return $VERSION if             $version < 2009;
  
      $wanted_date = $version if (caller(1))[3] =~ /::BEGIN/;
      return 2014;
  }
  
  sub import
  {
      my ($class, $date) = @_;
      $date = $wanted_date unless defined $date;
  
      my $feature_tag    = validate_date( $date );
      undef $wanted_date;
  
      warnings->import;
      strict->import;
      feature->import( $feature_tag );
      mro::set_mro( scalar caller(), 'c3' );
  }
  
  sub unimport
  {
      warnings->unimport;
      strict->unimport;
      feature->unimport;
  }
  
  my %dates =
  (
      2009 => ':5.10',
      2010 => ':5.10',
      2011 => ':5.12',
      2012 => ':5.14',
      2013 => ':5.16',
      2014 => ':5.18',
  );
  
  sub validate_date
  {
      my $date = shift;
  
      # always enable unicode_strings when available
      unless ($date)
      {
          return ':5.12' if $] > 5.011003;
          return ':5.10';
      }
  
      my $year = substr $date, 0, 4;
      return $dates{$year} if exists $dates{$year};
  
      die "Unknown date '$date' requested\n";
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Modern::Perl - enable all of the features of Modern Perl with one import
  
  =head1 VERSION
  
  version 1.20140107
  
  =head1 SYNOPSIS
  
  Modern Perl programs use several modules to enable additional features of Perl
  and of the CPAN.  Instead of copying and pasting all of these C<use> lines,
  instead write only one:
  
      use Modern::Perl;
  
  This enables the L<strict> and L<warnings> pragmas, as well as all of the
  features available in Perl 5.10. It also enables C3 method resolution order as
  documented in C<perldoc mro> and loads L<IO::File> and L<IO::Handle> so that
  you may call methods on filehandles. In the future, it may include additional
  core modules and pragmas.
  
  Because so much of this module's behavior uses lexically scoped pragmas, you
  may disable these pragmas within an inner scope with:
  
      no Modern::Perl;
  
  See L<http://www.modernperlbooks.com/mt/2009/01/toward-a-modernperl.html> for
  more information, L<http://www.modernperlbooks.com/> for further discussion of
  Modern Perl and its implications, and
  L<http://onyxneon.com/books/modern_perl/index.html> for a freely-downloadable
  Modern Perl tutorial.
  
  =head2 Forward Compatibility
  
  For forward compatibility, I recommend you specify a I<year> as the single
  optional import tag. For example:
  
      use Modern::Perl '2009';
      use Modern::Perl '2010';
  
  ... both enable 5.10 features, while:
  
      use Modern::Perl '2011';
  
  ... enables 5.12 features:
  
      use Modern::Perl '2012';
  
  ... enables 5.14 features:
  
      use Modern::Perl '2013';
  
  ... enables 5.16 features, and:
  
      use Modern::Perl '2014';
  
  ... enables 5.18 features. Obviously you cannot use newer features on earlier
  versions. Perl will throw the appropriate exception if you try.
  
  By mid-2014, this module will drop support for 5.10 and 5.12 and will complain
  (once per process) if you use a year too old. As of January 2014, Perl 5.14 is
  unsupported by the Perl 5 Porters, so please consider upgrading.
  
  =head1 AUTHOR
  
  chromatic, C<< <chromatic at wgz.org> >>
  
  =head1 BUGS
  
  None reported.
  
  Please report any bugs or feature requests to C<bug-modern-perl at
  rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Modern-Perl>.  I will be
  notified, and then you'll automatically be notified of progress on your bug as
  I make changes.
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc Modern::Perl
  
  You can also look for information at:
  
  =over 4
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Modern-Perl>
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Modern-Perl>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Modern-Perl>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Modern-Perl/>
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  Damian Conway (inspiration from L<Toolkit>), Florian Ragwitz
  (L<B::Hooks::Parser>, so I didn't have to write it myself), chocolateboy (for
  suggesting that I don't even need L<B::Hooks::Parser>), Damien Learns Perl,
  David Moreno, Evan Carroll, Elliot Shank, Andreas König, Father Chrysostomos,
  and Norbert E. Grüner for reporting bugs, filing patches, and requesting
  features.
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2009-2014 chromatic, all rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl 5.18 itself.
  
  =head1 AUTHOR
  
  chromatic
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by chromatic@wgz.org.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
MODERN_PERL

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Path::Tiny;
  # ABSTRACT: File path utility
  our $VERSION = '0.052'; # VERSION
  
  # Dependencies
  use Config;
  use Exporter 5.57   (qw/import/);
  use File::Spec 3.40 ();
  use Carp ();
  
  our @EXPORT    = qw/path/;
  our @EXPORT_OK = qw/cwd rootdir tempfile tempdir/;
  
  use constant {
      PATH     => 0,
      CANON    => 1,
      VOL      => 2,
      DIR      => 3,
      FILE     => 4,
      TEMP     => 5,
      IS_BSD   => ( scalar $^O =~ /bsd$/ ),
      IS_WIN32 => ( $^O eq 'MSWin32' ),
  };
  
  use overload (
      q{""}    => sub    { $_[0]->[PATH] },
      bool     => sub () { 1 },
      fallback => 1,
  );
  
  my $HAS_UU; # has Unicode::UTF8; lazily populated
  
  sub _check_UU {
      eval { require Unicode::UTF8; Unicode::UTF8->VERSION(0.58); 1 };
  }
  
  my $HAS_FLOCK = $Config{d_flock} || $Config{d_fcntl_can_lock} || $Config{d_lockf};
  
  # notions of "root" directories differ on Win32: \\server\dir\ or C:\ or \
  my $SLASH      = qr{[\\/]};
  my $NOTSLASH   = qr{[^\\/]};
  my $DRV_VOL    = qr{[a-z]:}i;
  my $UNC_VOL    = qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;
  my $WIN32_ROOT = qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;
  
  sub _win32_vol {
      my ( $path, $drv ) = @_;
      require Cwd;
      my $dcwd = eval { Cwd::getdcwd($drv) }; # C: -> C:\some\cwd
      # getdcwd on non-existent drive returns empty string
      # so just use the original drive Z: -> Z:
      $dcwd = "$drv" unless defined $dcwd && length $dcwd;
      # normalize dwcd to end with a slash: might be C:\some\cwd or D:\ or Z:
      $dcwd =~ s{$SLASH?$}{/};
      # make the path absolute with dcwd
      $path =~ s{^$DRV_VOL}{$dcwd};
      return $path;
  }
  
  # This is a string test for before we have the object; see is_rootdir for well-formed
  # object test
  sub _is_root {
      return IS_WIN32() ? ( $_[0] =~ /^$WIN32_ROOT$/ ) : ( $_[0] eq '/' );
  }
  
  # flock doesn't work on NFS on BSD.  Since program authors often can't control
  # or detect that, we warn once instead of being fatal if we can detect it and
  # people who need it strict can fatalize the 'flock' category
  
  #<<< No perltidy
  { package flock; use if Path::Tiny::IS_BSD(), 'warnings::register' }
  #>>>
  
  my $WARNED_BSD_NFS = 0;
  
  sub _throw {
      my ( $self, $function, $file ) = @_;
      if (   IS_BSD()
          && $function =~ /^flock/
          && $! =~ /operation not supported/i
          && !warnings::fatal_enabled('flock') )
      {
          if ( !$WARNED_BSD_NFS ) {
              warnings::warn( flock => "No flock for NFS on BSD: continuing in unsafe mode" );
              $WARNED_BSD_NFS++;
          }
      }
      else {
          Path::Tiny::Error->throw( $function, ( defined $file ? $file : $self->[PATH] ), $! );
      }
      return;
  }
  
  # cheapo option validation
  sub _get_args {
      my ( $raw, @valid ) = @_;
      if ( defined($raw) && ref($raw) ne 'HASH' ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak("Options for $called_as must be a hash reference");
      }
      my $cooked = {};
      for my $k (@valid) {
          $cooked->{$k} = delete $raw->{$k} if exists $raw->{$k};
      }
      if ( keys %$raw ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak( "Invalid option(s) for $called_as: " . join( ", ", keys %$raw ) );
      }
      return $cooked;
  }
  
  #--------------------------------------------------------------------------#
  # Constructors
  #--------------------------------------------------------------------------#
  
  
  sub path {
      my $path = shift;
      Carp::croak("path() requires a defined, positive-length argument")
        unless defined $path && length $path;
  
      # stringify initial path
      $path = "$path";
  
      # expand relative volume paths on windows; put trailing slash on UNC root
      if ( IS_WIN32() ) {
          $path = _win32_vol( $path, $1 ) if $path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};
          $path .= "/" if $path =~ m{^$UNC_VOL$};
      }
  
      # concatenate more arguments (stringifies any objects, too)
      if (@_) {
          $path .= ( _is_root($path) ? "" : "/" ) . join( "/", @_ );
      }
  
      # canonicalize paths
      my $cpath = $path = File::Spec->canonpath($path); # ugh, but probably worth it
      $path =~ tr[\\][/] if IS_WIN32();                 # unix convention enforced
      $path .= "/" if IS_WIN32() && $path =~ m{^$UNC_VOL$}; # canonpath strips it
  
      # hack to make splitpath give us a basename; root paths must always have
      # a trailing slash, but other paths must not
      if ( _is_root($path) ) {
          $path =~ s{/?$}{/};
      }
      else {
          $path =~ s{/$}{};
      }
  
      # do any tilde expansions
      if ( $path =~ m{^(~[^/]*).*} ) {
          my ($homedir) = glob($1); # glob without list context == heisenbug!
          $path =~ s{^(~[^/]*)}{$homedir};
      }
  
      # and we're finally done
      bless [ $path, $cpath ], __PACKAGE__;
  }
  
  
  sub new { shift; path(@_) }
  
  
  sub cwd {
      require Cwd;
      return path( Cwd::getcwd() );
  }
  
  
  sub rootdir { path( File::Spec->rootdir ) }
  
  
  sub tempfile {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
      # File::Temp->new demands TEMPLATE
      $args->{TEMPLATE} = $maybe_template->[0] if @$maybe_template;
  
      require File::Temp;
      my $temp = File::Temp->new( TMPDIR => 1, %$args );
      close $temp;
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  sub tempdir {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
  
      # File::Temp->newdir demands leading template
      require File::Temp;
      my $temp = File::Temp->newdir( @$maybe_template, TMPDIR => 1, %$args );
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  # normalize the various ways File::Temp does templates
  sub _parse_file_temp_args {
      my $leading_template = ( scalar(@_) % 2 == 1 ? shift(@_) : '' );
      my %args = @_;
      %args = map { uc($_), $args{$_} } keys %args;
      my @template = (
            exists $args{TEMPLATE} ? delete $args{TEMPLATE}
          : $leading_template      ? $leading_template
          :                          ()
      );
      return ( \@template, \%args );
  }
  
  #--------------------------------------------------------------------------#
  # Private methods
  #--------------------------------------------------------------------------#
  
  sub _splitpath {
      my ($self) = @_;
      @{$self}[ VOL, DIR, FILE ] = File::Spec->splitpath( $self->[PATH] );
  }
  
  #--------------------------------------------------------------------------#
  # Public methods
  #--------------------------------------------------------------------------#
  
  
  sub absolute {
      my ( $self, $base ) = @_;
  
      # absolute paths handled differently by OS
      if (IS_WIN32) {
          return $self if length $self->volume;
          # add missing volume
          if ( $self->is_absolute ) {
              require Cwd;
              # use Win32::GetCwd not Cwd::getdcwd because we're sure
              # to have the former but not necessarily the latter
              my ($drv) = Win32::GetCwd() =~ /^($DRV_VOL | $UNC_VOL)/x;
              return path( $drv . $self->[PATH] );
          }
      }
      else {
          return $self if $self->is_absolute;
      }
  
      # relative path on any OS
      require Cwd;
      return path( ( defined($base) ? $base : Cwd::getcwd() ), $_[0]->[PATH] );
  }
  
  
  sub append {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, ">>", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw('close');
  }
  
  sub append_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &append }
  
  sub append_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          append( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &append;
      }
  }
  
  
  sub basename {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[FILE];
      return $self->[FILE];
  }
  
  
  sub canonpath { $_[0]->[CANON] }
  
  
  sub child {
      my ( $self, @parts ) = @_;
      return path( $self->[PATH], @parts );
  }
  
  
  sub children {
      my ( $self, $filter ) = @_;
      my $dh;
      opendir $dh, $self->[PATH] or $self->_throw('opendir');
      my @children = readdir $dh;
      closedir $dh or $self->_throw('closedir');
  
      if ( not defined $filter ) {
          @children = grep { $_ ne '.' && $_ ne '..' } @children;
      }
      elsif ( $filter && ref($filter) eq 'Regexp' ) {
          @children = grep { $_ ne '.' && $_ ne '..' && $_ =~ $filter } @children;
      }
      else {
          Carp::croak("Invalid argument '$filter' for children()");
      }
  
      return map { path( $self->[PATH], $_ ) } @children;
  }
  
  
  # XXX do recursively for directories?
  sub copy {
      my ( $self, $dest ) = @_;
      require File::Copy;
      File::Copy::copy( $self->[PATH], $dest )
        or Carp::croak("copy failed for $self to $dest: $!");
  }
  
  
  sub digest {
      my ( $self, $alg, @args ) = @_;
      $alg = 'SHA-256' unless defined $alg;
      require Digest;
      return Digest->new( $alg, @args )->add( $self->slurp_raw )->hexdigest;
  }
  
  
  sub dirname {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return length $self->[DIR] ? $self->[DIR] : ".";
  }
  
  
  sub exists { -e $_[0]->[PATH] }
  
  sub is_file { -f $_[0]->[PATH] }
  
  sub is_dir { -d $_[0]->[PATH] }
  
  
  # Note: must put binmode on open line, not subsequent binmode() call, so things
  # like ":unix" actually stop perlio/crlf from being added
  
  sub filehandle {
      my ( $self, @args ) = @_;
      my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
      $args = _get_args( $args, qw/locked/ );
      my ( $opentype, $binmode ) = @args;
  
      $opentype = "<" unless defined $opentype;
      Carp::croak("Invalid file mode '$opentype'")
        unless grep { $opentype eq $_ } qw/< +< > +> >> +>>/;
  
      $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $opentype, -1, 1 ) }
        unless defined $binmode;
      $binmode = "" unless defined $binmode;
  
      my ( $fh, $lock, $trunc );
      if ( $HAS_FLOCK && $args->{locked} ) {
          require Fcntl;
          # truncating file modes shouldn't truncate until lock acquired
          if ( grep { $opentype eq $_ } qw( > +> ) ) {
              # sysopen in write mode without truncation
              my $flags = $opentype eq ">" ? Fcntl::O_WRONLY() : Fcntl::O_RDWR();
              $flags |= Fcntl::O_CREAT();
              sysopen( $fh, $self->[PATH], $flags ) or $self->_throw("sysopen");
  
              # fix up the binmode since sysopen() can't specify layers like
              # open() and binmode() can't start with just :unix like open()
              if ( $binmode =~ s/^:unix// ) {
                  # eliminate pseudo-layers
                  binmode( $fh, ":raw" ) or $self->_throw("binmode (:raw)");
                  # strip off real layers until only :unix is left
                  while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
                      binmode( $fh, ":pop" ) or $self->_throw("binmode (:pop)");
                  }
              }
  
              # apply any remaining binmode layers
              if ( length $binmode ) {
                  binmode( $fh, $binmode ) or $self->_throw("binmode ($binmode)");
              }
  
              # ask for lock and truncation
              $lock  = Fcntl::LOCK_EX();
              $trunc = 1;
          }
          elsif ( $^O eq 'aix' && $opentype eq "<" ) {
              # AIX can only lock write handles, so upgrade to RW and LOCK_EX
              $opentype = "+<";
              $lock     = Fcntl::LOCK_EX();
          }
          else {
              $lock = $opentype eq "<" ? Fcntl::LOCK_SH() : Fcntl::LOCK_EX();
          }
      }
  
      unless ($fh) {
          my $mode = $opentype . $binmode;
          open $fh, $mode, $self->[PATH] or $self->_throw("open ($mode)");
      }
  
      do { flock( $fh, $lock ) or $self->_throw("flock ($lock)") } if $lock;
      do { truncate( $fh, 0 ) or $self->_throw("truncate") } if $trunc;
  
      return $fh;
  }
  
  
  sub is_absolute { substr( $_[0]->dirname, 0, 1 ) eq '/' }
  
  sub is_relative { substr( $_[0]->dirname, 0, 1 ) ne '/' }
  
  
  sub is_rootdir {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return $self->[DIR] eq '/' && $self->[FILE] eq '';
  }
  
  
  sub iterator {
      my $self = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      my @dirs = $self;
      my $current;
      return sub {
          my $next;
          while (@dirs) {
              if ( ref $dirs[0] eq 'Path::Tiny' ) {
                  if ( !-r $dirs[0] ) {
                      # Directory is missing or not readable, so skip it.  There
                      # is still a race condition possible between the check and
                      # the opendir, but we can't easily differentiate between
                      # error cases that are OK to skip and those that we want
                      # to be exceptions, so we live with the race and let opendir
                      # be fatal.
                      shift @dirs and next;
                  }
                  $current = $dirs[0];
                  my $dh;
                  opendir( $dh, $current->[PATH] )
                    or $self->_throw( 'opendir', $current->[PATH] );
                  $dirs[0] = $dh;
                  if ( -l $current->[PATH] && !$args->{follow_symlinks} ) {
                      # Symlink attack! It was a real dir, but is now a symlink!
                      # N.B. we check *after* opendir so the attacker has to win
                      # two races: replace dir with symlink before opendir and
                      # replace symlink with dir before -l check above
                      shift @dirs and next;
                  }
              }
              while ( defined( $next = readdir $dirs[0] ) ) {
                  next if $next eq '.' || $next eq '..';
                  my $path = $current->child($next);
                  push @dirs, $path
                    if $args->{recurse} && -d $path && !( !$args->{follow_symlinks} && -l $path );
                  return $path;
              }
              shift @dirs;
          }
          return;
      };
  }
  
  
  sub lines {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode chomp count/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      my $chomp = $args->{chomp};
      # XXX more efficient to read @lines then chomp(@lines) vs map?
      if ( $args->{count} ) {
          my ( @result, $counter );
          while ( my $line = <$fh> ) {
              $line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if $chomp;
              push @result, $line;
              last if ++$counter == $args->{count};
          }
          return @result;
      }
      elsif ($chomp) {
          return map { s/(?:\x{0d}?\x{0a}|\x{0d})$//; $_ } <$fh>; ## no critic
      }
      else {
          return wantarray ? <$fh> : ( my $count =()= <$fh> );
      }
  }
  
  sub lines_raw {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if ( $args->{chomp} && !$args->{count} ) {
          return split /\n/, slurp_raw($self);                    ## no critic
      }
      else {
          $args->{binmode} = ":raw";
          return lines( $self, $args );
      }
  }
  
  sub lines_utf8 {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if (   ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() )
          && $args->{chomp}
          && !$args->{count} )
      {
          return split /(?:\x{0d}?\x{0a}|\x{0d})/, slurp_utf8($self); ## no critic
      }
      else {
          $args->{binmode} = ":raw:encoding(UTF-8)";
          return lines( $self, $args );
      }
  }
  
  
  sub mkpath {
      my ( $self, $args ) = @_;
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err} = \$err unless defined $args->{err};
      require File::Path;
      my @dirs = File::Path::make_path( $self->[PATH], $args );
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("mkpath failed for $file: $message");
      }
      return @dirs;
  }
  
  
  sub move {
      my ( $self, $dst ) = @_;
  
      return rename( $self->[PATH], $dst )
        || $self->_throw( 'rename', $self->[PATH] . "' -> '$dst'" );
  }
  
  
  # map method names to corresponding open mode
  my %opens = (
      opena  => ">>",
      openr  => "<",
      openw  => ">",
      openrw => "+<"
  );
  
  while ( my ( $k, $v ) = each %opens ) {
      no strict 'refs';
      # must check for lexical IO mode hint
      *{$k} = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          my ($binmode) = @args;
          $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $v, -1, 1 ) }
            unless defined $binmode;
          $self->filehandle( $args, $v, $binmode );
      };
      *{ $k . "_raw" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw" );
      };
      *{ $k . "_utf8" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw:encoding(UTF-8)" );
      };
  }
  
  
  # XXX this is ugly and coverage is incomplete.  I think it's there for windows
  # so need to check coverage there and compare
  sub parent {
      my ( $self, $level ) = @_;
      $level = 1 unless defined $level && $level > 0;
      $self->_splitpath unless defined $self->[FILE];
      my $parent;
      if ( length $self->[FILE] ) {
          if ( $self->[FILE] eq '.' || $self->[FILE] eq ".." ) {
              $parent = path( $self->[PATH] . "/.." );
          }
          else {
              $parent = path( _non_empty( $self->[VOL] . $self->[DIR] ) );
          }
      }
      elsif ( length $self->[DIR] ) {
          # because of symlinks, any internal updir requires us to
          # just add more updirs at the end
          if ( $self->[DIR] =~ m{(?:^\.\./|/\.\./|/\.\.$)} ) {
              $parent = path( $self->[VOL] . $self->[DIR] . "/.." );
          }
          else {
              ( my $dir = $self->[DIR] ) =~ s{/[^\/]+/$}{/};
              $parent = path( $self->[VOL] . $dir );
          }
      }
      else {
          $parent = path( _non_empty( $self->[VOL] ) );
      }
      return $level == 1 ? $parent : $parent->parent( $level - 1 );
  }
  
  sub _non_empty {
      my ($string) = shift;
      return ( ( defined($string) && length($string) ) ? $string : "." );
  }
  
  
  sub realpath {
      my $self = shift;
      require Cwd;
      my $realpath = eval {
          local $SIG{__WARN__} = sub { }; # (sigh) pure-perl CWD can carp
          Cwd::realpath( $self->[PATH] );
      };
      $self->_throw("resolving realpath") unless defined $realpath and length $realpath;
      return path($realpath);
  }
  
  
  # Easy to get wrong, so wash it through File::Spec (sigh)
  sub relative { path( File::Spec->abs2rel( $_[0]->[PATH], $_[1] ) ) }
  
  
  sub remove {
      my $self = shift;
  
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
  
      return unlink $self->[PATH] || $self->_throw('unlink');
  }
  
  
  sub remove_tree {
      my ( $self, $args ) = @_;
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err}  = \$err unless defined $args->{err};
      $args->{safe} = 1     unless defined $args->{safe};
      require File::Path;
      my $count = File::Path::remove_tree( $self->[PATH], $args );
  
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("remove_tree failed for $file: $message");
      }
      return $count;
  }
  
  
  sub slurp {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      if ( ( defined($binmode) ? $binmode : "" ) eq ":unix"
          and my $size = -s $fh )
      {
          my $buf;
          read $fh, $buf, $size; # File::Slurp in a nutshell
          return $buf;
      }
      else {
          local $/;
          return scalar <$fh>;
      }
  }
  
  sub slurp_raw { $_[1] = { binmode => ":unix" }; goto &slurp }
  
  sub slurp_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          return Unicode::UTF8::decode_utf8( slurp( $_[0], { binmode => ":unix" } ) );
      }
      else {
          $_[1] = { binmode => ":raw:encoding(UTF-8)" };
          goto &slurp;
      }
  }
  
  
  # XXX add "unsafe" option to disable flocking and atomic?  Check benchmarks on append() first.
  sub spew {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $temp = path( $self->[PATH] . $$ . int( rand( 2**31 ) ) );
      my $fh = $temp->filehandle( { locked => 1 }, ">", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw( 'close', $temp->[PATH] );
  
      # spewing need to follow the link
      # and replace the destination instead
      my $resolved_path = $self->[PATH];
      $resolved_path = readlink $resolved_path while -l $resolved_path;
      return $temp->move($resolved_path);
  }
  
  sub spew_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &spew }
  
  sub spew_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          spew( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &spew;
      }
  }
  
  
  # XXX break out individual stat() components as subs?
  sub stat {
      my $self = shift;
      require File::stat;
      return File::stat::stat( $self->[PATH] ) || $self->_throw('stat');
  }
  
  sub lstat {
      my $self = shift;
      require File::stat;
      return File::stat::lstat( $self->[PATH] ) || $self->_throw('lstat');
  }
  
  
  sub stringify { $_[0]->[PATH] }
  
  
  sub subsumes {
      my $self = shift;
      Carp::croak("subsumes() requires a defined, positive-length argument")
        unless defined $_[0];
      my $other = path(shift);
  
      # normalize absolute vs relative
      if ( $self->is_absolute && !$other->is_absolute ) {
          $other = $other->absolute;
      }
      elsif ( $other->is_absolute && !$self->is_absolute ) {
          $self = $self->absolute;
      }
  
      # normalize volume vs non-volume; do this after absolute path
      # adjustments above since that might add volumes already
      if ( length $self->volume && !length $other->volume ) {
          $other = $other->absolute;
      }
      elsif ( length $other->volume && !length $self->volume ) {
          $self = $self->absolute;
      }
  
      if ( $self->[PATH] eq '.' ) {
          return !!1; # cwd subsumes everything relative
      }
      elsif ( $self->is_rootdir ) {
          # a root directory ("/", "c:/") already ends with a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E};
      }
      else {
          # exact match or prefix breaking at a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E(?:/|$)};
      }
  }
  
  
  sub touch {
      my ( $self, $epoch ) = @_;
      if ( !-e $self->[PATH] ) {
          my $fh = $self->openw;
          close $fh or $self->_throw('close');
      }
      $epoch = defined($epoch) ? $epoch : time();
      utime $epoch, $epoch, $self->[PATH]
        or $self->_throw("utime ($epoch)");
      return $self;
  }
  
  
  sub touchpath {
      my ($self) = @_;
      my $parent = $self->parent;
      $parent->mkpath unless $parent->exists;
      $self->touch;
  }
  
  
  sub volume {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[VOL];
      return $self->[VOL];
  }
  
  package Path::Tiny::Error;
  
  our @CARP_NOT = qw/Path::Tiny/;
  
  use overload ( q{""} => sub { (shift)->{msg} }, fallback => 1 );
  
  sub throw {
      my ( $class, $op, $file, $err ) = @_;
      chomp( my $trace = Carp::shortmess );
      my $msg = "Error $op on '$file': $err$trace\n";
      die bless { op => $op, file => $file, err => $err, msg => $msg }, $class;
  }
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Path::Tiny - File path utility
  
  =head1 VERSION
  
  version 0.052
  
  =head1 SYNOPSIS
  
    use Path::Tiny;
  
    # creating Path::Tiny objects
  
    $dir = path("/tmp");
    $foo = path("foo.txt");
  
    $subdir = $dir->child("foo");
    $bar = $subdir->child("bar.txt");
  
    # stringifies as cleaned up path
  
    $file = path("./foo.txt");
    print $file; # "foo.txt"
  
    # reading files
  
    $guts = $file->slurp;
    $guts = $file->slurp_utf8;
  
    @lines = $file->lines;
    @lines = $file->lines_utf8;
  
    $head = $file->lines( {count => 1} );
  
    # writing files
  
    $bar->spew( @data );
    $bar->spew_utf8( @data );
  
    # reading directories
  
    for ( $dir->children ) { ... }
  
    $iter = $dir->iterator;
    while ( my $next = $iter->() ) { ... }
  
  =head1 DESCRIPTION
  
  This module attempts to provide a small, fast utility for working with
  file paths.  It is friendlier to use than L<File::Spec> and provides
  easy access to functions from several other core file handling modules.
  
  It doesn't attempt to be as full-featured as L<IO::All> or L<Path::Class>,
  nor does it try to work for anything except Unix-like and Win32 platforms.
  Even then, it might break if you try something particularly obscure or
  tortuous.  (Quick!  What does this mean: C<< ///../../..//./././a//b/.././c/././ >>?
  And how does it differ on Win32?)
  
  All paths are forced to have Unix-style forward slashes.  Stringifying
  the object gives you back the path (after some clean up).
  
  File input/output methods C<flock> handles before reading or writing,
  as appropriate (if supported by the platform).
  
  The C<*_utf8> methods (C<slurp_utf8>, C<lines_utf8>, etc.) operate in raw
  mode without CRLF translation.  Installing L<Unicode::UTF8> 0.58 or later
  will speed up several of them and is highly recommended.
  
  =head1 CONSTRUCTORS
  
  =head2 path
  
      $path = path("foo/bar");
      $path = path("/tmp", "file.txt"); # list
      $path = path(".");                # cwd
      $path = path("~user/file.txt");   # tilde processing
  
  Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  directory path.  It's still up to you to call directory-like methods only on
  directories and file-like methods only on files.  This function is exported
  automatically by default.
  
  The first argument must be defined and have non-zero length or an exception
  will be thrown.  This prevents subtle, dangerous errors with code like
  C<< path( maybe_undef() )->remove_tree >>.
  
  If the first component of the path is a tilde ('~') then the component will be
  replaced with the output of C<glob('~')>.  If the first component of the path
  is a tilde followed by a user name then the component will be replaced with
  output of C<glob('~username')>.  Behaviour for non-existent users depends on
  the output of C<glob> on the system.
  
  On Windows, if the path consists of a drive identifier without a path component
  (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  directory on that volume using C<Cwd::getdcwd()>.
  
  =head2 new
  
      $path = Path::Tiny->new("foo/bar");
  
  This is just like C<path>, but with method call overhead.  (Why would you
  do that?)
  
  =head2 cwd
  
      $path = Path::Tiny->cwd; # path( Cwd::getcwd )
      $path = cwd; # optional export
  
  Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  This is slightly faster than C<< path(".")->absolute >>.
  
  C<cwd> may be exported on request and used as a function instead of as a
  method.
  
  =head2 rootdir
  
      $path = Path::Tiny->rootdir; # /
      $path = rootdir;             # optional export 
  
  Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  picky for C<path("/")>.
  
  C<rootdir> may be exported on request and used as a function instead of as a
  method.
  
  =head2 tempfile, tempdir
  
      $temp = Path::Tiny->tempfile( @options );
      $temp = Path::Tiny->tempdir( @options );
      $temp = tempfile( @options ); # optional export
      $temp = tempdir( @options );  # optional export
  
  C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  object with the file name.  The C<TMPDIR> option is enabled by default.
  
  The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  destroyed, the C<File::Temp> object will be as well.
  
  C<File::Temp> annoyingly requires you to specify a custom template in slightly
  different ways depending on which function or method you call, but
  C<Path::Tiny> lets you ignore that and can take either a leading template or a
  C<TEMPLATE> option and does the right thing.
  
      $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
      $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  
  The tempfile path object will normalized to have an absolute path, even if
  created in a relative directory using C<DIR>.
  
  C<tempdir> is just like C<tempfile>, except it calls
  C<< File::Temp->newdir >> instead.
  
  Both C<tempfile> and C<tempdir> may be exported on request and used as
  functions instead of as methods.
  
  =head1 METHODS
  
  =head2 absolute
  
      $abs = path("foo/bar")->absolute;
      $abs = path("foo/bar")->absolute("/tmp");
  
  Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  absolute).  Unless an argument is given, the current directory is used as the
  absolute base path.  The argument must be absolute or you won't get an absolute
  result.
  
  This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  in L<File::Spec> would normally do so on your platform.  If you need them
  resolved, you must call the more expensive C<realpath> method instead.
  
  On Windows, an absolute path without a volume component will have it added
  based on the current drive.
  
  =head2 append, append_raw, append_utf8
  
      path("foo.txt")->append(@data);
      path("foo.txt")->append(\@data);
      path("foo.txt")->append({binmode => ":raw"}, @data);
      path("foo.txt")->append_raw(@data);
      path("foo.txt")->append_utf8(@data);
  
  Appends data to a file.  The file is locked with C<flock> prior to writing.  An
  optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to C<binmode()> on the handle used for writing.
  
  C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  unbuffered, raw write.
  
  C<append_utf8> is like C<append> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  append will be done instead on the data encoded with C<Unicode::UTF8>.
  
  =head2 basename
  
      $name = path("foo/bar.txt")->basename; # bar.txt
  
  Returns the file portion or last directory portion of a path.
  
  =head2 canonpath
  
      $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  
  Returns a string with the canonical format of the path name for
  the platform.  In particular, this means directory separators
  will be C<\> on Windows.
  
  =head2 child
  
      $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
      $file = path("/tmp")->child(@parts);
  
  Returns a new C<Path::Tiny> object relative to the original.  Works
  like C<catfile> or C<catdir> from File::Spec, but without caring about
  file or directories.
  
  =head2 children
  
      @paths = path("/tmp")->children;
      @paths = path("/tmp")->children( qr/\.txt$/ );
  
  Returns a list of C<Path::Tiny> objects for all files and directories
  within a directory.  Excludes "." and ".." automatically.
  
  If an optional C<qr//> argument is provided, it only returns objects for child
  names that match the given regular expression.  Only the base name is used
  for matching:
  
      @paths = path("/tmp")->children( qr/^foo/ );
      # matches children like the glob foo*
  
  =head2 copy
  
      path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  
  Copies a file using L<File::Copy>'s C<copy> function.
  
  =head2 digest
  
      $obj = path("/tmp/foo.txt")->digest;        # SHA-256
      $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
  
  Returns a hexadecimal digest for a file.  Any arguments are passed to the
  constructor for L<Digest> to select an algorithm.  If no arguments are given,
  the default is SHA-256.
  
  =head2 dirname
  
      $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  
  Returns the directory name portion of the path.  This is roughly
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually has the trailing slash. If that's not desired, stringify directories
  or call C<parent> on files.
  
  =head2 exists, is_file, is_dir
  
      if ( path("/tmp")->exists ) { ... }
      if ( path("/tmp")->is_file ) { ... }
      if ( path("/tmp")->is_dir ) { ... }
  
  Just like C<-e>, C<-f> or C<-d>.  This means the file or directory actually has to
  exist on the filesystem.  Until then, it's just a path.
  
  =head2 filehandle
  
      $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
  
  Returns an open file handle.  The C<$mode> argument must be a Perl-style
  read/write mode string ("<" ,">", "<<", etc.).  If a C<$binmode>
  is given, it is set during the C<open> call.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked with C<LOCK_SH>.  When using
  C<locked>, ">" or "+>" modes will delay truncation until after the lock is
  acquired.
  
  See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  
  =head2 is_absolute, is_relative
  
      if ( path("/tmp")->is_absolute ) { ... }
      if ( path("/tmp")->is_relative ) { ... }
  
  Booleans for whether the path appears absolute or relative.
  
  =head2 is_rootdir
  
      while ( ! $path->is_rootdir ) {
          $path = $path->parent;
          ...
      }
  
  Boolean for whether the path is the root directory of the volume.  I.e. the
  C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  
  This works even on C<MSWin32> with drives and UNC volumes:
  
      path("C:/")->is_rootdir;             # true
      path("//server/share/")->is_rootdir; #true
  
  =head2 iterator
  
      $iter = path("/tmp")->iterator( \%options );
  
  Returns a code reference that walks a directory lazily.  Each invocation
  returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  
      $iter = path("/tmp")->iterator;
      while ( $path = $iter->() ) {
          ...
      }
  
  The current and parent directory entries ("." and "..") will not
  be included.
  
  If the C<recurse> option is true, the iterator will walk the directory
  recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  directory links will be followed recursively.  There is no protection against
  loops when following links. If a directory is not readable, it will not be
  followed.
  
  The default is the same as:
  
      $iter = path("/tmp")->iterator( {
          recurse         => 0,
          follow_symlinks => 0,
      } );
  
  For a more powerful, recursive iterator with built-in loop avoidance, see
  L<Path::Iterator::Rule>.
  
  =head2 lines, lines_raw, lines_utf8
  
      @contents = path("/tmp/foo.txt")->lines;
      @contents = path("/tmp/foo.txt")->lines(\%options);
      @contents = path("/tmp/foo.txt")->lines_raw;
      @contents = path("/tmp/foo.txt")->lines_utf8;
  
      @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  
  Returns a list of lines from a file.  Optionally takes a hash-reference of
  options.  Valid options are C<binmode>, C<count> and C<chomp>.  If C<binmode>
  is provided, it will be set on the handle prior to reading.  If C<count> is
  provided, up to that many lines will be returned. If C<chomp> is set, any
  end-of-line character sequences (C<CR>, C<CRLF>, or C<LF>) will be removed
  from the lines returned.
  
  Because the return is a list, C<lines> in scalar context will return the number
  of lines (and throw away the data).
  
      $number_of_lines = path("/tmp/foo.txt")->lines;
  
  C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  instead of C<:unix> so PerlIO buffering can manage reading by line.
  
  C<lines_utf8> is like C<lines> with a C<binmode> of
  C<:raw:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  UTF-8 slurp will be done and then the lines will be split.  This is
  actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  intensive.  If memory use is a concern, consider C<openr_utf8> and
  iterating directly on the handle.
  
  =head2 mkpath
  
      path("foo/bar/baz")->mkpath;
      path("foo/bar/baz")->mkpath( \%options );
  
  Like calling C<make_path> from L<File::Path>.  An optional hash reference
  is passed through to C<make_path>.  Errors will be trapped and an exception
  thrown.  Returns the list of directories created or an empty list if
  the directories already exist, just like C<make_path>.
  
  =head2 move
  
      path("foo.txt")->move("bar.txt");
  
  Just like C<rename>.
  
  =head2 openr, openw, openrw, opena
  
      $fh = path("foo.txt")->openr($binmode);  # read
      $fh = path("foo.txt")->openr_raw;
      $fh = path("foo.txt")->openr_utf8;
  
      $fh = path("foo.txt")->openw($binmode);  # write
      $fh = path("foo.txt")->openw_raw;
      $fh = path("foo.txt")->openw_utf8;
  
      $fh = path("foo.txt")->opena($binmode);  # append
      $fh = path("foo.txt")->opena_raw;
      $fh = path("foo.txt")->opena_utf8;
  
      $fh = path("foo.txt")->openrw($binmode); # read/write
      $fh = path("foo.txt")->openrw_raw;
      $fh = path("foo.txt")->openrw_utf8;
  
  Returns a file handle opened in the specified mode.  The C<openr> style methods
  take a single C<binmode> argument.  All of the C<open*> methods have
  C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  C<:raw:encoding(UTF-8)>, respectively.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  
      $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  
  See L</filehandle> for more on locking.
  
  =head2 parent
  
      $parent = path("foo/bar/baz")->parent; # foo/bar
      $parent = path("foo/wibble.txt")->parent; # foo
  
      $parent = path("foo/bar/baz")->parent(2); # foo
  
  Returns a C<Path::Tiny> object corresponding to the parent directory of the
  original directory or file. An optional positive integer argument is the number
  of parent directories upwards to return.  C<parent> by itself is equivalent to
  C<parent(1)>.
  
  =head2 realpath
  
      $real = path("/baz/foo/../bar")->realpath;
      $real = path("foo/../bar")->realpath;
  
  Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  more expensive as it must actually consult the filesystem.
  
  If the path can't be resolved (e.g. if it includes directories that don't exist),
  an exception will be thrown:
  
      $real = path("doesnt_exist/foo")->realpath; # dies
  
  =head2 relative
  
      $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  
  Returns a C<Path::Tiny> object with a relative path name.
  Given the trickiness of this, it's a thin wrapper around
  C<< File::Spec->abs2rel() >>.
  
  =head2 remove
  
      path("foo.txt")->remove;
  
  B<Note: as of 0.012, remove only works on files>.
  
  This is just like C<unlink>, except if the path does not exist, it returns
  false rather than throwing an exception.
  
  =head2 remove_tree
  
      # directory
      path("foo/bar/baz")->remove_tree;
      path("foo/bar/baz")->remove_tree( \%options );
      path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  
  Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  An optional hash reference is passed through to C<remove_tree>.  Errors will be
  trapped and an exception thrown.  Returns the number of directories deleted,
  just like C<remove_tree>.
  
  If you want to remove a directory only if it is empty, use the built-in
  C<rmdir> function instead.
  
      rmdir path("foo/bar/baz/");
  
  =head2 slurp, slurp_raw, slurp_utf8
  
      $data = path("foo.txt")->slurp;
      $data = path("foo.txt")->slurp( {binmode => ":raw"} );
      $data = path("foo.txt")->slurp_raw;
      $data = path("foo.txt")->slurp_utf8;
  
  Reads file contents into a scalar.  Takes an optional hash reference may be
  used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for reading.
  
  C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  a fast, unbuffered, raw read.
  
  C<slurp_utf8> is like C<slurp> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  slurp will be done instead and the result decoded with C<Unicode::UTF8>.
  This is just as strict and is roughly an order of magnitude faster than
  using C<:encoding(UTF-8)>.
  
  =head2 spew, spew_raw, spew_utf8
  
      path("foo.txt")->spew(@data);
      path("foo.txt")->spew(\@data);
      path("foo.txt")->spew({binmode => ":raw"}, @data);
      path("foo.txt")->spew_raw(@data);
      path("foo.txt")->spew_utf8(@data);
  
  Writes data to a file atomically.  The file is written to a temporary file in
  the same directory, then renamed over the original.  An optional hash reference
  may be used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for writing.
  
  C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  unbuffered, raw write.
  
  C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>.
  If L<Unicode::UTF8> 0.58+ is installed, a raw spew will be done instead on
  the data encoded with C<Unicode::UTF8>.
  
  =head2 stat, lstat
  
      $stat = path("foo.txt")->stat;
      $stat = path("/some/symlink")->lstat;
  
  Like calling C<stat> or C<lstat> from L<File::stat>.
  
  =head2 stringify
  
      $path = path("foo.txt");
      say $path->stringify; # same as "$path"
  
  Returns a string representation of the path.  Unlike C<canonpath>, this method
  returns the path standardized with Unix-style C</> directory separators.
  
  =head2 subsumes
  
      path("foo/bar")->subsumes("foo/bar/baz"); # true
      path("/foo/bar")->subsumes("/foo/baz");   # false
  
  Returns true if the first path is a prefix of the second path at a directory
  boundary.
  
  This B<does not> resolve parent directory entries (C<..>) or symlinks:
  
      path("foo/bar")->subsumes("foo/bar/../baz"); # true
  
  If such things are important to you, ensure that both paths are resolved to
  the filesystem with C<realpath>:
  
      my $p1 = path("foo/bar")->realpath;
      my $p2 = path("foo/bar/../baz")->realpath;
      if ( $p1->subsumes($p2) ) { ... }
  
  =head2 touch
  
      path("foo.txt")->touch;
      path("foo.txt")->touch($epoch_secs);
  
  Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  changes the modification and access times to the current time.  If the first
  argument is the epoch seconds then it will be used.
  
  Returns the path object so it can be easily chained with spew:
  
      path("foo.txt")->touch->spew( $content );
  
  =head2 touchpath
  
      path("bar/baz/foo.txt")->touchpath;
  
  Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  before touching the file.  Returns the path object like C<touch> does.
  
  =head2 volume
  
      $vol = path("/tmp/foo.txt")->volume;   # ""
      $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  
  Returns the volume portion of the path.  This is equivalent
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually is the empty string on Unix-like operating systems or the
  drive letter for an absolute path on C<MSWin32>.
  
  =for Pod::Coverage openr_utf8 opena_utf8 openw_utf8 openrw_utf8
  openr_raw opena_raw openw_raw openrw_raw
  IS_BSD IS_WIN32
  
  =head1 EXCEPTION HANDLING
  
  Failures will be thrown as exceptions in the class C<Path::Tiny::Error>.
  
  The object will be a hash reference with the following fields:
  
  =over 4
  
  =item *
  
  C<op> — a description of the operation, usually function call and any extra info
  
  =item *
  
  C<file> — the file or directory relating to the error
  
  =item *
  
  C<err> — hold C<$!> at the time the error was thrown
  
  =item *
  
  C<msg> — a string combining the above data and a Carp-like short stack trace
  
  =back
  
  Exception objects will stringify as the C<msg> field.
  
  =head1 CAVEATS
  
  =head2 File locking
  
  If flock is not supported on a platform, it will not be used, even if
  locking is requested.
  
  See additional caveats below.
  
  =head3 NFS and BSD
  
  On BSD, Perl's flock implementation may not work to lock files on an
  NFS filesystem.  Path::Tiny has some heuristics to detect this
  and will warn once and let you continue in an unsafe mode.  If you
  want this failure to be fatal, you can fatalize the 'flock' warnings
  category:
  
      use warnings FATAL => 'flock';
  
  =head3 AIX and locking
  
  AIX requires a write handle for locking.  Therefore, calls that normally
  open a read handle and take a shared lock instead will open a read-write
  handle and take an exclusive lock.
  
  =head2 utf8 vs UTF-8
  
  All the C<*_utf8> methods use C<:encoding(UTF-8)> -- either as
  C<:unix:encoding(UTF-8)> (unbuffered) or C<:raw:encoding(UTF-8)> (buffered) --
  which is strict against the Unicode spec and disallows illegal Unicode
  codepoints or UTF-8 sequences.
  
  Unfortunately, C<:encoding(UTF-8)> is very, very slow.  If you install
  L<Unicode::UTF8> 0.58 or later, that module will be used by some C<*_utf8>
  methods to encode or decode data after a raw, binary input/output operation,
  which is much faster.
  
  If you need the performance and can accept the security risk,
  C<< slurp({binmode => ":unix:utf8"}) >> will be faster than C<:unix:encoding(UTF-8)>
  (but not as fast as C<Unicode::UTF8>).
  
  Note that the C<*_utf8> methods read in B<raw> mode.  There is no CRLF
  translation on Windows.  If you must have CRLF translation, use the regular
  input/output methods with an appropriate binmode:
  
    $path->spew_utf8($data);                            # raw
    $path->spew({binmode => ":encoding(UTF-8)"}, $data; # LF -> CRLF
  
  Consider L<PerlIO::utf8_strict> for a faster L<PerlIO> layer alternative to
  C<:encoding(UTF-8)>, though it does not appear to be as fast as the
  C<Unicode::UTF8> approach.
  
  =head2 Default IO layers and the open pragma
  
  If you have Perl 5.10 or later, file input/output methods (C<slurp>, C<spew>,
  etc.) and high-level handle opening methods ( C<filehandle>, C<openr>,
  C<openw>, etc. ) respect default encodings set by the C<-C> switch or lexical
  L<open> settings of the caller.  For UTF-8, this is almost certainly slower
  than using the dedicated C<_utf8> methods if you have L<Unicode::UTF8>.
  
  =head1 TYPE CONSTRAINTS AND COERCION
  
  A standard L<MooseX::Types> library is available at
  L<MooseX::Types::Path::Tiny>.  A L<Type::Tiny> equivalent is available as
  L<Types::Path::Tiny>.
  
  =head1 SEE ALSO
  
  These are other file/path utilities, which may offer a different feature
  set than C<Path::Tiny>.
  
  =over 4
  
  =item *
  
  L<File::Fu>
  
  =item *
  
  L<IO::All>
  
  =item *
  
  L<Path::Class>
  
  =back
  
  These iterators may be slightly faster than the recursive iterator in
  C<Path::Tiny>:
  
  =over 4
  
  =item *
  
  L<Path::Iterator::Rule>
  
  =item *
  
  L<File::Next>
  
  =back
  
  There are probably comparable, non-Tiny tools.  Let me know if you want me to
  add a module to the list.
  
  This module was featured in the L<2013 Perl Advent Calendar|http://www.perladvent.org/2013/2013-12-18.html>.
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Path-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Path-Tiny>
  
    git clone https://github.com/dagolden/Path-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Chris Williams <bingos@cpan.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Gabor Szabo <szabgab@cpan.org>
  
  =item *
  
  Gabriel Andrade <gabiruh@gmail.com>
  
  =item *
  
  George Hartzell <hartzell@cpan.org>
  
  =item *
  
  Geraud Continsouzas <geraud@scsi.nc>
  
  =item *
  
  Goro Fuji <gfuji@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Martin Kjeldsen <mk@bluepipe.dk>
  
  =item *
  
  Michael G. Schwern <mschwern@cpan.org>
  
  =item *
  
  Toby Inkster <tobyink@cpan.org>
  
  =item *
  
  김도형 - Keedi Kim <keedi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
PATH_TINY

$fatpacked{"Test/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_YAML';
  package Test::YAML;
  $Test::YAML::VERSION = '0.90';
  use Test::Base -Base;
  use lib 'lib';
  
  our $YAML    = 'YAML';
  our @EXPORT  = qw(
      no_diff
      run_yaml_tests
      run_roundtrip_nyn roundtrip_nyn
      run_load_passes load_passes
      dumper Load Dump LoadFile DumpFile
      XXX
  );
  
  delimiters('===', '+++');
  
  sub Dump     () { YAML(Dump => @_)     }
  sub Load     () { YAML(Load => @_)     }
  sub DumpFile () { YAML(DumpFile => @_) }
  sub LoadFile () { YAML(LoadFile => @_) }
  
  sub YAML () {
      load_yaml_pm();
      my $meth = shift;
      my $code = $YAML->can($meth) or die "$YAML cannot do $meth";
      goto &$code;
  }
  
  sub load_yaml_pm {
      my $file = "$YAML.pm";
      $file =~ s{::}{/}g;
      require $file;
  }
  
  sub run_yaml_tests() {
      run {
          my $block = shift;
          &{_get_function($block)}($block) unless
            _skip_tests_for_now($block) or
            _skip_yaml_tests($block);
      };
  }
  
  sub run_roundtrip_nyn() {
      my @options = @_;
      run {
          my $block = shift;
          roundtrip_nyn($block, @options);
      };
  }
  
  sub roundtrip_nyn() {
      my $block = shift;
      my $option = shift || '';
      die "'perl' data section required"
          unless exists $block->{perl};
      my @values = eval $block->perl;
      die "roundtrip_nyn eval perl error: $@" if $@;
      my $config = $block->config || '';
      my $result = eval "$config; Dump(\@values)";
      die "roundtrip_nyn YAML::Dump error: $@" if $@;
      if (exists $block->{yaml}) {
          is $result, $block->yaml,
              $block->description . ' (n->y)';
      }
      else {
          pass $block->description . ' (n->y)';
      }
  
      return if exists $block->{no_round_trip} or
          not exists $block->{yaml};
  
      if ($option eq 'dumper') {
          is dumper(Load($block->yaml)), dumper(@values),
              $block->description . ' (y->n)';
      }
      else {
          is_deeply [Load($block->yaml)], [@values],
              $block->description . ' (y->n)';
      }
  }
  
  sub count_roundtrip_nyn() {
      my $block = shift or die "Bad call to count_roundtrip_nyn";
      return 1 if exists $block->{skip_this_for_now};
      my $count = 0;
      $count++ if exists $block->{perl};
      $count++ unless exists $block->{no_round_trip} or
          not exists $block->{yaml};
      die "Invalid test definition" unless $count;
      return $count;
  }
  
  sub run_load_passes() {
      run {
          my $block = shift;
          my $yaml = $block->yaml;
          eval { YAML(Load => $yaml) };
          is("$@", "");
      };
  }
  
  sub load_passes() {
      my $block = shift;
      my $yaml = $block->yaml;
      eval { YAML(Load => $yaml) };
      is "$@", "", $block->description;
  }
  
  sub count_load_passes() {1}
  
  sub dumper() {
      require Data::Dumper;
      $Data::Dumper::Sortkeys = 1;
      $Data::Dumper::Terse = 1;
      $Data::Dumper::Indent = 1;
      return Data::Dumper::Dumper(@_);
  }
  
  sub _count_tests() {
      my $block = shift or die "Bad call to _count_tests";
      no strict 'refs';
      &{'count_' . _get_function_name($block)}($block);
  }
  
  sub _get_function_name() {
      my $block = shift;
      return $block->function || 'roundtrip_nyn';
  }
  
  sub _get_function() {
      my $block = shift;
      no strict 'refs';
      \ &{_get_function_name($block)};
  }
  
  sub _skip_tests_for_now() {
      my $block = shift;
      if (exists $block->{skip_this_for_now}) {
          _skip_test(
              $block->description,
              _count_tests($block),
          );
          return 1;
      }
      return 0;
  }
  
  sub _skip_yaml_tests() {
      my $block = shift;
      if ($block->skip_unless_modules) {
          my @modules = split /[\s\,]+/, $block->skip_unless_modules;
          for my $module (@modules) {
              eval "require $module";
              if ($@) {
                  _skip_test(
                      "This test requires the '$module' module",
                      _count_tests($block),
                  );
                  return 1;
              }
          }
      }
      return 0;
  }
  
  sub _skip_test() {
      my ($message, $count) = @_;
      SKIP: {
          skip($message, $count);
      }
  }
  
  #-------------------------------------------------------------------------------
  package Test::YAML::Filter;
  $Test::YAML::Filter::VERSION = '0.90';
  use Test::Base::Filter ();
  
  our @ISA = 'Test::Base::Filter';
  
  sub yaml_dump {
      Test::YAML::Dump(@_);
  }
  
  sub yaml_load {
      Test::YAML::Load(@_);
  }
  
  sub Dump { goto &Test::YAML::Dump }
  sub Load { goto &Test::YAML::Load }
  sub DumpFile { goto &Test::YAML::DumpFile }
  sub LoadFile { goto &Test::YAML::LoadFile }
  
  sub yaml_load_or_fail {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $result;
  }
  
  sub yaml_load_error_or_warning {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub perl_eval_error_or_warning {
      my ($result, $error, $warning) =
        $self->_perl_eval_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub _yaml_load_result_error_warning {
      $self->assert_scalar(@_);
      my $yaml = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval {
          $self->yaml_load($yaml);
      };
      return ($result, $@, $warning);
  }
  
  sub _perl_eval_result_error_warning {
      $self->assert_scalar(@_);
      my $perl = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval $perl;
      return ($result, $@, $warning);
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  Test::YAML - Testing Module for YAML Implementations
  
  =head1 SYNOPSIS
  
      use Test::YAML tests => 1;
  
      pass;
  
  =head1 DESCRIPTION
  
  Test::YAML is a subclass of Test::Base with YAML specific support.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
TEST_YAML

$fatpacked{"YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML';
  use 5.008001;
  package YAML;
  $YAML::VERSION = '0.90';
  use YAML::Mo;
  
  use Exporter;
  push @YAML::ISA, 'Exporter';
  our @EXPORT = qw{ Dump Load };
  our @EXPORT_OK = qw{ freeze thaw DumpFile LoadFile Bless Blessed };
  
  use YAML::Node; # XXX This is a temp fix for Module::Build
  
  # XXX This VALUE nonsense needs to go.
  use constant VALUE => "\x07YAML\x07VALUE\x07";
  
  # YAML Object Properties
  has dumper_class => default => sub {'YAML::Dumper'};
  has loader_class => default => sub {'YAML::Loader'};
  has dumper_object => default => sub {$_[0]->init_action_object("dumper")};
  has loader_object => default => sub {$_[0]->init_action_object("loader")};
  
  sub Dump {
      my $yaml = YAML->new;
      $yaml->dumper_class($YAML::DumperClass)
          if $YAML::DumperClass;
      return $yaml->dumper_object->dump(@_);
  }
  
  sub Load {
      my $yaml = YAML->new;
      $yaml->loader_class($YAML::LoaderClass)
          if $YAML::LoaderClass;
      return $yaml->loader_object->load(@_);
  }
  
  {
      no warnings 'once';
      # freeze/thaw is the API for Storable string serialization. Some
      # modules make use of serializing packages on if they use freeze/thaw.
      *freeze = \ &Dump;
      *thaw   = \ &Load;
  }
  
  sub DumpFile {
      my $OUT;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $OUT = $filename;
      }
      else {
          my $mode = '>';
          if ($filename =~ /^\s*(>{1,2})\s*(.*)$/) {
              ($mode, $filename) = ($1, $2);
          }
          open $OUT, $mode, $filename
            or YAML::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT', $filename, $!);
      }
      binmode $OUT, ':utf8';  # if $Config{useperlio} eq 'define';
      local $/ = "\n"; # reset special to "sane"
      print $OUT Dump(@_);
  }
  
  sub LoadFile {
      my $IN;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $IN = $filename;
      }
      else {
          open $IN, '<', $filename
            or YAML::Mo::Object->die('YAML_LOAD_ERR_FILE_INPUT', $filename, $!);
      }
      binmode $IN, ':utf8';  # if $Config{useperlio} eq 'define';
      return Load(do { local $/; <$IN> });
  }
  
  sub init_action_object {
      my $self = shift;
      my $object_class = (shift) . '_class';
      my $module_name = $self->$object_class;
      eval "require $module_name";
      $self->die("Error in require $module_name - $@")
          if $@ and "$@" !~ /Can't locate/;
      my $object = $self->$object_class->new;
      $object->set_global_options;
      return $object;
  }
  
  my $global = {};
  sub Bless {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::bless($global, @_)
  }
  sub Blessed {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::blessed($global, @_)
  }
  sub global_object { $global }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML - YAML Ain't Markup Language (tm)
  
  =head1 NOTE
  
  This module has been released to CPAN as YAML::Old, and soon YAML.pm
  will be changed to just be a frontend interface module for all the
  various Perl YAML implementation modules, including YAML::Old.
  
  If you want robust and fast YAML processing using the normal Dump/Load
  API, please consider switching to YAML::XS. It is by far the best Perl
  module for YAML at this time. It requires that you have a C compiler,
  since it is written in C.
  
  If you really need to use this version of YAML.pm it will always be
  available as YAML::Old.
  
  If you don't care which YAML module use, as long as it's the best one
  installed on your system, use YAML::Any.
  
  The rest of this documentation is left unchanged, until YAML.pm is
  switched over to the new UI-only version.
  
  =head1 SYNOPSIS
  
      use YAML;
  
      # Load a YAML stream of 3 YAML documents into Perl data structures.
      my ($hashref, $arrayref, $string) = Load(<<'...');
      ---
      name: ingy
      age: old
      weight: heavy
      # I should comment that I also like pink, but don't tell anybody.
      favorite colors:
          - red
          - green
          - blue
      ---
      - Clark Evans
      - Oren Ben-Kiki
      - Ingy döt Net
      --- >
      You probably think YAML stands for "Yet Another Markup Language". It
      ain't! YAML is really a data serialization language. But if you want
      to think of it as a markup, that's OK with me. A lot of people try
      to use XML as a serialization format.
  
      "YAML" is catchy and fun to say. Try it. "YAML, YAML, YAML!!!"
      ...
  
      # Dump the Perl data structures back into YAML.
      print Dump($string, $arrayref, $hashref);
  
      # YAML::Dump is used the same way you'd use Data::Dumper::Dumper
      use Data::Dumper;
      print Dumper($string, $arrayref, $hashref);
  
  =head1 DESCRIPTION
  
  The YAML.pm module implements a YAML Loader and Dumper based on the YAML
  1.0 specification. L<http://www.yaml.org/spec/>
  
  YAML is a generic data serialization language that is optimized for
  human readability. It can be used to express the data structures of most
  modern programming languages. (Including Perl!!!)
  
  For information on the YAML syntax, please refer to the YAML
  specification.
  
  =head1 WHY YAML IS COOL
  
  =over 4
  
  =item YAML is readable for people.
  
  It makes clear sense out of complex data structures. You should find
  that YAML is an exceptional data dumping tool. Structure is shown
  through indentation, YAML supports recursive data, and hash keys are
  sorted by default. In addition, YAML supports several styles of scalar
  formatting for different types of data.
  
  =item YAML is editable.
  
  YAML was designed from the ground up to be an excellent syntax for
  configuration files. Almost all programs need configuration files, so
  why invent a new syntax for each one? And why subject users to the
  complexities of XML or native Perl code?
  
  =item YAML is multilingual.
  
  Yes, YAML supports Unicode. But I'm actually referring to programming
  languages. YAML was designed to meet the serialization needs of Perl,
  Python, Ruby, Tcl, PHP, Javascript and Java. It was also designed to be
  interoperable between those languages. That means YAML serializations
  produced by Perl can be processed by Python.
  
  =item YAML is taint safe.
  
  Using modules like Data::Dumper for serialization is fine as long as you
  can be sure that nobody can tamper with your data files or
  transmissions. That's because you need to use Perl's C<eval()> built-in
  to deserialize the data. Somebody could add a snippet of Perl to erase
  your files.
  
  YAML's parser does not need to eval anything.
  
  =item YAML is full featured.
  
  YAML can accurately serialize all of the common Perl data structures and
  deserialize them again without losing data relationships. Although it is
  not 100% perfect (no serializer is or can be perfect), it fares as well
  as the popular current modules: Data::Dumper, Storable, XML::Dumper and
  Data::Denter.
  
  YAML.pm also has the ability to handle code (subroutine) references and
  typeglobs. (Still experimental) These features are not found in Perl's
  other serialization modules.
  
  =item YAML is extensible.
  
  The YAML language has been designed to be flexible enough to solve it's
  own problems. The markup itself has 3 basic construct which resemble
  Perl's hash, array and scalar. By default, these map to their Perl
  equivalents. But each YAML node also supports a tagging mechanism (type
  system) which can cause that node to be interpreted in a completely
  different manner. That's how YAML can support object serialization and
  oddball structures like Perl's typeglob.
  
  =back
  
  =head1 YAML IMPLEMENTATIONS IN PERL
  
  This module, YAML.pm, is really just the interface module for YAML
  modules written in Perl. The basic interface for YAML consists of two
  functions: C<Dump> and C<Load>. The real work is done by the modules
  YAML::Dumper and YAML::Loader.
  
  Different YAML module distributions can be created by subclassing
  YAML.pm and YAML::Loader and YAML::Dumper. For example, YAML-Simple
  consists of YAML::Simple YAML::Dumper::Simple and YAML::Loader::Simple.
  
  Why would there be more than one implementation of YAML? Well, despite
  YAML's offering of being a simple data format, YAML is actually very
  deep and complex. Implementing the entirety of the YAML specification is
  a daunting task.
  
  For this reason I am currently working on 3 different YAML implementations.
  
  =over
  
  =item YAML
  
  The main YAML distribution will keeping evolving to support the entire
  YAML specification in pure Perl. This may not be the fastest or most
  stable module though. Currently, YAML.pm has lots of known bugs. It is
  mostly a great tool for dumping Perl data structures to a readable form.
  
  =item YAML::Tiny
  
  The point of YAML::Tiny is to strip YAML down to the 90% that people
  use most and offer that in a small, fast, stable, pure Perl form.
  YAML::Tiny will simply die when it is asked to do something it can't.
  
  =item YAML::Syck
  
  C<libsyck> is the C based YAML processing library used by the Ruby
  programming language (and also Python, PHP and Pugs). YAML::Syck is the
  Perl binding to C<libsyck>. It should be very fast, but may have
  problems of its own. It will also require C compilation.
  
  NOTE: Audrey Tang has actually completed this module and it works great
        and is 10 times faster than YAML.pm.
  
  =back
  
  In the future, there will likely be even more YAML modules. Remember,
  people other than Ingy are allowed to write YAML modules!
  
  =head1 FUNCTIONAL USAGE
  
  YAML is completely OO under the hood. Still it exports a few useful top
  level functions so that it is dead simple to use. These functions just
  do the OO stuff for you. If you want direct access to the OO API see the
  documentation for YAML::Dumper and YAML::Loader.
  
  =head2 Exported Functions
  
  The following functions are exported by YAML.pm by default. The reason
  they are exported is so that YAML works much like Data::Dumper. If you
  don't want functions to be imported, just use YAML with an empty
  import list:
  
      use YAML ();
  
  =over 4
  
  =item Dump(list-of-Perl-data-structures)
  
  Turn Perl data into YAML. This function works very much like
  Data::Dumper::Dumper(). It takes a list of Perl data structures and
  dumps them into a serialized form. It returns a string containing the
  YAML stream. The structures can be references or plain scalars.
  
  =item Load(string-containing-a-YAML-stream)
  
  Turn YAML into Perl data. This is the opposite of Dump. Just like
  Storable's thaw() function or the eval() function in relation to
  Data::Dumper. It parses a string containing a valid YAML stream into a
  list of Perl data structures.
  
  =back
  
  =head2 Exportable Functions
  
  These functions are not exported by default but you can request them in
  an import list like this:
  
      use YAML qw'freeze thaw Bless';
  
  =over 4
  
  =item freeze() and thaw()
  
  Aliases to Dump() and Load() for Storable fans. This will also allow
  YAML.pm to be plugged directly into modules like POE.pm, that use the
  freeze/thaw API for internal serialization.
  
  =item DumpFile(filepath, list)
  
  Writes the YAML stream to a file instead of just returning a string.
  
  =item LoadFile(filepath)
  
  Reads the YAML stream from a file instead of a string.
  
  =item Bless(perl-node, [yaml-node | class-name])
  
  Associate a normal Perl node, with a yaml node. A yaml node is an object
  tied to the YAML::Node class. The second argument is either a yaml node
  that you've already created or a class (package) name that supports a
  yaml_dump() function. A yaml_dump() function should take a perl node and
  return a yaml node. If no second argument is provided, Bless will create
  a yaml node. This node is not returned, but can be retrieved with the
  Blessed() function.
  
  Here's an example of how to use Bless. Say you have a hash containing
  three keys, but you only want to dump two of them. Furthermore the keys
  must be dumped in a certain order. Here's how you do that:
  
      use YAML qw(Dump Bless);
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash)->keys(['banana', 'apple']);
      print Dump $hash;
  
  produces:
  
      ---
      apple: good
      banana: bad
      cauliflower: ugly
      ---
      banana: bad
      apple: good
  
  Bless returns the tied part of a yaml-node, so that you can call the
  YAML::Node methods. This is the same thing that YAML::Node::ynode()
  returns. So another way to do the above example is:
  
      use YAML qw(Dump Bless);
      use YAML::Node;
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash);
      $ynode = ynode(Blessed($hash));
      $ynode->keys(['banana', 'apple']);
      print Dump $hash;
  
  Note that Blessing a Perl data structure does not change it anyway. The
  extra information is stored separately and looked up by the Blessed
  node's memory address.
  
  =item Blessed(perl-node)
  
  Returns the yaml node that a particular perl node is associated with
  (see above). Returns undef if the node is not (YAML) Blessed.
  
  =back
  
  =head1 GLOBAL OPTIONS
  
  YAML options are set using a group of global variables in the YAML
  namespace. This is similar to how Data::Dumper works.
  
  For example, to change the indentation width, do something like:
  
      local $YAML::Indent = 3;
  
  The current options are:
  
  =over 4
  
  =item DumperClass
  
  You can override which module/class YAML uses for Dumping data.
  
  =item LoaderClass
  
  You can override which module/class YAML uses for Loading data.
  
  =item Indent
  
  This is the number of space characters to use for each indentation level
  when doing a Dump(). The default is 2.
  
  By the way, YAML can use any number of characters for indentation at any
  level. So if you are editing YAML by hand feel free to do it anyway that
  looks pleasing to you; just be consistent for a given level.
  
  =item SortKeys
  
  Default is 1. (true)
  
  Tells YAML.pm whether or not to sort hash keys when storing a document.
  
  YAML::Node objects can have their own sort order, which is usually what
  you want. To override the YAML::Node order and sort the keys anyway, set
  SortKeys to 2.
  
  =item Stringify
  
  Default is 0. (false)
  
  Objects with string overloading should honor the overloading and dump the
  stringification of themselves, rather than the actual object's guts.
  
  =item UseHeader
  
  Default is 1. (true)
  
  This tells YAML.pm whether to use a separator string for a Dump
  operation. This only applies to the first document in a stream.
  Subsequent documents must have a YAML header by definition.
  
  =item UseVersion
  
  Default is 0. (false)
  
  Tells YAML.pm whether to include the YAML version on the
  separator/header.
  
      --- %YAML:1.0
  
  =item AnchorPrefix
  
  Default is ''.
  
  Anchor names are normally numeric. YAML.pm simply starts with '1' and
  increases by one for each new anchor. This option allows you to specify a
  string to be prepended to each anchor number.
  
  =item UseCode
  
  Setting the UseCode option is a shortcut to set both the DumpCode and
  LoadCode options at once. Setting UseCode to '1' tells YAML.pm to dump
  Perl code references as Perl (using B::Deparse) and to load them back
  into memory using eval(). The reason this has to be an option is that
  using eval() to parse untrusted code is, well, untrustworthy.
  
  =item DumpCode
  
  Determines if and how YAML.pm should serialize Perl code references. By
  default YAML.pm will dump code references as dummy placeholders (much
  like Data::Dumper). If DumpCode is set to '1' or 'deparse', code
  references will be dumped as actual Perl code.
  
  DumpCode can also be set to a subroutine reference so that you can
  write your own serializing routine. YAML.pm passes you the code ref. You
  pass back the serialization (as a string) and a format indicator. The
  format indicator is a simple string like: 'deparse' or 'bytecode'.
  
  =item LoadCode
  
  LoadCode is the opposite of DumpCode. It tells YAML if and how to
  deserialize code references. When set to '1' or 'deparse' it will use
  C<eval()>. Since this is potentially risky, only use this option if you
  know where your YAML has been.
  
  LoadCode can also be set to a subroutine reference so that you can write
  your own deserializing routine. YAML.pm passes the serialization (as a
  string) and a format indicator. You pass back the code reference.
  
  =item UseBlock
  
  YAML.pm uses heuristics to guess which scalar style is best for a given
  node. Sometimes you'll want all multiline scalars to use the 'block'
  style. If so, set this option to 1.
  
  NOTE: YAML's block style is akin to Perl's here-document.
  
  =item UseFold
  
  If you want to force YAML to use the 'folded' style for all multiline
  scalars, then set $UseFold to 1.
  
  NOTE: YAML's folded style is akin to the way HTML folds text,
        except smarter.
  
  =item UseAliases
  
  YAML has an alias mechanism such that any given structure in memory gets
  serialized once. Any other references to that structure are serialized
  only as alias markers. This is how YAML can serialize duplicate and
  recursive structures.
  
  Sometimes, when you KNOW that your data is nonrecursive in nature, you
  may want to serialize such that every node is expressed in full. (ie as
  a copy of the original). Setting $YAML::UseAliases to 0 will allow you
  to do this. This also may result in faster processing because the lookup
  overhead is by bypassed.
  
  THIS OPTION CAN BE DANGEROUS. *If* your data is recursive, this option
  *will* cause Dump() to run in an endless loop, chewing up your computers
  memory. You have been warned.
  
  =item CompressSeries
  
  Default is 1.
  
  Compresses the formatting of arrays of hashes:
  
      -
        foo: bar
      -
        bar: foo
  
  becomes:
  
      - foo: bar
      - bar: foo
  
  Since this output is usually more desirable, this option is turned on by
  default.
  
  =back
  
  =head1 YAML TERMINOLOGY
  
  YAML is a full featured data serialization language, and thus has its
  own terminology.
  
  It is important to remember that although YAML is heavily influenced by
  Perl and Python, it is a language in its own right, not merely just a
  representation of Perl structures.
  
  YAML has three constructs that are conspicuously similar to Perl's hash,
  array, and scalar. They are called mapping, sequence, and string
  respectively. By default, they do what you would expect. But each
  instance may have an explicit or implicit tag (type) that makes it
  behave differently. In this manner, YAML can be extended to represent
  Perl's Glob or Python's tuple, or Ruby's Bigint.
  
  =over 4
  
  =item stream
  
  A YAML stream is the full sequence of Unicode characters that a YAML
  parser would read or a YAML emitter would write. A stream may contain
  one or more YAML documents separated by YAML headers.
  
      ---
      a: mapping
      foo: bar
      ---
      - a
      - sequence
  
  =item document
  
  A YAML document is an independent data structure representation within a
  stream. It is a top level node. Each document in a YAML stream must
  begin with a YAML header line. Actually the header is optional on the
  first document.
  
      ---
      This: top level mapping
      is:
          - a
          - YAML
          - document
  
  =item header
  
  A YAML header is a line that begins a YAML document. It consists of
  three dashes, possibly followed by more info. Another purpose of the
  header line is that it serves as a place to put top level tag and anchor
  information.
  
      --- !recursive-sequence &001
      - * 001
      - * 001
  
  =item node
  
  A YAML node is the representation of a particular data structure. Nodes
  may contain other nodes. (In Perl terms, nodes are like scalars.
  Strings, arrayrefs and hashrefs. But this refers to the serialized
  format, not the in-memory structure.)
  
  =item tag
  
  This is similar to a type. It indicates how a particular YAML node
  serialization should be transferred into or out of memory. For instance
  a Foo::Bar object would use the tag 'perl/Foo::Bar':
  
      - !perl/Foo::Bar
          foo: 42
          bar: stool
  
  =item collection
  
  A collection is the generic term for a YAML data grouping. YAML has two
  types of collections: mappings and sequences. (Similar to hashes and arrays)
  
  =item mapping
  
  A mapping is a YAML collection defined by unordered key/value pairs with
  unique keys. By default YAML mappings are loaded into Perl hashes.
  
      a mapping:
          foo: bar
          two: times two is 4
  
  =item sequence
  
  A sequence is a YAML collection defined by an ordered list of elements. By
  default YAML sequences are loaded into Perl arrays.
  
      a sequence:
          - one bourbon
          - one scotch
          - one beer
  
  =item scalar
  
  A scalar is a YAML node that is a single value. By default YAML scalars
  are loaded into Perl scalars.
  
      a scalar key: a scalar value
  
  YAML has many styles for representing scalars. This is important because
  varying data will have varying formatting requirements to retain the
  optimum human readability.
  
  =item plain scalar
  
  A plain scalar is unquoted. All plain scalars are automatic candidates
  for "implicit tagging". This means that their tag may be determined
  automatically by examination. The typical uses for this are plain alpha
  strings, integers, real numbers, dates, times and currency.
  
      - a plain string
      - -42
      - 3.1415
      - 12:34
      - 123 this is an error
  
  =item single quoted scalar
  
  This is similar to Perl's use of single quotes. It means no escaping
  except for single quotes which are escaped by using two adjacent
  single quotes.
  
      - 'When I say ''\n'' I mean "backslash en"'
  
  =item double quoted scalar
  
  This is similar to Perl's use of double quotes. Character escaping can
  be used.
  
      - "This scalar\nhas two lines, and a bell -->\a"
  
  =item folded scalar
  
  This is a multiline scalar which begins on the next line. It is
  indicated by a single right angle bracket. It is unescaped like the
  single quoted scalar. Line folding is also performed.
  
      - >
       This is a multiline scalar which begins on
       the next line. It is indicated by a single
       carat. It is unescaped like the single
       quoted scalar. Line folding is also
       performed.
  
  =item block scalar
  
  This final multiline form is akin to Perl's here-document except that
  (as in all YAML data) scope is indicated by indentation. Therefore, no
  ending marker is required. The data is verbatim. No line folding.
  
      - |
          QTY  DESC          PRICE  TOTAL
          ---  ----          -----  -----
            1  Foo Fighters  $19.95 $19.95
            2  Bar Belles    $29.95 $59.90
  
  =item parser
  
  A YAML processor has four stages: parse, load, dump, emit.
  
  A parser parses a YAML stream. YAML.pm's Load() function contains a
  parser.
  
  =item loader
  
  The other half of the Load() function is a loader. This takes the
  information from the parser and loads it into a Perl data structure.
  
  =item dumper
  
  The Dump() function consists of a dumper and an emitter. The dumper
  walks through each Perl data structure and gives info to the emitter.
  
  =item emitter
  
  The emitter takes info from the dumper and turns it into a YAML stream.
  
  NOTE:
  In YAML.pm the parser/loader and the dumper/emitter code are currently
  very closely tied together. In the future they may be broken into
  separate stages.
  
  =back
  
  For more information please refer to the immensely helpful YAML
  specification available at L<http://www.yaml.org/spec/>.
  
  =head1 ysh - The YAML Shell
  
  The YAML distribution ships with a script called 'ysh', the YAML shell.
  ysh provides a simple, interactive way to play with YAML. If you type in
  Perl code, it displays the result in YAML. If you type in YAML it turns
  it into Perl code.
  
  To run ysh, (assuming you installed it along with YAML.pm) simply type:
  
      ysh [options]
  
  Please read the C<ysh> documentation for the full details. There are
  lots of options.
  
  =head1 BUGS & DEFICIENCIES
  
  If you find a bug in YAML, please try to recreate it in the YAML Shell
  with logging turned on ('ysh -L'). When you have successfully reproduced
  the bug, please mail the LOG file to the author (ingy@cpan.org).
  
  WARNING: This is still *ALPHA* code. Well, most of this code has been
  around for years...
  
  BIGGER WARNING: YAML.pm has been slow in the making, but I am committed
  to having top notch YAML tools in the Perl world. The YAML team is close
  to finalizing the YAML 1.1 spec. This version of YAML.pm is based off of
  a very old pre 1.0 spec. In actuality there isn't a ton of difference,
  and this YAML.pm is still fairly useful. Things will get much better in
  the future.
  
  =head1 RESOURCES
  
  L<http://lists.sourceforge.net/lists/listinfo/yaml-core> is the mailing
  list. This is where the language is discussed and designed.
  
  L<http://www.yaml.org> is the official YAML website.
  
  L<http://www.yaml.org/spec/> is the YAML 1.0 specification.
  
  L<http://yaml.kwiki.org> is the official YAML wiki.
  
  =head1 SEE ALSO
  
  See YAML::XS. Fast!
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  is responsible for YAML.pm.
  
  The YAML serialization language is the result of years of collaboration
  between Oren Ben-Kiki, Clark Evans and Ingy döt Net. Several others
  have added help along the way.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005, 2006, 2008, 2011-2014. Ingy döt Net.
  
  Copyright (c) 2001, 2002, 2005. Brian Ingerson.
  
  Some parts copyright (c) 2009 - 2010 Adam Kennedy
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML

$fatpacked{"YAML/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ANY';
  package YAML::Any;
  $YAML::Any::VERSION = '0.90';
  use strict;
  use Exporter ();
  
  @YAML::Any::ISA       = 'Exporter';
  @YAML::Any::EXPORT    = qw(Dump Load);
  @YAML::Any::EXPORT_OK = qw(DumpFile LoadFile);
  
  my @dump_options = qw(
      UseCode
      DumpCode
      SpecVersion
      Indent
      UseHeader
      UseVersion
      SortKeys
      AnchorPrefix
      UseBlock
      UseFold
      CompressSeries
      InlineSeries
      UseAliases
      Purity
      Stringify
  );
  
  my @load_options = qw(
      UseCode
      LoadCode
  );
  
  my @implementations = qw(
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  );
  
  sub import {
      __PACKAGE__->implementation;
      goto &Exporter::import;
  }
  
  sub Dump {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Dump"}(@_);
  }
  
  sub DumpFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::DumpFile"}(@_);
  }
  
  sub Load {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Load"}(@_);
  }
  
  sub LoadFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::LoadFile"}(@_);
  }
  
  sub order {
      return @YAML::Any::_TEST_ORDER
          if @YAML::Any::_TEST_ORDER;
      return @implementations;
  }
  
  sub implementation {
      my @order = __PACKAGE__->order;
      for my $module (@order) {
          my $path = $module;
          $path =~ s/::/\//g;
          $path .= '.pm';
          return $module if exists $INC{$path};
          eval "require $module; 1" and return $module;
      }
      croak("YAML::Any couldn't find any of these YAML implementations: @order");
  }
  
  sub croak {
      require Carp;
      Carp::Croak(@_);
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Any - Pick a YAML implementation and use it.
  
  =head1 SYNOPSIS
  
      use YAML::Any;
      $YAML::Indent = 3;
      my $yaml = Dump(@objects);
  
  =head1 DESCRIPTION
  
  There are several YAML implementations that support the Dump/Load API.
  This module selects the best one available and uses it.
  
  =head1 ORDER
  
  Currently, YAML::Any will choose the first one of these YAML
  implementations that is installed on your system:
  
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  
  =head1 OPTIONS
  
  If you specify an option like:
  
      $YAML::Indent = 4;
  
  And YAML::Any is using YAML::XS, it will use the proper variable:
  $YAML::XS::Indent.
  
  =head1 SUBROUTINES
  
  Like all the YAML modules that YAML::Any uses, the following subroutines
  are exported by default:
  
      Dump
      Load
  
  and the following subroutines are exportable by request:
  
      DumpFile
      LoadFile
  
  =head1 METHODS
  
  YAML::Any provides the following class methods.
  
  =over
  
  =item YAML::Any->order;
  
  This method returns a list of the current possible implementations that
  YAML::Any will search for.
  
  =item YAML::Any->implementation;
  
  This method returns the implementation the YAML::Any will use. This
  result is obtained by finding the first member of YAML::Any->order that
  is either already loaded in C<%INC> or that can be loaded using
  C<require>. If no implementation is found, an error will be thrown.
  
  =back
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008, 2014. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ANY

$fatpacked{"YAML/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER';
  package YAML::Dumper;
  $YAML::Dumper::VERSION = '0.90';
  use YAML::Mo;
  extends 'YAML::Dumper::Base';
  
  use YAML::Dumper::Base;
  use YAML::Node;
  use YAML::Types;
  
  # Context constants
  use constant KEY       => 3;
  use constant BLESSED   => 4;
  use constant FROMARRAY => 5;
  use constant VALUE     => "\x07YAML\x07VALUE\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $LIT_CHAR    = '|';
  
  #==============================================================================
  # OO version of Dump. YAML->new->dump($foo);
  sub dump {
      my $self = shift;
      $self->stream('');
      $self->document(0);
      for my $document (@_) {
          $self->{document}++;
          $self->transferred({});
          $self->id_refcnt({});
          $self->id_anchor({});
          $self->anchor(1);
          $self->level(0);
          $self->offset->[0] = 0 - $self->indent_width;
          $self->_prewalk($document);
          $self->_emit_header($document);
          $self->_emit_node($document);
      }
      return $self->stream;
  }
  
  # Every YAML document in the stream must begin with a YAML header, unless
  # there is only a single document and the user requests "no header".
  sub _emit_header {
      my $self = shift;
      my ($node) = @_;
      if (not $self->use_header and
          $self->document == 1
         ) {
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            unless ref($node) =~ /^(HASH|ARRAY)$/;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'HASH' and keys(%$node) == 0;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'ARRAY' and @$node == 0;
          # XXX Also croak if aliased, blessed, or ynode
          $self->headless(1);
          return;
      }
      $self->{stream} .= '---';
  # XXX Consider switching to 1.1 style
      if ($self->use_version) {
  #         $self->{stream} .= " #YAML:1.0";
      }
  }
  
  # Walk the tree to be dumped and keep track of its reference counts.
  # This function is where the Dumper does all its work. All type
  # transfers happen here.
  sub _prewalk {
      my $self = shift;
      my $stringify = $self->stringify;
      my ($class, $type, $node_id) = $self->node_info(\$_[0], $stringify);
  
      # Handle typeglobs
      if ($type eq 'GLOB') {
          $self->transferred->{$node_id} =
            YAML::Type::glob->yaml_dump($_[0]);
          $self->_prewalk($self->transferred->{$node_id});
          return;
      }
  
      # Handle regexps
      if (ref($_[0]) eq 'Regexp') {
          return;
      }
  
      # Handle Purity for scalars.
      # XXX can't find a use case yet. Might be YAGNI.
      if (not ref $_[0]) {
          $self->{id_refcnt}{$node_id}++ if $self->purity;
          return;
      }
  
      # Make a copy of original
      my $value = $_[0];
      ($class, $type, $node_id) = $self->node_info($value, $stringify);
  
      # Must be a stringified object.
      return if (ref($value) and not $type);
  
      # Look for things already transferred.
      if ($self->transferred->{$node_id}) {
          (undef, undef, $node_id) = (ref $self->transferred->{$node_id})
            ? $self->node_info($self->transferred->{$node_id}, $stringify)
            : $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle code refs
      if ($type eq 'CODE') {
          $self->transferred->{$node_id} = 'placeholder';
          YAML::Type::code->yaml_dump(
              $self->dump_code,
              $_[0],
              $self->transferred->{$node_id}
          );
          ($class, $type, $node_id) =
            $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle blessed things
      if (defined $class) {
          if ($value->can('yaml_dump')) {
              $value = $value->yaml_dump;
          }
          elsif ($type eq 'SCALAR') {
              $self->transferred->{$node_id} = 'placeholder';
              YAML::Type::blessed->yaml_dump
                ($_[0], $self->transferred->{$node_id});
              ($class, $type, $node_id) =
                $self->node_info(\ $self->transferred->{$node_id}, $stringify);
              $self->{id_refcnt}{$node_id}++;
              return;
          }
          else {
              $value = YAML::Type::blessed->yaml_dump($value);
          }
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle YAML Blessed things
      require YAML;
      if (defined YAML->global_object()->{blessed_map}{$node_id}) {
          $value = YAML->global_object()->{blessed_map}{$node_id};
          $self->transferred->{$node_id} = $value;
          ($class, $type, $node_id) = $self->node_info($value, $stringify);
          $self->_prewalk($value);
          return;
      }
  
      # Handle hard refs
      if ($type eq 'REF' or $type eq 'SCALAR') {
          $value = YAML::Type::ref->yaml_dump($value);
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle ref-to-glob's
      elsif ($type eq 'GLOB') {
          my $ref_ynode = $self->transferred->{$node_id} =
            YAML::Type::ref->yaml_dump($value);
  
          my $glob_ynode = $ref_ynode->{&VALUE} =
            YAML::Type::glob->yaml_dump($$value);
  
          (undef, undef, $node_id) = $self->node_info($glob_ynode, $stringify);
          $self->transferred->{$node_id} = $glob_ynode;
          $self->_prewalk($glob_ynode);
          return;
      }
  
      # Increment ref count for node
      return if ++($self->{id_refcnt}{$node_id}) > 1;
  
      # Keep on walking
      if ($type eq 'HASH') {
          $self->_prewalk($value->{$_})
              for keys %{$value};
          return;
      }
      elsif ($type eq 'ARRAY') {
          $self->_prewalk($_)
              for @{$value};
          return;
      }
  
      # Unknown type. Need to know about it.
      $self->warn(<<"...");
  YAML::Dumper can't handle dumping this type of data.
  Please report this to the author.
  
  id:    $node_id
  type:  $type
  class: $class
  value: $value
  
  ...
  
      return;
  }
  
  # Every data element and sub data element is a node.
  # Everything emitted goes through this function.
  sub _emit_node {
      my $self = shift;
      my ($type, $node_id);
      my $ref = ref($_[0]);
      if ($ref) {
          if ($ref eq 'Regexp') {
              $self->_emit(' !!perl/regexp');
              $self->_emit_str("$_[0]");
              return;
          }
          (undef, $type, $node_id) = $self->node_info($_[0], $self->stringify);
      }
      else {
          $type = $ref || 'SCALAR';
          (undef, undef, $node_id) = $self->node_info(\$_[0], $self->stringify);
      }
  
      my ($ynode, $tag) = ('') x 2;
      my ($value, $context) = (@_, 0);
  
      if (defined $self->transferred->{$node_id}) {
          $value = $self->transferred->{$node_id};
          $ynode = ynode($value);
          if (ref $value) {
              $tag = defined $ynode ? $ynode->tag->short : '';
              (undef, $type, $node_id) =
                $self->node_info($value, $self->stringify);
          }
          else {
              $ynode = ynode($self->transferred->{$node_id});
              $tag = defined $ynode ? $ynode->tag->short : '';
              $type = 'SCALAR';
              (undef, undef, $node_id) =
                $self->node_info(
                    \ $self->transferred->{$node_id},
                    $self->stringify
                );
          }
      }
      elsif ($ynode = ynode($value)) {
          $tag = $ynode->tag->short;
      }
  
      if ($self->use_aliases) {
          $self->{id_refcnt}{$node_id} ||= 0;
          if ($self->{id_refcnt}{$node_id} > 1) {
              if (defined $self->{id_anchor}{$node_id}) {
                  $self->{stream} .= ' *' . $self->{id_anchor}{$node_id} . "\n";
                  return;
              }
              my $anchor = $self->anchor_prefix . $self->{anchor}++;
              $self->{stream} .= ' &' . $anchor;
              $self->{id_anchor}{$node_id} = $anchor;
          }
      }
  
      return $self->_emit_str("$value")   # Stringified object
        if ref($value) and not $type;
      return $self->_emit_scalar($value, $tag)
        if $type eq 'SCALAR' and $tag;
      return $self->_emit_str($value)
        if $type eq 'SCALAR';
      return $self->_emit_mapping($value, $tag, $node_id, $context)
        if $type eq 'HASH';
      return $self->_emit_sequence($value, $tag)
        if $type eq 'ARRAY';
      $self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE', $type);
      return $self->_emit_str("$value");
  }
  
  # A YAML mapping is akin to a Perl hash.
  sub _emit_mapping {
      my $self = shift;
      my ($value, $tag, $node_id, $context) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      # Sometimes 'keys' fails. Like on a bad tie implementation.
      my $empty_hash = not(eval {keys %$value});
      $self->warn('YAML_EMIT_WARN_KEYS', $@) if $@;
      return ($self->{stream} .= " {}\n") if $empty_hash;
  
      # If CompressSeries is on (default) and legal is this context, then
      # use it and make the indent level be 2 for this node.
      if ($context == FROMARRAY and
          $self->compress_series and
          not (defined $self->{id_anchor}{$node_id} or $tag or $empty_hash)
         ) {
          $self->{stream} .= ' ';
          $self->offset->[$self->level+1] = $self->offset->[$self->level] + 2;
      }
      else {
          $context = 0;
          $self->{stream} .= "\n"
            unless $self->headless && not($self->headless(0));
          $self->offset->[$self->level+1] =
            $self->offset->[$self->level] + $self->indent_width;
      }
  
      $self->{level}++;
      my @keys;
      if ($self->sort_keys == 1) {
          if (ynode($value)) {
              @keys = keys %$value;
          }
          else {
              @keys = sort keys %$value;
          }
      }
      elsif ($self->sort_keys == 2) {
          @keys = sort keys %$value;
      }
      # XXX This is hackish but sometimes handy. Not sure whether to leave it in.
      elsif (ref($self->sort_keys) eq 'ARRAY') {
          my $i = 1;
          my %order = map { ($_, $i++) } @{$self->sort_keys};
          @keys = sort {
              (defined $order{$a} and defined $order{$b})
                ? ($order{$a} <=> $order{$b})
                : ($a cmp $b);
          } keys %$value;
      }
      else {
          @keys = keys %$value;
      }
      # Force the YAML::VALUE ('=') key to sort last.
      if (exists $value->{&VALUE}) {
          for (my $i = 0; $i < @keys; $i++) {
              if ($keys[$i] eq &VALUE) {
                  splice(@keys, $i, 1);
                  push @keys, &VALUE;
                  last;
              }
          }
      }
  
      for my $key (@keys) {
          $self->_emit_key($key, $context);
          $context = 0;
          $self->{stream} .= ':';
          $self->_emit_node($value->{$key});
      }
      $self->{level}--;
  }
  
  # A YAML series is akin to a Perl array.
  sub _emit_sequence {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      return ($self->{stream} .= " []\n") if @$value == 0;
  
      $self->{stream} .= "\n"
        unless $self->headless && not($self->headless(0));
  
      # XXX Really crufty feature. Better implemented by ynodes.
      if ($self->inline_series and
          @$value <= $self->inline_series and
          not (scalar grep {ref or /\n/} @$value)
         ) {
          $self->{stream} =~ s/\n\Z/ /;
          $self->{stream} .= '[';
          for (my $i = 0; $i < @$value; $i++) {
              $self->_emit_str($value->[$i], KEY);
              last if $i == $#{$value};
              $self->{stream} .= ', ';
          }
          $self->{stream} .= "]\n";
          return;
      }
  
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
      for my $val (@$value) {
          $self->{stream} .= ' ' x $self->offset->[$self->level];
          $self->{stream} .= '-';
          $self->_emit_node($val, FROMARRAY);
      }
      $self->{level}--;
  }
  
  # Emit a mapping key
  sub _emit_key {
      my $self = shift;
      my ($value, $context) = @_;
      $self->{stream} .= ' ' x $self->offset->[$self->level]
        unless $context == FROMARRAY;
      $self->_emit_str($value, KEY);
  }
  
  # Emit a blessed SCALAR
  sub _emit_scalar {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag";
      $self->_emit_str($value, BLESSED);
  }
  
  sub _emit {
      my $self = shift;
      $self->{stream} .= join '', @_;
  }
  
  # Emit a string value. YAML has many scalar styles. This routine attempts to
  # guess the best style for the text.
  sub _emit_str {
      my $self = shift;
      my $type = $_[1] || 0;
  
      # Use heuristics to find the best scalar emission style.
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
  
      my $sf = $type == KEY ? '' : ' ';
      my $sb = $type == KEY ? '? ' : ' ';
      my $ef = $type == KEY ? '' : "\n";
      my $eb = "\n";
  
      while (1) {
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if not defined $_[0];
          $self->_emit($sf, '=', $ef), last
            if $_[0] eq VALUE;
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /$ESCAPE_CHAR/;
          if ($_[0] =~ /\n/) {
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last
                if $self->use_block;
                Carp::cluck "[YAML] \$UseFold is no longer supported"
                if $self->use_fold;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if length $_[0] <= 30;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if $_[0] !~ /\n\s*\S/;
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last;
          }
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if $self->is_valid_plain($_[0]);
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /'/;
          $self->_emit($sf),
          $self->_emit_single($_[0]),
          $self->_emit($ef);
          last;
      }
  
      $self->{level}--;
  
      return;
  }
  
  # Check whether or not a scalar should be emitted as an plain scalar.
  sub is_valid_plain {
      my $self = shift;
      return 0 unless length $_[0];
      # refer to YAML::Loader::parse_inline_simple()
      return 0 if $_[0] =~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;
      return 0 if $_[0] =~ /[\{\[\]\},]/;
      return 0 if $_[0] =~ /[:\-\?]\s/;
      return 0 if $_[0] =~ /\s#/;
      return 0 if $_[0] =~ /\:(\s|$)/;
      return 0 if $_[0] =~ /[\s\|\>]$/;
      return 1;
  }
  
  sub _emit_block {
      my $self = shift;
      my ($indicator, $value) = @_;
      $self->{stream} .= $indicator;
      $value =~ /(\n*)\Z/;
      my $chomp = length $1 ? (length $1 > 1) ? '+' : '' : '-';
      $value = '~' if not defined $value;
      $self->{stream} .= $chomp;
      $self->{stream} .= $self->indent_width if $value =~ /^\s/;
      $self->{stream} .= $self->indent($value);
  }
  
  # Plain means that the scalar is unquoted.
  sub _emit_plain {
      my $self = shift;
      $self->{stream} .= defined $_[0] ? $_[0] : '~';
  }
  
  # Double quoting is for single lined escaped strings.
  sub _emit_double {
      my $self = shift;
      (my $escaped = $self->escape($_[0])) =~ s/"/\\"/g;
      $self->{stream} .= qq{"$escaped"};
  }
  
  # Single quoting is for single lined unescaped strings.
  sub _emit_single {
      my $self = shift;
      my $item = shift;
      $item =~ s{'}{''}g;
      $self->{stream} .= "'$item'";
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Indent a scalar to the current indentation level.
  sub indent {
      my $self = shift;
      my ($text) = @_;
      return $text unless length $text;
      $text =~ s/\n\Z//;
      my $indent = ' ' x $self->offset->[$self->level];
      $text =~ s/^/$indent/gm;
      $text = "\n$text";
      return $text;
  }
  
  # Escapes for unprintable characters
  my @escapes = qw(\0   \x01 \x02 \x03 \x04 \x05 \x06 \a
                   \x08 \t   \n   \v   \f   \r   \x0e \x0f
                   \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17
                   \x18 \x19 \x1a \e   \x1c \x1d \x1e \x1f
                  );
  
  # Escape the unprintable characters
  sub escape {
      my $self = shift;
      my ($text) = @_;
      $text =~ s/\\/\\\\/g;
      $text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;
      return $text;
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Dumper - YAML class for dumping Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Dumper;
      my $dumper = YAML::Dumper->new;
      $dumper->indent_width(4);
      print $dumper->dump({foo => 'bar'});
  
  =head1 DESCRIPTION
  
  YAML::Dumper is the module that YAML.pm used to serialize Perl objects to
  YAML. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER

$fatpacked{"YAML/Dumper/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER_BASE';
  package YAML::Dumper::Base;
  $YAML::Dumper::Base::VERSION = '0.90';
  use YAML::Mo;
  
  use YAML::Node;
  
  # YAML Dumping options
  has spec_version    => default => sub {'1.0'};
  has indent_width    => default => sub {2};
  has use_header      => default => sub {1};
  has use_version     => default => sub {0};
  has sort_keys       => default => sub {1};
  has anchor_prefix   => default => sub {''};
  has dump_code       => default => sub {0};
  has use_block       => default => sub {0};
  has use_fold        => default => sub {0};
  has compress_series => default => sub {1};
  has inline_series   => default => sub {0};
  has use_aliases     => default => sub {1};
  has purity          => default => sub {0};
  has stringify       => default => sub {0};
  
  # Properties
  has stream      => default => sub {''};
  has document    => default => sub {0};
  has transferred => default => sub {{}};
  has id_refcnt   => default => sub {{}};
  has id_anchor   => default => sub {{}};
  has anchor      => default => sub {1};
  has level       => default => sub {0};
  has offset      => default => sub {[]};
  has headless    => default => sub {0};
  has blessed_map => default => sub {{}};
  
  # Global Options are an idea taken from Data::Dumper. Really they are just
  # sugar on top of real OO properties. They make the simple Dump/Load API
  # easy to configure.
  sub set_global_options {
      my $self = shift;
      $self->spec_version($YAML::SpecVersion)
        if defined $YAML::SpecVersion;
      $self->indent_width($YAML::Indent)
        if defined $YAML::Indent;
      $self->use_header($YAML::UseHeader)
        if defined $YAML::UseHeader;
      $self->use_version($YAML::UseVersion)
        if defined $YAML::UseVersion;
      $self->sort_keys($YAML::SortKeys)
        if defined $YAML::SortKeys;
      $self->anchor_prefix($YAML::AnchorPrefix)
        if defined $YAML::AnchorPrefix;
      $self->dump_code($YAML::DumpCode || $YAML::UseCode)
        if defined $YAML::DumpCode or defined $YAML::UseCode;
      $self->use_block($YAML::UseBlock)
        if defined $YAML::UseBlock;
      $self->use_fold($YAML::UseFold)
        if defined $YAML::UseFold;
      $self->compress_series($YAML::CompressSeries)
        if defined $YAML::CompressSeries;
      $self->inline_series($YAML::InlineSeries)
        if defined $YAML::InlineSeries;
      $self->use_aliases($YAML::UseAliases)
        if defined $YAML::UseAliases;
      $self->purity($YAML::Purity)
        if defined $YAML::Purity;
      $self->stringify($YAML::Stringify)
        if defined $YAML::Stringify;
  }
  
  sub dump {
      my $self = shift;
      $self->die('dump() not implemented in this class.');
  }
  
  sub blessed {
      my $self = shift;
      my ($ref) = @_;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      $self->{blessed_map}->{$node_id};
  }
  
  sub bless {
      my $self = shift;
      my ($ref, $blessing) = @_;
      my $ynode;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      if (not defined $blessing) {
          $ynode = YAML::Node->new($ref);
      }
      elsif (ref $blessing) {
          $self->die() unless ynode($blessing);
          $ynode = $blessing;
      }
      else {
          no strict 'refs';
          my $transfer = $blessing . "::yaml_dump";
          $self->die() unless defined &{$transfer};
          $ynode = &{$transfer}($ref);
          $self->die() unless ynode($ynode);
      }
      $self->{blessed_map}->{$node_id} = $ynode;
      my $object = ynode($ynode) or $self->die();
      return $object;
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Dumper::Base - Base class for YAML Dumper classes
  
  =head1 SYNOPSIS
  
      package YAML::Dumper::Something;
      use YAML::Dumper::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Dumper::Base is a base class for creating YAML dumper classes.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER_BASE

$fatpacked{"YAML/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ERROR';
  package YAML::Error;
  $YAML::Error::VERSION = '0.90';
  use YAML::Mo;
  
  has 'code';
  has 'type' => default => sub {'Error'};
  has 'line';
  has 'document';
  has 'arguments' => default => sub {[]};
  
  my ($error_messages, %line_adjust);
  
  sub format_message {
      my $self = shift;
      my $output = 'YAML ' . $self->type . ': ';
      my $code = $self->code;
      if ($error_messages->{$code}) {
          $code = sprintf($error_messages->{$code}, @{$self->arguments});
      }
      $output .= $code . "\n";
  
      $output .= '   Code: ' . $self->code . "\n"
          if defined $self->code;
      $output .= '   Line: ' . $self->line . "\n"
          if defined $self->line;
      $output .= '   Document: ' . $self->document . "\n"
          if defined $self->document;
      return $output;
  }
  
  sub error_messages {
      $error_messages;
  }
  
  %$error_messages = map {s/^\s+//;$_} split "\n", <<'...';
  YAML_PARSE_ERR_BAD_CHARS
    Invalid characters in stream. This parser only supports printable ASCII
  YAML_PARSE_ERR_NO_FINAL_NEWLINE
    Stream does not end with newline character
  YAML_PARSE_ERR_BAD_MAJOR_VERSION
    Can't parse a %s document with a 1.0 parser
  YAML_PARSE_WARN_BAD_MINOR_VERSION
    Parsing a %s document with a 1.0 parser
  YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
    '%s directive used more than once'
  YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
    No text allowed after indicator
  YAML_PARSE_ERR_NO_ANCHOR
    No anchor for alias '*%s'
  YAML_PARSE_ERR_NO_SEPARATOR
    Expected separator '---'
  YAML_PARSE_ERR_SINGLE_LINE
    Couldn't parse single line value
  YAML_PARSE_ERR_BAD_ANCHOR
    Invalid anchor
  YAML_DUMP_ERR_INVALID_INDENT
    Invalid Indent width specified: '%s'
  YAML_LOAD_USAGE
    usage: YAML::Load($yaml_stream_scalar)
  YAML_PARSE_ERR_BAD_NODE
    Can't parse node
  YAML_PARSE_ERR_BAD_EXPLICIT
    Unsupported explicit transfer: '%s'
  YAML_DUMP_USAGE_DUMPCODE
    Invalid value for DumpCode: '%s'
  YAML_LOAD_ERR_FILE_INPUT
    Couldn't open %s for input:\n%s
  YAML_DUMP_ERR_FILE_CONCATENATE
    Can't concatenate to YAML file %s
  YAML_DUMP_ERR_FILE_OUTPUT
    Couldn't open %s for output:\n%s
  YAML_DUMP_ERR_NO_HEADER
    With UseHeader=0, the node must be a plain hash or array
  YAML_DUMP_WARN_BAD_NODE_TYPE
    Can't perform serialization for node type: '%s'
  YAML_EMIT_WARN_KEYS
    Encountered a problem with 'keys':\n%s
  YAML_DUMP_WARN_DEPARSE_FAILED
    Deparse failed for CODE reference
  YAML_DUMP_WARN_CODE_DUMMY
    Emitting dummy subroutine for CODE reference
  YAML_PARSE_ERR_MANY_EXPLICIT
    More than one explicit transfer
  YAML_PARSE_ERR_MANY_IMPLICIT
    More than one implicit request
  YAML_PARSE_ERR_MANY_ANCHOR
    More than one anchor
  YAML_PARSE_ERR_ANCHOR_ALIAS
    Can't define both an anchor and an alias
  YAML_PARSE_ERR_BAD_ALIAS
    Invalid alias
  YAML_PARSE_ERR_MANY_ALIAS
    More than one alias
  YAML_LOAD_ERR_NO_CONVERT
    Can't convert implicit '%s' node to explicit '%s' node
  YAML_LOAD_ERR_NO_DEFAULT_VALUE
    No default value for '%s' explicit transfer
  YAML_LOAD_ERR_NON_EMPTY_STRING
    Only the empty string can be converted to a '%s'
  YAML_LOAD_ERR_BAD_MAP_TO_SEQ
    Can't transfer map as sequence. Non numeric key '%s' encountered.
  YAML_DUMP_ERR_BAD_GLOB
    '%s' is an invalid value for Perl glob
  YAML_DUMP_ERR_BAD_REGEXP
    '%s' is an invalid value for Perl Regexp
  YAML_LOAD_ERR_BAD_MAP_ELEMENT
    Invalid element in map
  YAML_LOAD_WARN_DUPLICATE_KEY
    Duplicate map key found. Ignoring.
  YAML_LOAD_ERR_BAD_SEQ_ELEMENT
    Invalid element in sequence
  YAML_PARSE_ERR_INLINE_MAP
    Can't parse inline map
  YAML_PARSE_ERR_INLINE_SEQUENCE
    Can't parse inline sequence
  YAML_PARSE_ERR_BAD_DOUBLE
    Can't parse double quoted string
  YAML_PARSE_ERR_BAD_SINGLE
    Can't parse single quoted string
  YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
    Can't parse inline implicit value '%s'
  YAML_PARSE_ERR_BAD_IMPLICIT
    Unrecognized implicit value '%s'
  YAML_PARSE_ERR_INDENTATION
    Error. Invalid indentation level
  YAML_PARSE_ERR_INCONSISTENT_INDENTATION
    Inconsistent indentation level
  YAML_LOAD_WARN_UNRESOLVED_ALIAS
    Can't resolve alias *%s
  YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
    No 'REGEXP' element for Perl regexp
  YAML_LOAD_WARN_BAD_REGEXP_ELEM
    Unknown element '%s' in Perl regexp
  YAML_LOAD_WARN_GLOB_NAME
    No 'NAME' element for Perl glob
  YAML_LOAD_WARN_PARSE_CODE
    Couldn't parse Perl code scalar: %s
  YAML_LOAD_WARN_CODE_DEPARSE
    Won't parse Perl code unless $YAML::LoadCode is set
  YAML_EMIT_ERR_BAD_LEVEL
    Internal Error: Bad level detected
  YAML_PARSE_WARN_AMBIGUOUS_TAB
    Amibiguous tab converted to spaces
  YAML_LOAD_WARN_BAD_GLOB_ELEM
    Unknown element '%s' in Perl glob
  YAML_PARSE_ERR_ZERO_INDENT
    Can't use zero as an indentation width
  YAML_LOAD_WARN_GLOB_IO
    Can't load an IO filehandle. Yet!!!
  ...
  
  %line_adjust = map {($_, 1)}
    qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION
       YAML_PARSE_WARN_BAD_MINOR_VERSION
       YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
       YAML_PARSE_ERR_NO_ANCHOR
       YAML_PARSE_ERR_MANY_EXPLICIT
       YAML_PARSE_ERR_MANY_IMPLICIT
       YAML_PARSE_ERR_MANY_ANCHOR
       YAML_PARSE_ERR_ANCHOR_ALIAS
       YAML_PARSE_ERR_BAD_ALIAS
       YAML_PARSE_ERR_MANY_ALIAS
       YAML_LOAD_ERR_NO_CONVERT
       YAML_LOAD_ERR_NO_DEFAULT_VALUE
       YAML_LOAD_ERR_NON_EMPTY_STRING
       YAML_LOAD_ERR_BAD_MAP_TO_SEQ
       YAML_LOAD_ERR_BAD_STR_TO_INT
       YAML_LOAD_ERR_BAD_STR_TO_DATE
       YAML_LOAD_ERR_BAD_STR_TO_TIME
       YAML_LOAD_WARN_DUPLICATE_KEY
       YAML_PARSE_ERR_INLINE_MAP
       YAML_PARSE_ERR_INLINE_SEQUENCE
       YAML_PARSE_ERR_BAD_DOUBLE
       YAML_PARSE_ERR_BAD_SINGLE
       YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
       YAML_PARSE_ERR_BAD_IMPLICIT
       YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
       YAML_LOAD_WARN_BAD_REGEXP_ELEM
       YAML_LOAD_WARN_REGEXP_CREATE
       YAML_LOAD_WARN_GLOB_NAME
       YAML_LOAD_WARN_PARSE_CODE
       YAML_LOAD_WARN_CODE_DEPARSE
       YAML_LOAD_WARN_BAD_GLOB_ELEM
       YAML_PARSE_ERR_ZERO_INDENT
      );
  
  package YAML::Warning;
  $YAML::Warning::VERSION = '0.90';
  our @ISA = 'YAML::Error';
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Error - Error formatting class for YAML modules
  
  =head1 SYNOPSIS
  
      $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias);
      $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
  
  =head1 DESCRIPTION
  
  This module provides a C<die> and a C<warn> facility.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ERROR

$fatpacked{"YAML/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER';
  package YAML::Loader;
  $YAML::Loader::VERSION = '0.90';
  use YAML::Mo;
  extends 'YAML::Loader::Base';
  
  use YAML::Loader::Base;
  use YAML::Types;
  
  # Context constants
  use constant LEAF       => 1;
  use constant COLLECTION => 2;
  use constant VALUE      => "\x07YAML\x07VALUE\x07";
  use constant COMMENT    => "\x07YAML\x07COMMENT\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $FOLD_CHAR   = '>';
  my $LIT_CHAR    = '|';
  my $LIT_CHAR_RX = "\\$LIT_CHAR";
  
  sub load {
      my $self = shift;
      $self->stream($_[0] || '');
      return $self->_parse();
  }
  
  # Top level function for parsing. Parse each document in order and
  # handle processing for YAML headers.
  sub _parse {
      my $self = shift;
      my (%directives, $preface);
      $self->{stream} =~ s|\015\012|\012|g;
      $self->{stream} =~ s|\015|\012|g;
      $self->line(0);
      $self->die('YAML_PARSE_ERR_BAD_CHARS')
        if $self->stream =~ /$ESCAPE_CHAR/;
      $self->die('YAML_PARSE_ERR_NO_FINAL_NEWLINE')
        if length($self->stream) and
           $self->{stream} !~ s/(.)\n\Z/$1/s;
      $self->lines([split /\x0a/, $self->stream, -1]);
      $self->line(1);
      # Throw away any comments or blanks before the header (or start of
      # content for headerless streams)
      $self->_parse_throwaway_comments();
      $self->document(0);
      $self->documents([]);
      # Add an "assumed" header if there is no header and the stream is
      # not empty (after initial throwaways).
      if (not $self->eos) {
          if ($self->lines->[0] !~ /^---(\s|$)/) {
              unshift @{$self->lines}, '---';
              $self->{line}--;
          }
      }
  
      # Main Loop. Parse out all the top level nodes and return them.
      while (not $self->eos) {
          $self->anchor2node({});
          $self->{document}++;
          $self->done(0);
          $self->level(0);
          $self->offset->[0] = -1;
  
          if ($self->lines->[0] =~ /^---\s*(.*)$/) {
              my @words = split /\s+/, $1;
              %directives = ();
              while (@words && $words[0] =~ /^#(\w+):(\S.*)$/) {
                  my ($key, $value) = ($1, $2);
                  shift(@words);
                  if (defined $directives{$key}) {
                      $self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',
                        $key, $self->document);
                      next;
                  }
                  $directives{$key} = $value;
              }
              $self->preface(join ' ', @words);
          }
          else {
              $self->die('YAML_PARSE_ERR_NO_SEPARATOR');
          }
  
          if (not $self->done) {
              $self->_parse_next_line(COLLECTION);
          }
          if ($self->done) {
              $self->{indent} = -1;
              $self->content('');
          }
  
          $directives{YAML} ||= '1.0';
          $directives{TAB} ||= 'NONE';
          ($self->{major_version}, $self->{minor_version}) =
            split /\./, $directives{YAML}, 2;
          $self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION', $directives{YAML})
            if $self->major_version ne '1';
          $self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION', $directives{YAML})
            if $self->minor_version ne '0';
          $self->die('Unrecognized TAB policy')
            unless $directives{TAB} =~ /^(NONE|\d+)(:HARD)?$/;
  
          push @{$self->documents}, $self->_parse_node();
      }
      return wantarray ? @{$self->documents} : $self->documents->[-1];
  }
  
  # This function is the dispatcher for parsing each node. Every node
  # recurses back through here. (Inlines are an exception as they have
  # their own sub-parser.)
  sub _parse_node {
      my $self = shift;
      my $preface = $self->preface;
      $self->preface('');
      my ($node, $type, $indicator, $escape, $chomp) = ('') x 5;
      my ($anchor, $alias, $explicit, $implicit, $class) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $preface) =
        $self->_parse_qualifiers($preface);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $self->inline('');
      while (length $preface) {
          my $line = $self->line - 1;
          if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//) {
              $indicator = $1;
              $chomp = $2 if defined($2);
          }
          else {
              $self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR') if $indicator;
              $self->inline($preface);
              $preface = '';
          }
      }
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif (length $self->inline) {
          $node = $self->_parse_inline(1, $implicit, $explicit);
          if (length $self->inline) {
              $self->die('YAML_PARSE_ERR_SINGLE_LINE');
          }
      }
      elsif ($indicator eq $LIT_CHAR) {
          $self->{level}++;
          $node = $self->_parse_block($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      elsif ($indicator eq $FOLD_CHAR) {
          $self->{level}++;
          $node = $self->_parse_unfold($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      else {
          $self->{level}++;
          $self->offset->[$self->level] ||= 0;
          if ($self->indent == $self->offset->[$self->level]) {
              if ($self->content =~ /^-( |$)/) {
                  $node = $self->_parse_seq($anchor);
              }
              elsif ($self->content =~ /(^\?|\:( |$))/) {
                  $node = $self->_parse_mapping($anchor);
              }
              elsif ($preface =~ /^\s*$/) {
                  $node = $self->_parse_implicit('');
              }
              else {
                  $self->die('YAML_PARSE_ERR_BAD_NODE');
              }
          }
          else {
              $node = undef;
          }
          $self->{level}--;
      }
      $#{$self->offset} = $self->level;
  
      if ($explicit) {
          if ($class) {
              if (not ref $node) {
                  my $copy = $node;
                  undef $node;
                  $node = \$copy;
              }
              CORE::bless $node, $class;
          }
          else {
              $node = $self->_parse_explicit($node, $explicit);
          }
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              # XXX Can't remember what this code actually does
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Preprocess the qualifiers that may be attached to any node.
  sub _parse_qualifiers {
      my $self = shift;
      my ($preface) = @_;
      my ($anchor, $alias, $explicit, $implicit, $token) = ('') x 5;
      $self->inline('');
      while ($preface =~ /^[&*!]/) {
          my $line = $self->line - 1;
          if ($preface =~ s/^\!(\S+)\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_EXPLICIT') if $explicit;
              $explicit = $1;
          }
          elsif ($preface =~ s/^\!\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_IMPLICIT') if $implicit;
              $implicit = 1;
          }
          elsif ($preface =~ s/^\&([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ANCHOR')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ANCHOR') if $anchor;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $alias;
              $anchor = $token;
          }
          elsif ($preface =~ s/^\*([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ALIAS')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ALIAS') if $alias;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $anchor;
              $alias = $token;
          }
      }
      return ($anchor, $alias, $explicit, $implicit, $preface);
  }
  
  # Morph a node to it's explicit type
  sub _parse_explicit {
      my $self = shift;
      my ($node, $explicit) = @_;
      my ($type, $class);
      if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/) {
          ($type, $class) = (($1 || ''), ($2 || ''));
  
          # FIXME # die unless uc($type) eq ref($node) ?
  
          if ( $type eq "ref" ) {
              $self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'XXX', $explicit)
              unless exists $node->{VALUE()} and scalar(keys %$node) == 1;
  
              my $value = $node->{VALUE()};
              $node = \$value;
          }
  
          if ( $type eq "scalar" and length($class) and !ref($node) ) {
              my $value = $node;
              $node = \$value;
          }
  
          if ( length($class) ) {
              CORE::bless($node, $class);
          }
  
          return $node;
      }
      if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}) {
          ($type, $class) = (($1 || ''), ($2 || ''));
          my $type_class = "YAML::Type::$type";
          no strict 'refs';
          if ($type_class->can('yaml_load')) {
              return $type_class->yaml_load($node, $class, $self);
          }
          else {
              $self->die('YAML_LOAD_ERR_NO_CONVERT', 'XXX', $explicit);
          }
      }
      # This !perl/@Foo and !perl/$Foo are deprecated but still parsed
      elsif ($YAML::TagClass->{$explicit} ||
             $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}
            ) {
          $class = $YAML::TagClass->{$explicit} || $2;
          if ($class->can('yaml_load')) {
              require YAML::Node;
              return $class->yaml_load(YAML::Node->new($node, $explicit));
          }
          else {
              if (ref $node) {
                  return CORE::bless $node, $class;
              }
              else {
                  return CORE::bless \$node, $class;
              }
          }
      }
      elsif (ref $node) {
          require YAML::Node;
          return YAML::Node->new($node, $explicit);
      }
      else {
          # XXX This is likely wrong. Failing test:
          # --- !unknown 'scalar value'
          return $node;
      }
  }
  
  # Parse a YAML mapping into a Perl hash
  sub _parse_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $mapping = {};
      $self->anchor2node->{$anchor} = $mapping;
      my $key;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          # If structured key:
          if ($self->{content} =~ s/^\?\s*//) {
              $self->preface($self->content);
              $self->_parse_next_line(COLLECTION);
              $key = $self->_parse_node();
              $key = "$key";
          }
          # If "default" key (equals sign)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = VALUE;
          }
          # If "comment" key (slash slash)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = COMMENT;
          }
          # Regular scalar key:
          else {
              $self->inline($self->content);
              $key = $self->_parse_inline();
              $key = "$key";
              $self->content($self->inline);
              $self->inline('');
          }
  
          unless ($self->{content} =~ s/^:\s*//) {
              $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
          }
          $self->preface($self->content);
          my $line = $self->line;
          $self->_parse_next_line(COLLECTION);
          my $value = $self->_parse_node();
          if (exists $mapping->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $mapping->{$key} = $value;
          }
      }
      return $mapping;
  }
  
  # Parse a YAML sequence into a Perl array
  sub _parse_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $seq = [];
      $self->anchor2node->{$anchor} = $seq;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          if ($self->content =~ /^-(?: (.*))?$/) {
              $self->preface(defined($1) ? $1 : '');
          }
          else {
              $self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT');
          }
          if ($self->preface =~ /^(\s*)(\w.*\:(?: |$).*)$/) {
              $self->indent($self->offset->[$self->level] + 2 + length($1));
              $self->content($2);
              $self->level($self->level + 1);
              $self->offset->[$self->level] = $self->indent;
              $self->preface('');
              push @$seq, $self->_parse_mapping('');
              $self->{level}--;
              $#{$self->offset} = $self->level;
          }
          else {
              $self->_parse_next_line(COLLECTION);
              push @$seq, $self->_parse_node();
          }
      }
      return $seq;
  }
  
  # Parse an inline value. Since YAML supports inline collections, this is
  # the top level of a sub parsing.
  sub _parse_inline {
      my $self = shift;
      my ($top, $top_implicit, $top_explicit) = (@_, '', '', '');
      $self->{inline} =~ s/^\s*(.*)\s*$/$1/; # OUCH - mugwump
      my ($node, $anchor, $alias, $explicit, $implicit) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $self->{inline}) =
        $self->_parse_qualifiers($self->inline);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $implicit ||= $top_implicit;
      $explicit ||= $top_explicit;
      ($top_implicit, $top_explicit) = ('', '');
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif ($self->inline =~ /^\{/) {
          $node = $self->_parse_inline_mapping($anchor);
      }
      elsif ($self->inline =~ /^\[/) {
          $node = $self->_parse_inline_seq($anchor);
      }
      elsif ($self->inline =~ /^"/) {
          $node = $self->_parse_inline_double_quoted();
          $node = $self->_unescape($node);
          $node = $self->_parse_implicit($node) if $implicit;
      }
      elsif ($self->inline =~ /^'/) {
          $node = $self->_parse_inline_single_quoted();
          $node = $self->_parse_implicit($node) if $implicit;
      }
      else {
          if ($top) {
              $node = $self->inline;
              $self->inline('');
          }
          else {
              $node = $self->_parse_inline_simple();
          }
          $node = $self->_parse_implicit($node) unless $explicit;
      }
      if ($explicit) {
          $node = $self->_parse_explicit($node, $explicit);
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Parse the inline YAML mapping into a Perl hash
  sub _parse_inline_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $node = {};
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_MAP')
        unless $self->{inline} =~ s/^\{\s*//;
      while (not $self->{inline} =~ s/^\s*\}//) {
          my $key = $self->_parse_inline();
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\: \s*//;
          my $value = $self->_parse_inline();
          if (exists $node->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $node->{$key} = $value;
          }
          next if $self->inline =~ /^\s*\}/;
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline YAML sequence into a Perl array
  sub _parse_inline_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $node = [];
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
        unless $self->{inline} =~ s/^\[\s*//;
      while (not $self->{inline} =~ s/^\s*\]//) {
          my $value = $self->_parse_inline();
          push @$node, $value;
          next if $self->inline =~ /^\s*\]/;
          $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline double quoted string.
  sub _parse_inline_double_quoted {
      my $self = shift;
      my $node;
      # https://rt.cpan.org/Public/Bug/Display.html?id=90593
      if ($self->inline =~ /^"((?>(?>(?:\\"|[^"]){0,32766}){0,32766}))"\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/\\"/"/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_DOUBLE');
      }
      return $node;
  }
  
  
  # Parse the inline single quoted string.
  sub _parse_inline_single_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^'((?:''|[^'])*)'\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/''/'/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_SINGLE');
      }
      return $node;
  }
  
  # Parse the inline unquoted string and do implicit typing.
  sub _parse_inline_simple {
      my $self = shift;
      my $value;
      if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/) {
          $value = $1;
          substr($self->{inline}, 0, length($1)) = '';
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT', $value);
      }
      return $value;
  }
  
  sub _parse_implicit {
      my $self = shift;
      my ($value) = @_;
      $value =~ s/\s*$//;
      return $value if $value eq '';
      return undef if $value =~ /^~$/;
      return $value
        unless $value =~ /^[\@\`\^]/ or
               $value =~ /^[\-\?]\s/;
      $self->die('YAML_PARSE_ERR_BAD_IMPLICIT', $value);
  }
  
  # Unfold a YAML multiline scalar into a single string.
  sub _parse_unfold {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      my $space = 0;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content. "\n";
          $self->_parse_next_line(LEAF);
      }
      $node =~ s/^(\S.*)\n(?=\S)/$1 /gm;
      $node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;
      $node =~ s/\n*\Z// unless $chomp eq '+';
      $node .= "\n" unless $chomp;
      return $node;
  }
  
  # Parse a YAML block style scalar. This is like a Perl here-document.
  sub _parse_block {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content . "\n";
          $self->_parse_next_line(LEAF);
      }
      return $node if '+' eq $chomp;
      $node =~ s/\n*\Z/\n/;
      $node =~ s/\n\Z// if $chomp eq '-';
      return $node;
  }
  
  # Handle Perl style '#' comments. Comments must be at the same indentation
  # level as the collection line following them.
  sub _parse_throwaway_comments {
      my $self = shift;
      while (@{$self->lines} and
             $self->lines->[0] =~ m{^\s*(\#|$)}
            ) {
          shift @{$self->lines};
          $self->{line}++;
      }
      $self->eos($self->{done} = not @{$self->lines});
  }
  
  # This is the routine that controls what line is being parsed. It gets called
  # once for each line in the YAML stream.
  #
  # This routine must:
  # 1) Skip past the current line
  # 2) Determine the indentation offset for a new level
  # 3) Find the next _content_ line
  #   A) Skip over any throwaways (Comments/blanks)
  #   B) Set $self->indent, $self->content, $self->line
  # 4) Expand tabs appropriately
  sub _parse_next_line {
      my $self = shift;
      my ($type) = @_;
      my $level = $self->level;
      my $offset = $self->offset->[$level];
      $self->die('YAML_EMIT_ERR_BAD_LEVEL') unless defined $offset;
      shift @{$self->lines};
      $self->eos($self->{done} = not @{$self->lines});
      return if $self->eos;
      $self->{line}++;
  
      # Determine the offset for a new leaf node
      if ($self->preface =~
          qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/
         ) {
          $self->die('YAML_PARSE_ERR_ZERO_INDENT')
            if length($1) and $1 == 0;
          $type = LEAF;
          if (length($1)) {
              $self->offset->[$level + 1] = $offset + $1;
          }
          else {
              # First get rid of any comments.
              while (@{$self->lines} && ($self->lines->[0] =~ /^\s*#/)) {
                  $self->lines->[0] =~ /^( *)/ or die;
                  last unless length($1) <= $offset;
                  shift @{$self->lines};
                  $self->{line}++;
              }
              $self->eos($self->{done} = not @{$self->lines});
              return if $self->eos;
              if ($self->lines->[0] =~ /^( *)\S/ and length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
      # Determine the offset for a new collection level
      elsif ($type == COLLECTION and
             $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/) {
          $self->_parse_throwaway_comments();
          if ($self->eos) {
              $self->offset->[$level+1] = $offset + 1;
              return;
          }
          else {
              $self->lines->[0] =~ /^( *)\S/ or die;
              if (length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
  
      if ($type == LEAF) {
          while (@{$self->lines} and
                 $self->lines->[0] =~ m{^( *)(\#)} and
                 length($1) < $offset
                ) {
              shift @{$self->lines};
              $self->{line}++;
          }
          $self->eos($self->{done} = not @{$self->lines});
      }
      else {
          $self->_parse_throwaway_comments();
      }
      return if $self->eos;
  
      if ($self->lines->[0] =~ /^---(\s|$)/) {
          $self->done(1);
          return;
      }
      if ($type == LEAF and
          $self->lines->[0] =~ /^ {$offset}(.*)$/
         ) {
          $self->indent($offset);
          $self->content($1);
      }
      elsif ($self->lines->[0] =~ /^\s*$/) {
          $self->indent($offset);
          $self->content('');
      }
      else {
          $self->lines->[0] =~ /^( *)(\S.*)$/;
          while ($self->offset->[$level] > length($1)) {
              $level--;
          }
          $self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION')
            if $self->offset->[$level] != length($1);
          $self->indent(length($1));
          $self->content($2);
      }
      $self->die('YAML_PARSE_ERR_INDENTATION')
        if $self->indent - $offset > 1;
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Printable characters for escapes
  my %unescapes = (
     0 => "\x00",
     a => "\x07",
     t => "\x09",
     n => "\x0a",
     'v' => "\x0b", # Potential v-string error on 5.6.2 if not quoted
     f => "\x0c",
     r => "\x0d",
     e => "\x1b",
     '\\' => '\\',
    );
  
  # Transform all the backslash style escape characters to their literal meaning
  sub _unescape {
      my $self = shift;
      my ($node) = @_;
      $node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
                (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;
      return $node;
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Loader - YAML class for loading Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Loader;
      my $loader = YAML::Loader->new;
      my $hash = $loader->load(<<'...');
      foo: bar
      ...
  
  =head1 DESCRIPTION
  
  YAML::Loader is the module that YAML.pm used to deserialize YAML to Perl
  objects. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER

$fatpacked{"YAML/Loader/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER_BASE';
  package YAML::Loader::Base;
  $YAML::Loader::Base::VERSION = '0.90';
  use YAML::Mo;
  
  has load_code     => default => sub {0};
  has stream        => default => sub {''};
  has document      => default => sub {0};
  has line          => default => sub {0};
  has documents     => default => sub {[]};
  has lines         => default => sub {[]};
  has eos           => default => sub {0};
  has done          => default => sub {0};
  has anchor2node   => default => sub {{}};
  has level         => default => sub {0};
  has offset        => default => sub {[]};
  has preface       => default => sub {''};
  has content       => default => sub {''};
  has indent        => default => sub {0};
  has major_version => default => sub {0};
  has minor_version => default => sub {0};
  has inline        => default => sub {''};
  
  sub set_global_options {
      my $self = shift;
      $self->load_code($YAML::LoadCode || $YAML::UseCode)
        if defined $YAML::LoadCode or defined $YAML::UseCode;
  }
  
  sub load {
      die 'load() not implemented in this class.';
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Loader::Base - Base class for YAML Loader classes
  
  =head1 SYNOPSIS
  
      package YAML::Loader::Something;
      use YAML::Loader::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Loader::Base is a base class for creating YAML loader classes.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER_BASE

$fatpacked{"YAML/Marshall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MARSHALL';
  use strict; use warnings;
  package YAML::Marshall;
  $YAML::Marshall::VERSION = '0.90';
  use YAML::Node ();
  
  sub import {
      my $class = shift;
      no strict 'refs';
      my $package = caller;
      unless (grep { $_ eq $class} @{$package . '::ISA'}) {
          push @{$package . '::ISA'}, $class;
      }
  
      my $tag = shift;
      if ( $tag ) {
          no warnings 'once';
          $YAML::TagClass->{$tag} = $package;
          ${$package . "::YamlTag"} = $tag;
      }
  }
  
  sub yaml_dump {
      my $self = shift;
      no strict 'refs';
      my $tag = ${ref($self) . "::YamlTag"} || 'perl/' . ref($self);
      $self->yaml_node($self, $tag);
  }
  
  sub yaml_load {
      my ($class, $node) = @_;
      if (my $ynode = $class->yaml_ynode($node)) {
          $node = $ynode->{NODE};
      }
      bless $node, $class;
  }
  
  sub yaml_node {
      shift;
      YAML::Node->new(@_);
  }
  
  sub yaml_ynode {
      shift;
      YAML::Node::ynode(@_);
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Marshall - YAML marshalling class you can mixin to your classes
  
  =head1 SYNOPSIS
  
      package Bar;
      use Foo -base;
      use YAML::Marshall -mixin;
  
  =head1 DESCRIPTION
  
  For classes that want to handle their own YAML serialization.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_MARSHALL

$fatpacked{"YAML/Mo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MO';
  package YAML::Mo;
  $YAML::Mo::VERSION = '0.90';
  # use Mo qw[builder default import];
  #   The following line of code was produced from the previous line by
  #   Mo::Inline version 0.31
  no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{bless{@_[1..$#_]},$_[0]};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;$a{default}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$a{default}->(@_):$m->(@_)}}};my$i=\&import;*{$M.import}=sub{(@_==2 and not $_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};@f=qw[builder default import];use strict;use warnings;
  
  our $DumperModule = 'Data::Dumper';
  
  my ($_new_error, $_info, $_scalar_info);
  
  no strict 'refs';
  *{$M.'Object::die'} = sub {
      my $self = shift;
      my $error = $self->$_new_error(@_);
      $error->type('Error');
      Carp::croak($error->format_message);
  };
  
  *{$M.'Object::warn'} = sub {
      my $self = shift;
      return unless $^W;
      my $error = $self->$_new_error(@_);
      $error->type('Warning');
      Carp::cluck($error->format_message);
  };
  
  # This code needs to be refactored to be simpler and more precise, and no,
  # Scalar::Util doesn't DWIM.
  #
  # Can't handle:
  # * blessed regexp
  *{$M.'Object::node_info'} = sub {
      my $self = shift;
      my $stringify = $_[1] || 0;
      my ($class, $type, $id) =
          ref($_[0])
          ? $stringify
            ? &$_info("$_[0]")
            : do {
                require overload;
                my @info = &$_info(overload::StrVal($_[0]));
                if (ref($_[0]) eq 'Regexp') {
                    @info[0, 1] = (undef, 'REGEXP');
                }
                @info;
            }
          : &$_scalar_info($_[0]);
      ($class, $type, $id) = &$_scalar_info("$_[0]")
          unless $id;
      return wantarray ? ($class, $type, $id) : $id;
  };
  
  #-------------------------------------------------------------------------------
  $_info = sub {
      return (($_[0]) =~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o);
  };
  
  $_scalar_info = sub {
      my $id = 'undef';
      if (defined $_[0]) {
          \$_[0] =~ /\((\w+)\)$/o or CORE::die();
          $id = "$1-S";
      }
      return (undef, undef, $id);
  };
  
  $_new_error = sub {
      require Carp;
      my $self = shift;
      require YAML::Error;
  
      my $code = shift || 'unknown error';
      my $error = YAML::Error->new(code => $code);
      $error->line($self->line) if $self->can('line');
      $error->document($self->document) if $self->can('document');
      $error->arguments([@_]);
      return $error;
  };
  
  1;
YAML_MO

$fatpacked{"YAML/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_NODE';
  use strict; use warnings;
  package YAML::Node;
  $YAML::Node::VERSION = '0.90';
  use YAML::Tag;
  require YAML::Mo;
  
  use Exporter;
  our @ISA     = qw(Exporter YAML::Mo::Object);
  our @EXPORT  = qw(ynode);
  
  sub ynode {
      my $self;
      if (ref($_[0]) eq 'HASH') {
  	$self = tied(%{$_[0]});
      }
      elsif (ref($_[0]) eq 'ARRAY') {
  	$self = tied(@{$_[0]});
      }
      elsif (ref(\$_[0]) eq 'GLOB') {
  	$self = tied(*{$_[0]});
      }
      else {
  	$self = tied($_[0]);
      }
      return (ref($self) =~ /^yaml_/) ? $self : undef;
  }
  
  sub new {
      my ($class, $node, $tag) = @_;
      my $self;
      $self->{NODE} = $node;
      my (undef, $type) = YAML::Mo::Object->node_info($node);
      $self->{KIND} = (not defined $type) ? 'scalar' :
                      ($type eq 'ARRAY') ? 'sequence' :
  		    ($type eq 'HASH') ? 'mapping' :
  		    $class->die("Can't create YAML::Node from '$type'");
      tag($self, ($tag || ''));
      if ($self->{KIND} eq 'scalar') {
  	yaml_scalar->new($self, $_[1]);
  	return \ $_[1];
      }
      my $package = "yaml_" . $self->{KIND};
      $package->new($self)
  }
  
  sub node { $_->{NODE} }
  sub kind { $_->{KIND} }
  sub tag {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{TAG} = YAML::Tag->new($value);
  	return $self;
      }
      else {
         return $self->{TAG};
      }
  }
  sub keys {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{KEYS} = $value;
  	return $self;
      }
      else {
         return $self->{KEYS};
      }
  }
  
  #==============================================================================
  package yaml_scalar;
  $yaml_scalar::VERSION = '0.90';
  @yaml_scalar::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      tie $_[2], $class, $self;
  }
  
  sub TIESCALAR {
      my ($class, $self) = @_;
      bless $self, $class;
      $self
  }
  
  sub FETCH {
      my ($self) = @_;
      $self->{NODE}
  }
  
  sub STORE {
      my ($self, $value) = @_;
      $self->{NODE} = $value
  }
  
  #==============================================================================
  package yaml_sequence;
  $yaml_sequence::VERSION = '0.90';
  @yaml_sequence::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      my $new;
      tie @$new, $class, $self;
      $new
  }
  
  sub TIEARRAY {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCHSIZE {
      my ($self) = @_;
      scalar @{$self->{NODE}};
  }
  
  sub FETCH {
      my ($self, $index) = @_;
      $self->{NODE}[$index]
  }
  
  sub STORE {
      my ($self, $index, $value) = @_;
      $self->{NODE}[$index] = $value
  }
  
  sub undone {
      die "Not implemented yet"; # XXX
  }
  
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *undone; # XXX Must implement before release
  
  #==============================================================================
  package yaml_mapping;
  $yaml_mapping::VERSION = '0.90';
  
  @yaml_mapping::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      @{$self->{KEYS}} = sort keys %{$self->{NODE}};
      my $new;
      tie %$new, $class, $self;
      $new
  }
  
  sub TIEHASH {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCH {
      my ($self, $key) = @_;
      if (exists $self->{NODE}{$key}) {
  	return (grep {$_ eq $key} @{$self->{KEYS}})
  	       ? $self->{NODE}{$key} : undef;
      }
      return $self->{HASH}{$key};
  }
  
  sub STORE {
      my ($self, $key, $value) = @_;
      if (exists $self->{NODE}{$key}) {
  	$self->{NODE}{$key} = $value;
      }
      elsif (exists $self->{HASH}{$key}) {
  	$self->{HASH}{$key} = $value;
      }
      else {
  	if (not grep {$_ eq $key} @{$self->{KEYS}}) {
  	    push(@{$self->{KEYS}}, $key);
  	}
  	$self->{HASH}{$key} = $value;
      }
      $value
  }
  
  sub DELETE {
      my ($self, $key) = @_;
      my $return;
      if (exists $self->{NODE}{$key}) {
  	$return = $self->{NODE}{$key};
      }
      elsif (exists $self->{HASH}{$key}) {
  	$return = delete $self->{NODE}{$key};
      }
      for (my $i = 0; $i < @{$self->{KEYS}}; $i++) {
  	if ($self->{KEYS}[$i] eq $key) {
  	    splice(@{$self->{KEYS}}, $i, 1);
  	}
      }
      return $return;
  }
  
  sub CLEAR {
      my ($self) = @_;
      @{$self->{KEYS}} = ();
      %{$self->{HASH}} = ();
  }
  
  sub FIRSTKEY {
      my ($self) = @_;
      $self->{ITER} = 0;
      $self->{KEYS}[0]
  }
  
  sub NEXTKEY {
      my ($self) = @_;
      $self->{KEYS}[++$self->{ITER}]
  }
  
  sub EXISTS {
      my ($self, $key) = @_;
      exists $self->{NODE}{$key}
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Node - A generic data node that encapsulates YAML information
  
  =head1 SYNOPSIS
  
      use YAML;
      use YAML::Node;
  
      my $ynode = YAML::Node->new({}, 'ingerson.com/fruit');
      %$ynode = qw(orange orange apple red grape green);
      print Dump $ynode;
  
  yields:
  
      --- !ingerson.com/fruit
      orange: orange
      apple: red
      grape: green
  
  =head1 DESCRIPTION
  
  A generic node in YAML is similar to a plain hash, array, or scalar node
  in Perl except that it must also keep track of its type. The type is a
  URI called the YAML type tag.
  
  YAML::Node is a class for generating and manipulating these containers.
  A YAML node (or ynode) is a tied hash, array or scalar. In most ways it
  behaves just like the plain thing. But you can assign and retrieve and
  YAML type tag URI to it. For the hash flavor, you can also assign the
  order that the keys will be retrieved in. By default a ynode will offer
  its keys in the same order that they were assigned.
  
  YAML::Node has a class method call new() that will return a ynode. You
  pass it a regular node and an optional type tag. After that you can
  use it like a normal Perl node, but when you YAML::Dump it, the magical
  properties will be honored.
  
  This is how you can control the sort order of hash keys during a YAML
  serialization. By default, YAML sorts keys alphabetically. But notice
  in the above example that the keys were Dumped in the same order they
  were assigned.
  
  YAML::Node exports a function called ynode(). This function returns the tied object so that you can call special methods on it like ->keys().
  
  keys() works like this:
  
      use YAML;
      use YAML::Node;
  
      %$node = qw(orange orange apple red grape green);
      $ynode = YAML::Node->new($node);
      ynode($ynode)->keys(['grape', 'apple']);
      print Dump $ynode;
  
  produces:
  
      ---
      grape: green
      apple: red
  
  It tells the ynode which keys and what order to use.
  
  ynodes will play a very important role in how programs use YAML. They
  are the foundation of how a Perl class can marshall the Loading and
  Dumping of its objects.
  
  The upcoming versions of YAML.pm will have much more information on this.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  Copyright (c) 2002. Brian Ingerson. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_NODE

$fatpacked{"YAML/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TAG';
  use strict; use warnings;
  package YAML::Tag;
  $YAML::Tag::VERSION = '0.90';
  use overload '""' => sub { ${$_[0]} };
  
  sub new {
      my ($class, $self) = @_;
      bless \$self, $class
  }
  
  sub short {
      ${$_[0]}
  }
  
  sub canonical {
      ${$_[0]}
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Tag - Tag URI object class for YAML
  
  =head1 SYNOPSIS
  
      use YAML::Tag;
  
  =head1 DESCRIPTION
  
  Used by YAML::Node.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TAG

$fatpacked{"YAML/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TYPES';
  package YAML::Types;
  $YAML::Types::VERSION = '0.90';
  use YAML::Mo;
  use YAML::Node;
  
  # XXX These classes and their APIs could still use some refactoring,
  # but at least they work for now.
  #-------------------------------------------------------------------------------
  package YAML::Type::blessed;
  $YAML::Type::blessed::VERSION = '0.90';
  use YAML::Mo; # XXX
  
  sub yaml_dump {
      my $self = shift;
      my ($value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      no strict 'refs';
      my $kind = lc($type) . ':';
      my $tag = ${$class . '::ClassTag'} ||
                "!perl/$kind$class";
      if ($type eq 'REF') {
          YAML::Node->new(
              {(&YAML::VALUE, ${$_[0]})}, $tag
          );
      }
      elsif ($type eq 'SCALAR') {
          $_[1] = $$value;
          YAML::Node->new($_[1], $tag);
      } else {
          YAML::Node->new($value, $tag);
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::undef;
  $YAML::Type::undef::VERSION = '0.90';
  sub yaml_dump {
      my $self = shift;
  }
  
  sub yaml_load {
      my $self = shift;
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::glob;
  $YAML::Type::glob::VERSION = '0.90';
  sub yaml_dump {
      my $self = shift;
      my $ynode = YAML::Node->new({}, '!perl/glob:');
      for my $type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)) {
          my $value = *{$_[0]}{$type};
          $value = $$value if $type eq 'SCALAR';
          if (defined $value) {
              if ($type eq 'IO') {
                  my @stats = qw(device inode mode links uid gid rdev size
                                 atime mtime ctime blksize blocks);
                  undef $value;
                  $value->{stat} = YAML::Node->new({});
                  if ($value->{fileno} = fileno(*{$_[0]})) {
                      local $^W;
                      map {$value->{stat}{shift @stats} = $_} stat(*{$_[0]});
                      $value->{tell} = tell(*{$_[0]});
                  }
              }
              $ynode->{$type} = $value;
          }
      }
      return $ynode;
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      my ($name, $package);
      if (defined $node->{NAME}) {
          $name = $node->{NAME};
          delete $node->{NAME};
      }
      else {
          $loader->warn('YAML_LOAD_WARN_GLOB_NAME');
          return undef;
      }
      if (defined $node->{PACKAGE}) {
          $package = $node->{PACKAGE};
          delete $node->{PACKAGE};
      }
      else {
          $package = 'main';
      }
      no strict 'refs';
      if (exists $node->{SCALAR}) {
          *{"${package}::$name"} = \$node->{SCALAR};
          delete $node->{SCALAR};
      }
      for my $elem (qw(ARRAY HASH CODE IO)) {
          if (exists $node->{$elem}) {
              if ($elem eq 'IO') {
                  $loader->warn('YAML_LOAD_WARN_GLOB_IO');
                  delete $node->{IO};
                  next;
              }
              *{"${package}::$name"} = $node->{$elem};
              delete $node->{$elem};
          }
      }
      for my $elem (sort keys %$node) {
          $loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM', $elem);
      }
      return *{"${package}::$name"};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::code;
  $YAML::Type::code::VERSION = '0.90';
  my $dummy_warned = 0;
  my $default = '{ "DUMMY" }';
  
  sub yaml_dump {
      my $self = shift;
      my $code;
      my ($dumpflag, $value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      my $tag = "!perl/code";
      $tag .= ":$class" if defined $class;
      if (not $dumpflag) {
          $code = $default;
      }
      else {
          bless $value, "CODE" if $class;
          eval { use B::Deparse };
          return if $@;
          my $deparse = B::Deparse->new();
          eval {
              local $^W = 0;
              $code = $deparse->coderef2text($value);
          };
          if ($@) {
              warn YAML::YAML_DUMP_WARN_DEPARSE_FAILED() if $^W;
              $code = $default;
          }
          bless $value, $class if $class;
          chomp $code;
          $code .= "\n";
      }
      $_[2] = $code;
      YAML::Node->new($_[2], $tag);
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      if ($loader->load_code) {
          my $code = eval "package main; sub $node";
          if ($@) {
              $loader->warn('YAML_LOAD_WARN_PARSE_CODE', $@);
              return sub {};
          }
          else {
              CORE::bless $code, $class if $class;
              return $code;
          }
      }
      else {
          return CORE::bless sub {}, $class if $class;
          return sub {};
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::ref;
  $YAML::Type::ref::VERSION = '0.90';
  sub yaml_dump {
      my $self = shift;
      YAML::Node->new({(&YAML::VALUE, ${$_[0]})}, '!perl/ref')
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      $loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'ptr')
        unless exists $node->{&YAML::VALUE};
      return \$node->{&YAML::VALUE};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::regexp;
  $YAML::Type::regexp::VERSION = '0.90';
  # XXX Be sure to handle blessed regexps (if possible)
  sub yaml_dump {
      die "YAML::Type::regexp::yaml_dump not currently implemented";
  }
  
  use constant _QR_TYPES => {
      '' => sub { qr{$_[0]} },
      x => sub { qr{$_[0]}x },
      i => sub { qr{$_[0]}i },
      s => sub { qr{$_[0]}s },
      m => sub { qr{$_[0]}m },
      ix => sub { qr{$_[0]}ix },
      sx => sub { qr{$_[0]}sx },
      mx => sub { qr{$_[0]}mx },
      si => sub { qr{$_[0]}si },
      mi => sub { qr{$_[0]}mi },
      ms => sub { qr{$_[0]}sm },
      six => sub { qr{$_[0]}six },
      mix => sub { qr{$_[0]}mix },
      msx => sub { qr{$_[0]}msx },
      msi => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class) = @_;
      return qr{$node} unless $node =~ /^\(\?([\^\-xism]*):(.*)\)\z/s;
      my ($flags, $re) = ($1, $2);
      $flags =~ s/-.*//;
      $flags =~ s/^\^//;
      my $sub = _QR_TYPES->{$flags} || sub { qr{$_[0]} };
      my $qr = &$sub($re);
      bless $qr, $class if length $class;
      return $qr;
  }
  
  1;
  
  =encoding UTF-8
  
  =head1 NAME
  
  YAML::Types - Marshall Perl internal data types to/from YAML
  
  =head1 SYNOPSIS
  
      $::foo = 42;
      print YAML::Dump(*::foo);
  
      print YAML::Dump(qr{match me});
  
  =head1 DESCRIPTION
  
  This module has the helper classes for transferring objects,
  subroutines, references, globs, regexps and file handles to and
  from YAML.
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2014. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TYPES

$fatpacked{"x86_64-linux-thread-multi/JSON/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_JSON_SYCK';
  package JSON::Syck;
  use strict;
  use vars qw( $VERSION @EXPORT_OK @ISA );
  use Exporter;
  use YAML::Syck ();
  
  BEGIN {
      $VERSION   = '1.27';
      @EXPORT_OK = qw( Load Dump LoadFile DumpFile DumpInto );
      @ISA       = 'Exporter';
      *Load      = \&YAML::Syck::LoadJSON;
      *Dump      = \&YAML::Syck::DumpJSON;
  }
  
  sub DumpFile {
      my $file = shift;
      if ( YAML::Syck::_is_glob($file) ) {
          my $err = YAML::Syck::DumpJSONFile( $_[0], $file );
          if ($err) {
              $! = 0 + $err;
              die "Error writing to filehandle $file: $!\n";
          }
      }
      else {
          open( my $fh, '>', $file ) or die "Cannot write to $file: $!";
          my $err = YAML::Syck::DumpJSONFile( $_[0], $fh );
          if ($err) {
              $! = 0 + $err;
              die "Error writing to file $file: $!\n";
          }
          close $fh
            or die "Error writing to file $file: $!\n";
      }
      return 1;
  }
  
  sub LoadFile {
      my $file = shift;
      if ( YAML::Syck::_is_glob($file) ) {
          YAML::Syck::LoadJSON(
              do { local $/; <$file> }
          );
      }
      else {
          if ( !-e $file || -z $file ) {
              die("'$file' is non-existent or empty");
          }
          open( my $fh, '<', $file ) or die "Cannot read from $file: $!";
          YAML::Syck::LoadJSON(
              do { local $/; <$fh> }
          );
      }
  }
  
  sub DumpInto {
      my $bufref = shift;
      ( ref $bufref ) or die "DumpInto not given reference to output buffer\n";
      YAML::Syck::DumpJSONInto( $_[0], $bufref );
      1;
  }
  
  $JSON::Syck::ImplicitTyping  = 1;
  $JSON::Syck::MaxDepth        = 512;
  $JSON::Syck::Headless        = 1;
  $JSON::Syck::ImplicitUnicode = 0;
  $JSON::Syck::SingleQuote     = 0;
  
  1;
  
  __END__
  
  =head1 NAME
  
  JSON::Syck - JSON is YAML (but consider using L<JSON::XS> instead!)
  
  =head1 SYNOPSIS
  
      use JSON::Syck; # no exports by default 
  
      my $data = JSON::Syck::Load($json);
      my $json = JSON::Syck::Dump($data);
  
      # $file can be an IO object, or a filename
      my $data = JSON::Syck::LoadFile($file);
      JSON::Syck::DumpFile($file, $data);
  
      # Dump into a pre-existing buffer
      my $json;
      JSON::Syck::DumpInto(\$json, $data);
  
  =head1 DESCRIPTION
  
  JSON::Syck is a syck implementation of JSON parsing and generation. Because
  JSON is YAML (L<http://redhanded.hobix.com/inspect/yamlIsJson.html>), using
  syck gives you a fast and memory-efficient parser and dumper for JSON data
  representation.
  
  However, a newer module L<JSON::XS>, has since emerged.  It is more flexible,
  efficient and robust, so please consider using it instead of this module.
  
  =head1 DIFFERENCE WITH JSON
  
  You might want to know the difference between the I<JSON> module and
  this one.
  
  Since JSON is a pure-perl module and JSON::Syck is based on libsyck,
  JSON::Syck is supposed to be very fast and memory efficient. See
  chansen's benchmark table at
  L<http://idisk.mac.com/christian.hansen/Public/perl/serialize.pl>
  
  JSON.pm comes with dozens of ways to do the same thing and lots of
  options, while JSON::Syck doesn't. There's only C<Load> and C<Dump>.
  
  Oh, and JSON::Syck doesn't use camelCase method names :-)
  
  =head1 REFERENCES
  
  =head2 SCALAR REFERENCE
  
  For now, when you pass a scalar reference to JSON::Syck, it
  dereferences to get the actual scalar value.
  
  JSON::Syck raises an exception when you pass in circular references.
  
  If you want to serialize self refernecing stuff, you should use
  YAML which supports it.
  
  =head2 SUBROUTINE REFERENCE
  
  When you pass subroutine reference, JSON::Syck dumps it as null.
  
  =head1 UTF-8 FLAGS
  
  By default this module doesn't touch any of utf-8 flags set in
  strings, and assumes UTF-8 bytes to be passed and emit.
  
  However, when you set C<$JSON::Syck::ImplicitUnicode> to 1, this
  module properly decodes UTF-8 binaries and sets UTF-8 flag everywhere,
  as in:
  
    JSON (UTF-8 bytes)   => Perl (UTF-8 flagged)
    JSON (UTF-8 flagged) => Perl (UTF-8 flagged)
    Perl (UTF-8 bytes)   => JSON (UTF-8 flagged)
    Perl (UTF-8 flagged) => JSON (UTF-8 flagged)
  
  By default, JSON::Syck::Dump will only transverse up to 512 levels of
  a datastructure in order to avoid an infinite loop when it is
  presented with an circular reference.
  
  However, you set C<$JSON::Syck::MaxLevels> to a larger value if you
  have very complex structures.
  
  Unfortunately, there's no implicit way to dump Perl UTF-8 flagged data
  structure to utf-8 encoded JSON. To do this, simply use Encode module, e.g.:
  
    use Encode;
    use JSON::Syck qw(Dump);
  
    my $json = encode_utf8( Dump($data) );
  
  Alternatively you can use Encode::JavaScript::UCS to encode Unicode
  strings as in I<%uXXXX> form.
  
    use Encode;
    use Encode::JavaScript::UCS;
    use JSON::Syck qw(Dump);
  
    my $json_unicode_escaped = encode( 'JavaScript-UCS', Dump($data) );
  
  =head1 QUOTING
  
  According to the JSON specification, all JSON strings are to be double-quoted.
  However, when embedding JavaScript in HTML attributes, it may be more
  convenient to use single quotes.
  
  Set C<$JSON::Syck::SingleQuote> to 1 will make both C<Dump> and C<Load> expect
  single-quoted string literals.
  
  =head1 BUGS
  
  Dumping into tied (or other magic variables) with C<DumpInto> might not work
  properly in all cases.
  
  When dumping with C<DumpFile>, some spacing might be wrong and
  C<$JSON::Syck::SingleQuote> might be handled incorrectly.
  
  =head1 SEE ALSO
  
  L<JSON::XS>, L<YAML::Syck>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  Tatsuhiko Miyagawa E<lt>miyagawa@gmail.comE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005-2009 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  The F<libsyck> code bundled with this library is released by
  "why the lucky stiff", under a BSD-style license.  See the F<COPYING>
  file for details.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
X86_64-LINUX-THREAD-MULTI_JSON_SYCK

$fatpacked{"x86_64-linux-thread-multi/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle
    pairmap pairgrep pairfirst pairs pairkeys pairvalues
  );
  our $VERSION    = "1.38";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 $b = any { BLOCK } @list
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 $b = all { BLOCK } @list
  
  Similar to C<any>, except that it requires all elements of the C<@list> to make
  the C<BLOCK> return true. If any element returns false, then it returns false.
  If the C<BLOCK> never returns false or the C<@list> was empty then it returns
  true.
  
  =head2 $b = none { BLOCK } @list
  
  =head2 $b = notall { BLOCK } @list
  
  Similar to C<any> and C<all>, but with the return sense inverted. C<none>
  returns true only if no value in the LIST causes the BLOCK to return true, and
  C<notall> returns true only if not all of the values do.
  
  =head2 $val = first { BLOCK } @list
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 $num = max @list
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 $str = maxstr @list
  
  Similar to C<max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 $num = min @list
  
  Similar to C<max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 $str = minstr @list
  
  Similar to C<min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 $num = product @list
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 $num_or_undef = sum @list
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 $num = sum0 @list
  
  Similar to C<sum>, except this returns 0 when given an empty list, rather than
  C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  =cut
  
  =head2 @kvlist = pairgrep { BLOCK } @kvlist
  
  =head2 $count = pairgrep { BLOCK } @kvlist
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 ( $key, $val ) = pairfirst { BLOCK } @kvlist
  
  =head2 $found = pairfirst { BLOCK } @kvlist
  
  Similar to the C<first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 @list = pairmap { BLOCK } @kvlist
  
  =head2 $count = pairmap { BLOCK } @kvlist
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 @pairs = pairs @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of ARRAY references, each containing two items from the given
  list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach ( pairs @KVLIST ) {
         my ( $key, $value ) = @$_;
         ...
      }
  
  =head2 @keys = pairkeys @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 @values = pairvalues @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 @values = shuffle @values
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =cut
  
  =head1 KNOWN BUGS
  
  With perl versions prior to 5.005 there are some cases where reduce will return
  an incorrect result. This will show up as test 7 of reduce.t failing.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_UTIL

$fatpacked{"x86_64-linux-thread-multi/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use List::Util;
  
  our $VERSION = "1.38";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS

$fatpacked{"x86_64-linux-thread-multi/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  require Exporter;
  require List::Util; # List::Util loads the XS
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype tainted
  );
  our $VERSION    = "1.38";
  $VERSION   = eval $VERSION;
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 $pkg = blessed( $ref )
  
  If C<$ref> is a blessed reference the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 $addr = refaddr( $ref )
  
  If C<$ref> is reference the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 $type = reftype( $ref )
  
  If C<$ref> is a reference the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken( REF )
  
  The lvalue C<REF> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken( REF )
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  C<weaken()>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 $weak = isweak( $ref )
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 $var = dualvar( $num, $string )
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 $dual = isdual( $var )
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be dual-valued variable, it is actually
  implemented using a tied scalar:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 $vstring = isvstring( $var )
  
  If C<$var> is a scalar which was coded as a vstring the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 $isnum = looks_like_number( $var )
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 $fh = openhandle( $fh )
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 $ro = readonly( $var )
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 $code = set_prototype( $code, $prototype )
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 $t = tainted( $var )
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use C<isweak> or C<weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  C<isvstring> you will need to use a newer release of perl.
  
  =item C<NAME> is only available with the XS version of Scalar::Util
  
  C<Scalar::Util> contains both perl and C implementations of many of its
  functions so that those without access to a C compiler may still use it.
  However some of the functions are only available when a C compiler was
  available to compile the XS version of the extension.
  
  At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Except weaken and isweak which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL

$fatpacked{"x86_64-linux-thread-multi/YAML/Dumper/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_YAML_DUMPER_SYCK';
  package YAML::Dumper::Syck;
  use strict;
  
  sub new { $_[0] }
  sub dump { shift; YAML::Syck::Dump( $_[0] ) }
  
  1;
X86_64-LINUX-THREAD-MULTI_YAML_DUMPER_SYCK

$fatpacked{"x86_64-linux-thread-multi/YAML/Loader/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_YAML_LOADER_SYCK';
  package YAML::Loader::Syck;
  use strict;
  
  sub new { $_[0] }
  sub load { shift; YAML::Syck::Load( $_[0] ) }
  
  1;
X86_64-LINUX-THREAD-MULTI_YAML_LOADER_SYCK

$fatpacked{"x86_64-linux-thread-multi/YAML/Syck.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_YAML_SYCK';
  package YAML::Syck;
  
  # See documentation after the __END__ mark.
  
  use strict;
  use vars qw(
    @ISA @EXPORT @EXPORT_OK $VERSION
    $Headless $SortKeys $SingleQuote
    $ImplicitBinary $ImplicitTyping $ImplicitUnicode
    $UseCode $LoadCode $DumpCode
    $DeparseObject $LoadBlessed
  );
  use 5.006;
  use Exporter;
  
  BEGIN {
      $VERSION   = '1.27';
      @EXPORT    = qw( Dump Load DumpFile LoadFile );
      @EXPORT_OK = qw( DumpInto );
      @ISA       = qw( Exporter );
  
      $SortKeys    = 1;
      $LoadBlessed = 1;
  
      local $@;
      eval {
          require XSLoader;
          XSLoader::load( __PACKAGE__, $VERSION );
          1;
      } or do {
          require DynaLoader;
          push @ISA, 'DynaLoader';
          __PACKAGE__->bootstrap($VERSION);
      };
  
  }
  
  use constant QR_MAP => {
      ''   => sub { qr{$_[0]} },
      x    => sub { qr{$_[0]}x },
      i    => sub { qr{$_[0]}i },
      s    => sub { qr{$_[0]}s },
      m    => sub { qr{$_[0]}m },
      ix   => sub { qr{$_[0]}ix },
      sx   => sub { qr{$_[0]}sx },
      mx   => sub { qr{$_[0]}mx },
      si   => sub { qr{$_[0]}si },
      mi   => sub { qr{$_[0]}mi },
      ms   => sub { qr{$_[0]}sm },
      six  => sub { qr{$_[0]}six },
      mix  => sub { qr{$_[0]}mix },
      msx  => sub { qr{$_[0]}msx },
      msi  => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub __qr_helper {
      if ( $_[0] =~ /\A  \(\?  ([ixsm]*)  (?:-  (?:[ixsm]*))?  : (.*) \)  \z/x ) {
          my $sub = QR_MAP()->{$1} || QR_MAP()->{''};
          &$sub($2);
      }
      else {
          qr/$_[0]/;
      }
  }
  
  sub Dump {
      $#_
        ? join( '', map { YAML::Syck::DumpYAML($_) } @_ )
        : YAML::Syck::DumpYAML( $_[0] );
  }
  
  sub Load {
      if (wantarray) {
          my ($rv) = YAML::Syck::LoadYAML( $_[0] );
          @{$rv};
      }
      else {
          @_ = $_[0];
          goto &YAML::Syck::LoadYAML;
      }
  }
  
  sub _is_glob {
      my $h = shift;
  
      return 1 if ( ref($h) eq 'GLOB' );
      return 1 if ( ref( \$h ) eq 'GLOB' );
      return 1 if ( ref($h) =~ m/^IO::/ );
  
      return;
  }
  
  sub DumpFile {
      my $file = shift;
      if ( _is_glob($file) ) {
          for (@_) {
              my $err = YAML::Syck::DumpYAMLFile( $_, $file );
              if ($err) {
                  $! = 0 + $err;
                  die "Error writing to filehandle $file: $!\n";
              }
          }
      }
      else {
          open( my $fh, '>', $file ) or die "Cannot write to $file: $!";
          for (@_) {
              my $err = YAML::Syck::DumpYAMLFile( $_, $fh );
              if ($err) {
                  $! = 0 + $err;
                  die "Error writing to file $file: $!\n";
              }
          }
          close $fh
            or die "Error writing to file $file: $!\n";
      }
      return 1;
  }
  
  sub LoadFile {
      my $file = shift;
      if ( _is_glob($file) ) {
          Load(
              do { local $/; <$file> }
          );
      }
      else {
          if ( !-e $file || -z $file ) {
              die("'$file' is empty or non-existent");
          }
          open( my $fh, '<', $file ) or die "Cannot read from $file: $!";
          Load(
              do { local $/; <$fh> }
          );
      }
  }
  
  sub DumpInto {
      my $bufref = shift;
      ( ref $bufref ) or die "DumpInto not given reference to output buffer\n";
      YAML::Syck::DumpYAMLInto( $_, $bufref ) for @_;
      1;
  }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME 
  
  YAML::Syck - Fast, lightweight YAML loader and dumper
  
  =head1 SYNOPSIS
  
      use YAML::Syck;
  
      # Set this for interoperability with other YAML/Syck bindings:
      # e.g. Load('Yes') becomes 1 and Load('No') becomes ''.
      $YAML::Syck::ImplicitTyping = 1;
  
      $data = Load($yaml);
      $yaml = Dump($data);
  
      # $file can be an IO object, or a filename
      $data = LoadFile($file);
      DumpFile($file, $data);
  
      # A string with multiple YAML streams in it
      $yaml = Dump(@data);
      @data = Load($yaml);
  
      # Dumping into a pre-existing output buffer
      my $yaml;
      DumpInto(\$yaml, @data);
  
  =head1 DESCRIPTION
  
  This module provides a Perl interface to the B<libsyck> data serialization
  library.  It exports the C<Dump> and C<Load> functions for converting
  Perl data structures to YAML strings, and the other way around.
  
  B<NOTE>: If you are working with other language's YAML/Syck bindings
  (such as Ruby), please set C<$YAML::Syck::ImplicitTyping> to C<1> before
  calling the C<Load>/C<Dump> functions.  The default setting is for
  preserving backward-compatibility with C<YAML.pm>.
  
  =head1 Differences Between YAML::Syck and YAML
  
  =head2 Error handling
  
  Some calls are designed to die rather than returning YAML. You should wrap
  your calls in eval to assure you do not get unexpected results.
  
  =head1 FLAGS
  
  =head2 $YAML::Syck::Headless
  
  Defaults to false.  Setting this to a true value will make C<Dump> omit the
  leading C<---\n> marker.
  
  =head2 $YAML::Syck::SortKeys
  
  Defaults to false.  Setting this to a true value will make C<Dump> sort
  hash keys.
  
  =head2 $YAML::Syck::SingleQuote
  
  Defaults to false.  Setting this to a true value will make C<Dump> always emit
  single quotes instead of bare strings.
  
  =head2 $YAML::Syck::ImplicitTyping
  
  Defaults to false.  Setting this to a true value will make C<Load> recognize
  various implicit types in YAML, such as unquoted C<true>, C<false>, as well as
  integers and floating-point numbers.  Otherwise, only C<~> is recognized to
  be C<undef>.
  
  =head2 $YAML::Syck::ImplicitUnicode
  
  Defaults to false.  For Perl 5.8.0 or later, setting this to a true value will
  make C<Load> set Unicode flag on for every string that contains valid UTF8
  sequences, and make C<Dump> return a unicode string.
  
  Regardless of this flag, Unicode strings are dumped verbatim without escaping;
  byte strings with high-bit set will be dumped with backslash escaping.
  
  However, because YAML does not distinguish between these two kinds of strings,
  so this flag will affect loading of both variants of strings.
  
  If you want to use LoadFile or DumpFile with unicode, you are required to open
  your own file in order to assure it's UTF8 encoded:
  
    open(my $fh, ">:encoding(UTF-8)", "out.yml");
    DumpFile($fh, $hashref);
  
  =head2 $YAML::Syck::ImplicitBinary
  
  Defaults to false.  For Perl 5.8.0 or later, setting this to a true value will
  make C<Dump> generate Base64-encoded C<!!binary> data for all non-Unicode
  scalars containing high-bit bytes.
  
  =head2 $YAML::Syck::UseCode / $YAML::Syck::LoadCode / $YAML::Syck::DumpCode
  
  These flags control whether or not to try and eval/deparse perl source code;
  each of them defaults to false.
  
  Setting C<$YAML::Syck::UseCode> to a true value is equivalent to setting
  both C<$YAML::Syck::LoadCode> and C<$YAML::Syck::DumpCode> to true.
  
  =head2 $YAML::Syck::LoadBlessed
  
  Defaults to true. Setting to false will block YAML::Syck from doing ANY
  blessing. This is an interface change since 1.21. The variable name was
  misleading, implying that no blessing would happen when in fact it did.
  
  Prior to 1.22, setting this to a false value only prevented C<Load> from
  blessing tag names that did not begin with C<!!perl> or C<!perl>;.
  
  =head1 BUGS
  
  Dumping Glob/IO values do not work yet.
  
  Dumping of Tied variables is unsupported.
  
  Dumping into tied (or other magic variables) with C<DumpInto> might not work
  properly in all cases.
  
  =head1 CAVEATS
  
  This module implements the YAML 1.0 spec.  To deal with data in YAML 1.1, 
  please use the C<YAML::XS> module instead.
  
  The current implementation bundles libsyck source code; if your system has a
  site-wide shared libsyck, it will I<not> be used.
  
  Tag names such as C<!!perl/hash:Foo> is blessed into the package C<Foo>, but
  the C<!hs/foo> and C<!!hs/Foo> tags are blessed into C<hs::Foo>.  Note that
  this holds true even if the tag contains non-word characters; for example,
  C<!haskell.org/Foo> is blessed into C<haskell.org::Foo>.  Please use
  L<Class::Rebless> to cast it into other user-defined packages. You can also
  set the LoadBlessed flag false to disable all blessing.
  
  This module has L<a lot of known
  issues|https://rt.cpan.org/Public/Dist/Display.html?Name=YAML-Syck>
  and has only been semi-actively maintained since 2007. If you
  encounter an issue with it probably won't be fixed unless you L<offer
  up a patch|http://github.com/toddr/YAML-Syck> in Git that's ready for
  release.
  
  There are still good reasons to use this module, such as better
  interoperability with other syck wrappers (like Ruby's), or some edge
  case of YAML's syntax that it handles better. It'll probably work
  perfectly for you, but if it doesn't you may want to look at
  L<YAML::XS>, or perhaps at looking another serialization format like
  L<JSON>.
  
  =head1 SEE ALSO
  
  L<YAML>, L<JSON::Syck>
  
  L<http://www.yaml.org/>
  
  =head1 AUTHORS
  
  Audrey Tang E<lt>cpan@audreyt.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005-2009 by Audrey Tang E<lt>cpan@audreyt.orgE<gt>.
  
  This software is released under the MIT license cited below.
  
  The F<libsyck> code bundled with this library is released by
  "why the lucky stiff", under a BSD-style license.  See the F<COPYING>
  file for details.
  
  =head2 The "MIT" License
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  
  =cut
X86_64-LINUX-THREAD-MULTI_YAML_SYCK

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use Modern::Perl;
use YAML::Any;
use Graph;
use Path::Tiny;

# BASIC BLOCKING DISPATCHER
#
# Currently read yaml file into graph - then go through the job_ids and see 
# if they have a dependency - if not execute and delete from graph - if do skip
# and keep going until no graph left. Probably better way to do this breadth first 
# and focus on leaves

die "Did not receive plite yaml file " unless defined($ARGV[0]);
my $plite_yaml = path($ARGV[0]);
my $pipeline_graph_and_jobs_yaml = $plite_yaml->slurp;
my $graph_and_jobs = Load( $pipeline_graph_and_jobs_yaml );
my $graph = make_graph( $graph_and_jobs);
my @job_ids = $graph->vertices;
dispatch_simple(\@job_ids, $graph);

sub make_graph {
   my $jobs = shift;
   my $graph = Graph->new;
 
   foreach my $job_num (keys %$jobs){
     my $job = $jobs->{$job_num};
     foreach my $stepinjob ( keys %$job ) {
       my $dependents = $job->{$stepinjob}->{dependents};
       if( @$dependents > 0 ){
          foreach my $dependency (@$dependents) {
              $graph->add_edge( $dependency, "$job_num.$stepinjob" );  #print "added  $dependency - $job_num.$stepinjob  to graph\n";            
          }
       }else{          
        $graph->add_vertex("$job_num.$stepinjob"); #print "add vertex $job_num.$stepinjob\n";
       }          
     }   
   }
   return $graph; 
}

sub dispatch_simple {  
  my ($job_ids, $graph ) = @_;
  my $job_id;
  while( @$job_ids > 0 ){    
      $job_id = shift @$job_ids;
      if( $graph->predecessors($job_id) > 0 ) {
        push ( @$job_ids, $job_id); #goes back on the end   #warn "That one had a dependency put to back";         
      }else{
        
        my ($job,$step) = split(/\./,$job_id); #print "system $job_id\n";
        #print "Dispatch job $job and step $step:\n " . $graph_and_jobs->{ $job }->{$step}->{cmd}, "\n" ;
        system( $graph_and_jobs->{ $job }->{$step}->{cmd} );  
        $graph->delete_vertex($job_id);
      }    
  } 
}